00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/16/2018 11:10:20 PM

00000000                             1  *-----------------------------------------------------------------------------------------------
00000000                             2  *                                  Disassembler program
00000000                             3  *                                      Winter 2018
00000000                             4  * Description: A program to disassemble selected instructions from the Motorola 68k IS opcodes
00000000                             5  *                         
00000000                             6  *                          Sean Coulter, Corin Ennis, Antony Mbugua
00000000                             7  *-----------------------------------------------------------------------------------------------            
00000000                             8              
00000000  =0000000D                  9  CR         EQU   $0D
00000000  =0000000A                 10  LF         EQU   $0A
00000000  =00007000                 11  stack      EQU   $7000
00000000  =00001000                 12  start_addr EQU   $1000
00000000                            13             
00001000                            14  start      ORG     start_addr             
00001000                            15                
00001000                            16  *----------------*display starting information for user, capture start and end addresses, error check on addresses------------------------------
00001000                            17  *----------------for each ascii character the user enters, if that character is outside [30,40) (40,46], its an invalid character---------------
00001000                            18      *A2: points to starting address
00001000                            19      *A3: points to ending address
00001000                            20      *A4: points to ascii/hex string table
00001000                            21      
00001000                            22      *D3: holds the next byte of the user starting address
00001000                            23      *D3: holds length of user input
00001000                            24      *D4: offset of string table value
00001000                            25  
00001000  4FF8 7000                 26                LEA     stack, SP         *put the stack in the stack pointer
00001004                            27                
00001004  43F9 00004184             28  disp_msg      LEA     display_start,A1  *load intro msg to A1
0000100A  103C 000E                 29                MOVE.B  #14,D0            *indicate output
0000100E  4E4F                      30                TRAP    #15
00001010                            31                
00001010  49F9 00004000             32                LEA     string_tbl,A4 *load A4 with the string table
00001016                            33                
00001016  43F9 0000424E             34                LEA     user_start,A1 *load user input variable address to A1
0000101C  103C 0002                 35                MOVE.B  #2,D0         *indicate saving user input to loaded variable in A1
00001020  4E4F                      36                TRAP    #15
00001022                            37                
00001022  3039 00004256             38                MOVE.W  exit_val,D0
00001028  B079 0000424E             39                CMP.W   user_start,D0  *did the user want to quit?
0000102E  6700 1196                 40                BEQ     done           * yes-quit
00001032                            41                
00001032  B2BC 00000008             42                CMP.L   #8,D1         *is the starting address <= 8 hex digits?
00001038  6E00 11AA                 43                BGT     addr_err      * no-invalid
0000103C  B2BC 00000000             44                CMP.L   #0,D1         *user didnt type anything
00001042  6F00 11A0                 45                BLE     addr_err
00001046                            46                
00001046  1601                      47                MOVE.B  D1,D3         *store length of start address (task #2) in D3
00001048  4241                      48                CLR     D1            *clear D1 for use in the folllowing subroutine
0000104A  4EB9 00001056             49                JSR     conversion    *enter loop to convert ascii string to hex
00001050  DBC7                      50                ADDA.L  D7,A5          *store start address in A5
00001052  6000 0042                 51                BRA     end_addr      *we've converted the valid string to hex--get the end address now     
00001056                            52             
00001056                            53  *********************SUBROUTINE converts user input (ascii) to hex**********************************************
00001056  4287                      54  conversion    CLR.L  D7
00001058  3C7C 0000                 55                MOVEA  #0,A6         *clear the address register being used to store the conversion data
0000105C                            56                
0000105C  1419                      57  get_next_byte MOVE.B (A1)+,D2      *move next byte of input address to D2
0000105E  4244                      58                CLR    D4            *reset index offset in string table
00001060  5303                      59                SUBI.B #1,D3         *decrement the loop counter (length of user string)
00001062  B63C 00FF                 60                CMP.B  #-1,D3        *have we converted the whole address?
00001066  6700 002C                 61                BEQ    end_conv      * yes-return from the subroutine
0000106A  6000 0002                 62                BRA    char_convert  * no-convert the next character from ascii -> hex
0000106E                            63                
0000106E  B434 4000                 64  char_convert  CMP.B   (A4,D4.W),D2 *compare this byte with the next value in string table
00001072  6700 000E                 65                BEQ     push_byte    *we found the corresponding hex
00001076  5444                      66                ADDI    #2,D4          *Next index of string table
00001078  B83C 001F                 67                CMP.B   #31,D4         *check if we're outside the table (indicates invalid hex input)
0000107C  6E00 1166                 68                BGT     addr_err       * we're outside the table, so user input character wasn't hex-convertible
00001080  60EC                      69                BRA     char_convert   *check the next string table value
00001082                            70                
00001082  1234 4001                 71  push_byte     MOVE.B 1(A4,D4.W),D1
00001086  DE81                      72                ADD.L  D1,D7
00001088  B63C 0000                 73                CMP.B  #0,D3
0000108C  6700 0006                 74                BEQ    end_conv
00001090  E98F                      75                LSL.L  #4,D7
00001092  60C8                      76                BRA    get_next_byte      
00001094  4E75                      77  end_conv      RTS
00001096                            78  ******************************************************************************************************************  
00001096                            79        
00001096                            80  *------------------- by this point, the starting address is valid and stored in A5.*--------------------------------
00001096                            81                
00001096  4281                      82  end_addr      CLR.L   D1
00001098  43F9 000041D2             83                LEA     display_end,A1
0000109E  103C 000E                 84                MOVE.B  #14,D0        *indicate display
000010A2  4E4F                      85                TRAP    #15
000010A4                            86                
000010A4  43F9 00004252             87                LEA     user_end,A1
000010AA  103C 0002                 88                MOVE.B  #2,D0         * trap user ending address   
000010AE  4E4F                      89                TRAP    #15
000010B0                            90                
000010B0  3039 00004256             91                MOVE.W  exit_val,D0
000010B6  B079 00004252             92                CMP.W   user_end,D0  *did the user want to quit?
000010BC  6700 1108                 93                BEQ     done          * yes-quit
000010C0                            94                
000010C0  B2BC 00000008             95                CMP.L   #8,D1         *is the starting address 8 hex digits?
000010C6  6E00 111C                 96                BGT     addr_err      * no-invalid
000010CA  B2BC 00000000             97                CMP.L   #0,D1         *user didnt type anything
000010D0  6F00 1112                 98                BLE     addr_err
000010D4                            99                
000010D4  1601                     100                MOVE.B  D1,D3         *store length of start address (task #2) in D3
000010D6  4EB8 1056                101                JSR     conversion    *convert(above) the ending address from ascii to hex
000010DA  DDC7                     102                ADDA.L  D7,A6         *store end address in A5
000010DC  6000 0006                103                BRA     prep          *begin initial steps before parsing data at user address
000010E0                           104  
000010E0                           105  *------------------At this point, A5 holds starting address and A6 holds ending address. --------------------------------
000010E0                           106  *A5: start
000010E0                           107  *A6: end
000010E0                           108  *A4: pointer to hex_1 table and bcc_tbl
000010E0                           109  *D1: holds the next hex to be read in instruction
000010E0                           110  *D2: holds the instruction
000010E0                           111                
000010E0  4244                     112                CLR      D4                 *register used in address calculation
000010E2  4247                     113                CLR      D7                 *register used for address calculation
000010E4                           114  
000010E4  BDCD                     115  prep          CMPA.L   A5,A6              *have we read from start-end?
000010E6  6D00 10DE                116                BLT      done               * yes-end            
000010EA  103C 0005                117                MOVE.B   #5,D0              *pause for user to hit enter
000010EE  4E4F                     118                TRAP     #15
000010F0  43F9 0000417C            119                LEA      nl,A1              *make an new line
000010F6  103C 000E                120                MOVE.B   #14,D0
000010FA  4E4F                     121                TRAP     #15
000010FC  49F9 00004020            122                LEA      hex_1,A4           *pointer to hex_1 table in A4
00001102  227C 00000000            123                MOVEA.L  #0,A1              *clearing variables
00001108  23FC 00000000 00004148   124                MOVE.L   #0,SIZECODE
00001112  23FC 00000000 00004168   125                MOVE.L   #0,INST_NAME_EXT
0000111C                           126                *EOR      D0,D0
0000111C  4280                     127                CLR.L    D0
0000111E  4281                     128                CLR.L    D1
00001120  4282                     129                CLR.L    D2
00001122  4283                     130                CLR.L    D3
00001124  4284                     131                CLR.L    D4
00001126  4285                     132                CLR.L    D5
00001128  4286                     133                CLR.L    D6
0000112A  4287                     134                CLR.L    D7            
0000112C  3215                     135                MOVE.W   (A5),D1            *move the instruction thats pointed to by starting address
0000112E  2641                     136                MOVE.L   D1,A3              *and copy it to A3
00001130  4841                     137                SWAP     D1
00001132  E999                     138                ROL.L    #4,D1              *isolate the first hex digit
00001134                           139               
00001134  B21C                     140  check_first   CMP.B   (A4)+,D1            *compare with the next value in the hex table
00001136  6700 0038                141                BEQ     match_found         *theres a match with the value in the table
0000113A  524C                     142                ADDA    #1,A4               *increment the pointer to the table
0000113C  0C14 00FF                143                CMP.B   #$FF,(A4)           *have we reached the end of the hex table?
00001140  6700 0004                144                BEQ     inv_handler         * yes-no matches (so output DATA)
00001144  60EE                     145                BRA     check_first         *keep searching through the table for a match           
00001146                           146       
00001146                           147  *-----------------------------------------------------------------------------
00001146                           148  * inv_handler
00001146                           149  * handles unsupported instruction names
00001146                           150  * prints DATA for instruction name 
00001146                           151                  
00001146  23F9 00004114 00004160   152  inv_handler   MOVE.L  DAT,INST_NAME
00001150  23F9 00004124 00004168   153                MOVE.L  A,INST_NAME_EXT
0000115A  4EB9 000020B4            154                JSR     disp_instr
00001160  204B                     155                MOVE.L  A3,A0
00001162  4EB9 00002108            156                JSR     hex_2_ascii       *convert/display the unsupported opcode
00001168  DAFC 0002                157                ADDA    #word_len,A5
0000116C  6000 FF76                158                BRA     prep
00001170                           159                
00001170                           160  * /inv_handler
00001170                           161  *-----------------------------------------------------------------------------
00001170                           162  
00001170                           163  **below functions handle instructions that are supported in this program**
00001170                           164  
00001170  0C14 0001                165  match_found   CMP.B   #1,(A4)             *check if the mapping is ambiguous
00001174  6700 0006                166                BEQ     inst_parse          * it is- get the next hex digit
00001178  6000 0268                167                BRA     get_data            * its not-- just branch straight to the corresponding function
0000117C                           168                            
0000117C  B23C 0001                169  inst_parse    CMP.B   #1,D1            *based on the first digit, decide how to decode next value.
00001180  6700 0044                170                BEQ     _1_handler
00001184  B23C 0003                171                CMP.B   #3,D1
00001188  6700 00A8                172                BEQ     _3_handler
0000118C  B23C 0002                173                CMP.B   #2,D1
00001190  6700 00CA                174                BEQ     _2_handler
00001194  B23C 0004                175                CMP.B   #4,D1
00001198  6700 00F0                176                BEQ     _4_handler
0000119C  B23C 000D                177                CMP.B   #13,D1
000011A0  6700 0168                178                BEQ     _13_handler
000011A4  B23C 0000                179                CMP.B   #0,D1
000011A8  6700 0176                180                BEQ     _0_handler
000011AC  B23C 000B                181                CMP.B   #11,D1
000011B0  6700 01B4                182                BEQ     _11_handler
000011B4  B23C 0008                183                CMP.B   #8,D1
000011B8  6700 01EA                184                BEQ     _8_handler
000011BC  B23C 0005                185                CMP.B   #5,D1
000011C0  6700 0210                186                BEQ     _5_handler
000011C4  6080                     187                BRA     inv_handler
000011C6                           188  
000011C6                           189  *The following functions determine where to go if the first hex value is shared between instructions             
000011C6                           190  *---------------           
000011C6  4201                     191  _1_handler    CLR.B   D1
000011C8  23F9 0000403C 00004160   192                MOVE.L  MOV,INST_NAME
000011D2  23F9 0000413C 00004148   193                MOVE.L  SIZEB,SIZECODE
000011DC  14BC 0000                194                MOVE.B  #0,(A2)        *flag data as byte
000011E0  E799                     195                ROL.L   #3,D1          *isolate dest. An or Dn bits (t.b.d. if MOVE or MOVEA)
000011E2  1401                     196                MOVE.B  D1,D2          *and move them to D2
000011E4  4201                     197                CLR.B   D1
000011E6  E799                     198                ROL.L   #3,D1          *isolate dest. mode bits in D1.B
000011E8  B23C 0001                199                CMP.B   #1,D1          *is mode == 001?
000011EC  6700 0010                200                BEQ     movea_handler * yes- its movea
000011F0                           201                
000011F0  23F9 00004132 00004168   202  move_handler MOVE.L  E,INST_NAME_EXT
000011FA  6000 000C                203               BRA     move_ea
000011FE                           204  
000011FE  23F9 00004138 00004168   205  movea_handler MOVE.L EA,INST_NAME_EXT     
00001208                           206  
00001208  1801                     207  move_ea       MOVE.B D1,D4         *save dest mode bits to D4
0000120A  4201                     208                CLR.B  D1
0000120C  E799                     209                ROL.L  #3,D1
0000120E  2601                     210                MOVE.L D1,D3         *save source mode/reg bits in D3
00001210  4EB9 000020B4            211                JSR    disp_instr    *print MOVEA.(X) or MOVE.(X)
00001216  4EB9 00001DAE            212                JSR    EA_SRC_beg    *print source information
0000121C                           213                
0000121C  E69A                     214                ROR.L  #3,D2         *roll dest register bits to left fringe
0000121E  1404                     215                MOVE.B D4,D2         *move dest mode bits to right fringe
00001220  2602                     216                MOVE.L D2,D3         *move these same bits to D3
00001222  4EB9 0000216E            217                JSR    print_comma
00001228  4EB9 00001DB2            218                JSR    EA_SRC        *prints destination mode/register
0000122E  6000 FEB4                219                BRA    prep
00001232                           220  
00001232                           221  *--------------- 
00001232                           222  *---------------
00001232  4201                     223  _3_handler    CLR.B   D1
00001234  23F9 0000403C 00004160   224                MOVE.L  MOV,INST_NAME
0000123E  23F9 00004140 00004148   225                MOVE.L  SIZEW,SIZECODE
00001248  14BC 0001                226                MOVE.B  #1,(A2)        *flag data as word
0000124C  E799                     227                ROL.L   #3,D1          *isolate dest. An or Dn bits (t.b.d. if MOVE or MOVEA)
0000124E  1401                     228                MOVE.B  D1,D2          *and move them to D2
00001250  4201                     229                CLR.B   D1
00001252  E799                     230                ROL.L   #3,D1          *isolate dest. mode bits in D1.B
00001254  B23C 0001                231                CMP.B   #1,D1          *is mode == 001?
00001258  67A4                     232                BEQ     movea_handler * yes- its movea (function is subset of _1_handler)
0000125A  6094                     233                BRA     move_handler  * no- its move (function is subset of _1_handler)
0000125C                           234                
0000125C                           235  *--------------- 
0000125C                           236  *--------------- 
0000125C  4201                     237  _2_handler    CLR.B   D1
0000125E  23F9 0000403C 00004160   238                MOVE.L  MOV,INST_NAME
00001268  23F9 00004144 00004148   239                MOVE.L  SIZEL,SIZECODE
00001272  14BC 0002                240                MOVE.B  #2,(A2)        *flag data as long
00001276  E799                     241                ROL.L   #3,D1          *isolate dest. An or Dn bits (t.b.d. if MOVE or MOVEA)
00001278  1401                     242                MOVE.B  D1,D2          *and move them to D2
0000127A  4201                     243                CLR.B   D1
0000127C  E799                     244                ROL.L   #3,D1          *isolate dest. mode bits in D1.B
0000127E  B23C 0001                245                CMP.B   #1,D1          *is mode == 001?
00001282  6700 FF7A                246                BEQ     movea_handler * yes- its movea (function is subset of _1_handler)
00001286  6000 FF68                247                BRA     move_handler  * no- its move (function is subset of _1_handler)
0000128A                           248  
0000128A                           249  *--------------- 
0000128A                           250  *--------------- 
0000128A  B6FC 4E71                251  _4_handler    CMP.W   #$4E71,A3        *is it nop
0000128E  6700 017A                252                BEQ     nop_handler      * its nop
00001292  B6FC 4E75                253                CMP.W   #$4E75,A3        *is it rts
00001296  6700 0AFC                254                BEQ     rts_handler      * its rts
0000129A  4201                     255                CLR.B   D1               *get byte space ready for next digit
0000129C  E999                     256                ROL.L   #4,D1            *get the next digit
0000129E  2401                     257                MOVE.L  D1,D2            *make a temp copy
000012A0  E59A                     258                ROL.L   #2,D2            *get another 3 bits
000012A2  B43C 003A                259                CMP.B   #$3A,D2          *is 3A in the byte position
000012A6  6700 09C8                260                BEQ     jsr_handler      * yes its jsr
000012AA  B23C 0004                261                CMP.B   #4,D1            *is the next digit 4
000012AE  6700 0006                262                BEQ     neg_resolve      * neg or MOVE to CCR
000012B2  6000 0012                263                BRA     _4_resolve       *now its either lea,movem,unsupported
000012B6  4202                     264  neg_resolve   CLR.B   D2
000012B8  E51A                     265                ROL.B   #2,D2
000012BA  B43C 0003                266                CMP.B   #3,D2
000012BE  6D00 0610                267                BLT     neg_handler
000012C2  6000 FE82                268                BRA     inv_handler                                       
000012C6  2401                     269  _4_resolve    MOVE.L  D1,D2            *make a full copy to D2
000012C8  2801                     270                MOVE.L  D1,D4            *make another full copy
000012CA  E20A                     271                LSR.B   #1,D2            *lea and movem differentiated by current MSB        
000012CC  6500 0006                272                BCS     lea_resolve      * carry set- lea or unsupported
000012D0  6000 0014                273                BRA     movem_resolve    * carry not set-movem or unsupported
000012D4  4202                     274  lea_resolve   CLR.B   D2
000012D6  E59A                     275                ROL.L   #2,D2            *lea is unique in bits d8 to d6. use previous copy D2
000012D8  ED0A                     276                LSL.B   #6,D2            *shift out 0 pad and remaining An bits
000012DA  B43C 00C0                277                CMP.B   #$C0,D2          *is result 11000000?
000012DE  6700 095C                278                BEQ     lea_handler      * lea
000012E2  6000 FE62                279                BRA     inv_handler      * unsupported
000012E6  E39C                     280  movem_resolve ROL.L   #1,D4
000012E8  B83C 0019                281                CMP.B   #25,D4
000012EC  6600 0012                282                BNE     movem_check      *last check on movem
000012F0  4204                     283  is_it_movem   CLR.B   D4               *this is either MOVEM register to memory or EXT
000012F2  E79C                     284                ROL.L   #3,D4            *get ea mode into d2
000012F4  B83C 0000                285                CMP.B   #0,D4            *is the ea mode 000?
000012F8  6700 FE4C                286                BEQ     inv_handler      * yes-ea mode is data register-- cant be movem
000012FC  6000 0992                287                BRA     movem_handler    * no-its movem
00001300                           288                
00001300  B83C 0011                289  movem_check   CMP.B   #17,D4          
00001304  6600 FE40                290                BNE     inv_handler      *we can be sure its not movem now
00001308  60E6                     291                BRA     is_it_movem      *EXT or MOVEM
0000130A                           292                        
0000130A                           293  *--------------- 
0000130A                           294  *--------------- 
0000130A  4201                     295  _13_handler     CLR.B   D1
0000130C  E999                     296                  ROL.L   #4,D1
0000130E  2401                     297                  MOVE.L  D1,D2          *make a copy
00001310  4202                     298                  CLR.B   D2             *clear byte space for next roll
00001312  E59A                     299                  ROL.L   #2,D2          *get size bits
00001314  B43C 0003                300                  CMP.B   #3,D2          *are size bits 11?
00001318  6700 0108                301                  BEQ     adda_handler
0000131C  6000 0248                302                  BRA     add_handler
00001320                           303  
00001320                           304  *--------------- 
00001320                           305  *--------------- 
00001320  4201                     306  _0_handler      CLR.B D1
00001322  E999                     307                  ROL.L #4,D1         *the next 4 bits will determine the instruction exactly
00001324  B23C 0000                308                  CMP.B #0,D1
00001328  6700 04DC                309                  BEQ   ori_handler
0000132C  B23C 0004                310                  CMP.B #4,D1
00001330  6700 056C                311                  BEQ   subi_handler
00001334  B23C 000A                312                  CMP.B #$A,D1
00001338  6700 0532                313                  BEQ   eori_handler
0000133C  B23C 0008                314                  CMP.B #8,D1
00001340  6700 043E                315                  BEQ   bclr_static
00001344  B23C 000C                316                  CMP.B #$C,D1
00001348  6700 03A8                317                  BEQ   cmpi_handler
0000134C  B23C 0006                318                  CMP.B #6,D1
00001350  6700 04E8                319                  BEQ   addi_handler
00001354                           320                                      *at this point its BCLR or its unsupported
00001354  2401                     321                  MOVE.L D1,D2        *make a copy
00001356  4202                     322                  CLR.B  D2
00001358  E59A                     323                  ROL.L  #2,D2        *get next 2 hardcoded bits
0000135A  B43C 0002                324                  CMP.B  #2,D2        *BCLR bits defined as 10
0000135E  6700 046A                325                  BEQ    bclr_dynamic  *BCLR with a Dn (dynamic)
00001362  6000 FDE2                326                  BRA    inv_handler   *unsupported instruction
00001366                           327  
00001366                           328  *--------------- 
00001366                           329  *--------------- 
00001366  4201                     330  _11_handler     CLR.B   D1          
00001368  E999                     331                  ROL.L   #4,D1      *get next hex digit
0000136A  2401                     332                  MOVE.L  D1,D2      *make a temp copy
0000136C  E20A                     333                  LSR.B   #1,D2      * eor and cmp can be differentiated by lsb in 2nd digit. check carry
0000136E  6500 0006                334                  BCS     _11_resolve  *check if its eor,cpma(long), or cmpm(unsupported)
00001372  6000 0020                335                  BRA     cmpa_or_cmp  *its cmp or cmpa
00001376  2401                     336  _11_resolve     MOVE.L  D1,D2       *make a copy
00001378  4202                     337                  CLR.B   D2
0000137A  E59A                     338                  ROL.L   #2,D2
0000137C  B43C 0003                339                  CMP.B   #3,D2
00001380  6700 0112                340                  BEQ     cmpa_handler    *its cmpa (long)
00001384  4202                     341                  CLR.B   D2              *down to eor or cmpm
00001386  E79A                     342                  ROL.L   #3,D2           *get EA mode
00001388  B43C 0001                343                  CMP.B   #1,D2
0000138C  6700 FDB8                344                  BEQ     inv_handler     *cmpm
00001390  6000 020E                345                  BRA     eor_handler     *eor
00001394  4202                     346  cmpa_or_cmp     CLR.B   D2
00001396  E59A                     347                  ROL.L   #2,D2           *get the size code
00001398  B43C 0003                348                  CMP.B   #3,D2           *whats the size code
0000139C  6700 00F6                349                  BEQ     cmpa_handler    * size code 11-cmpa
000013A0  6000 0210                350                  BRA     cmp_handler     * size code !11-cmp
000013A4                           351  
000013A4                           352  *---------------
000013A4                           353  *---------------
000013A4  4201                     354  _8_handler      CLR.B   D1
000013A6  E999                     355                  ROL.L   #4,D1
000013A8  2401                     356                  MOVE.L  D1,D2
000013AA  E20A                     357                  LSR.B   #1,D2
000013AC  6500 0012                358                  BCS     _8_check              
000013B0  4202                     359                  CLR.B   D2                  *carry not set- OR or DIVU
000013B2  E59A                     360                  ROL.L   #2,D2
000013B4  B43C 0003                361                  CMP.B   #3,D2
000013B8  6700 FD8C                362                  BEQ     inv_handler         *DIVU
000013BC  6000 00E2                363                  BRA     or_handler
000013C0                           364                  
000013C0  4202                     365  _8_check        CLR.B   D2                  *its OR, DIVS, or SBCD
000013C2  E59A                     366                  ROL.L   #2,D2
000013C4  B43C 0003                367                  CMP.B   #3,D2
000013C8  6700 01FA                368                  BEQ     divsw_handler       *between or and divs.w, only divs.w can have a size 11
000013CC  4202                     369                  CLR.B   D2
000013CE  6000 00D0                370                  BRA     or_handler          *figure out if its OR or SBCD in here
000013D2                           371                      
000013D2                           372  *---------------
000013D2                           373  *--------------- 
000013D2  4201                     374  _5_handler      CLR.B   D1
000013D4  E999                     375                  ROL.L   #4,D1
000013D6  1401                     376                  MOVE.B  D1,D2               *D2 now holds the immediate data
000013D8  E20A                     377                  LSR.B   #1,D2               *check if carry is set-- this will determine branch
000013DA  6500 025E                378                  BCS     subq_handler
000013DE  6000 0304                379                  BRA     addq_handler
000013E2                           380                  
000013E2                           381  *---------------
000013E2                           382  *--------------- 
000013E2                           383  
000013E2                           384  *we can go directly to the function since the first hex val maps directly to an instruction
000013E2  B23C 0006                385  get_data      CMP.B   #6,D1
000013E6  6700 0546                386                BEQ     bcc_handler
000013EA  B23C 000E                387                CMP.B   #$E,D1
000013EE  6700 06BE                388                BEQ     _shift_roll_handler
000013F2  B23C 0009                389                CMP.B   #9,D1
000013F6  6700 0184                390                BEQ     sub_handler
000013FA  B23C 0005                391                CMP.B   #5,D1
000013FE  6700 023A                392                BEQ     subq_handler
00001402  B23C 000C                393                CMP.B   #$C,D1
00001406  6700 0202                394                BEQ     muls_handler
0000140A                           395  *----------------------------------------------------------------------------
0000140A                           396  *----------------------------------------------------------------------------              
0000140A                           397  *----------------------------------------------------------------------------
0000140A                           398  *nop_handler
0000140A                           399  *handles 'NOP'
0000140A                           400  
0000140A  23F9 00004064 00004160   401  nop_handler   MOVE.L  NOP,INST_NAME 
00001414  DAFC 0002                402                ADDA    #word_len,A5         *nop took up a word- set A5 to the next instruction
00001418  4EB9 000020B4            403                JSR     disp_instr
0000141E  6000 FCC4                404                BRA     prep
00001422                           405  
00001422                           406  * /nop_handler
00001422                           407  *----------------------------------------------------------------------------
00001422                           408  
00001422                           409  
00001422                           410  *----------------------------------------------------------------------------
00001422                           411  *adda_handler
00001422                           412  *handles 'ADDA'
00001422                           413  
00001422  23F9 0000406C 00004160   414  adda_handler       MOVE.L ADD,INST_NAME  *we know its valid instr ADDA
0000142C  33F9 00004124 00004168   415  adda_beg           MOVE.W A,INST_NAME_EXT
00001436  E209                     416                     LSR.B  #1,D1                *send the size bit to carry
00001438  6500 0018                417                     BCS    adda_long_handler    *carry is set->ADDA.W
0000143C  6000 0002                418                     BRA    adda_word_handler    *carry not set->ADDA.L
00001440                           419                     
00001440  23F9 00004140 00004148   420  adda_word_handler  MOVE.L SIZEW,SIZECODE
0000144A  14BC 0001                421                     MOVE.B #1,(A2)
0000144E  6000 0010                422                     BRA    adda_save_data
00001452                           423                     
00001452  23F9 00004144 00004148   424  adda_long_handler  MOVE.L SIZEL,SIZECODE
0000145C  14BC 0002                425                     MOVE.B #2,(A2)
00001460                           426                              
00001460  4EB9 000020B4            427  adda_save_data     JSR    disp_instr
00001466  1A01                     428                     MOVE.B D1,D5             *move the 3 An bits to D5 temporarily
00001468  E599                     429                     ROL.L  #2,D1             *get hardcoded size bits
0000146A  4201                     430                     CLR.B  D1                *and clear the byte space
0000146C  E799                     431                     ROL.L  #3,D1
0000146E  2601                     432                     MOVE.L D1,D3             *send EA bits to D3
00001470  4EB9 00001DAE            433                     JSR    EA_SRC_beg
00001476  4EB9 0000216E            434                     JSR    print_comma
0000147C  C745                     435                     EXG    D3,D5             *send An bits to D3 for function call
0000147E  4EB9 00001E88            436                     JSR    PRINT_INNER_An
00001484  6000 FC5E                437                     BRA    prep                     
00001488                           438  
00001488                           439  * /adda_handler
00001488                           440  *----------------------------------------------------------------------------
00001488                           441  
00001488                           442  
00001488                           443  *-----------------------------------------------------------------------------
00001488                           444  * suba_handler
00001488                           445  * handles 'SUBA'
00001488                           446  
00001488                           447  *uses adda_handler due to similar bit layout
00001488                           448  
00001488  23F9 000040F8 00004160   449  suba_handler       MOVE.L   SUB,INST_NAME
00001492  6098                     450                     BRA      adda_beg
00001494                           451  
00001494                           452  * /suba_handler
00001494                           453  *-----------------------------------------------------------------------------
00001494                           454  
00001494                           455  
00001494                           456  *-----------------------------------------------------------------------------
00001494                           457  * cmpa_handler
00001494                           458  * handles 'CMPA'
00001494                           459  
00001494                           460  *uses adda_handler due to similar bit layout
00001494                           461  
00001494  23F9 0000408C 00004160   462  cmpa_handler       MOVE.L   CMP,INST_NAME
0000149E  608C                     463                     BRA      adda_beg
000014A0                           464  
000014A0                           465  * /cmpa_handler
000014A0                           466  *-----------------------------------------------------------------------------
000014A0                           467  
000014A0                           468  
000014A0                           469  *-----------------------------------------------------------------------------
000014A0                           470  *or_handler
000014A0                           471  *handles 'OR'
000014A0                           472  
000014A0                           473  *D7 holds the direction flag
000014A0                           474  *D5 holds source/destination bits
000014A0                           475  *D4 holds the 2 size bits
000014A0                           476  *D3 holds the parameters used for jumps to EA handlers
000014A0                           477  
000014A0                           478  *Dn_left means the Dn is the dest
000014A0                           479  *Dn_right means the Dn is the source
000014A0                           480  
000014A0  E59A                     481  or_handler     ROL.L    #2,D2
000014A2  B43C 0000                482                 CMP.B    #0,D2
000014A6  6700 FC9E                483                 BEQ      inv_handler    *SBCD
000014AA  23F9 00004110 00004160   484                 MOVE.L   OR,INST_NAME
000014B4  E209                     485                 LSR.B    #1,D1          *shift the direction bit to carry-- D1 now also holds the data register of the operation
000014B6  1A01                     486                 MOVE.B   D1,D5          *move source/destination (undertermined) Dn bits to D5
000014B8  6500 0006                487                 BCS      or_Dn_right    * <ea> OR Dn
000014BC  6000 000C                488                 BRA      or_Dn_left     * Dn OR <ea>
000014C0                           489                 
000014C0  4201                     490  or_Dn_right    CLR.B    D1
000014C2  E599                     491                 ROL.L    #2,D1
000014C4  1801                     492                 MOVE.B   D1,D4          *D4 holds the size of the operation
000014C6  6000 000C                493                 BRA      or_size
000014CA                           494  
000014CA  1E3C 0001                495  or_Dn_left     MOVE.B   #1,D7          *flag operation as Dn_left
000014CE  4201                     496                 CLR.B    D1
000014D0  E599                     497                 ROL.L    #2,D1
000014D2  1801                     498                 MOVE.B   D1,D4          *D4 holds the size of the operation
000014D4  B83C 0000                499  or_size        CMP.B    #0,D4
000014D8  6700 0012                500                 BEQ      or_byte
000014DC  B83C 0001                501                 CMP.B    #1,D4
000014E0  6700 001C                502                 BEQ      or_word
000014E4  B83C 0002                503                 CMP.B    #2,D4
000014E8  6700 0026                504                 BEQ      or_long
000014EC                           505                 
000014EC  23F9 0000413C 00004148   506  or_byte        MOVE.L   SIZEB,SIZECODE
000014F6  14BC 0000                507                 MOVE.B   #0,(A2)        *flag data as byte sized
000014FA  6000 0022                508                 BRA      or_ea
000014FE                           509  
000014FE  23F9 00004140 00004148   510  or_word        MOVE.L   SIZEW,SIZECODE
00001508  14BC 0001                511                 MOVE.B   #1,(A2)        *flag data as word sized
0000150C  6000 0010                512                 BRA      or_ea
00001510                           513  
00001510  23F9 00004144 00004148   514  or_long        MOVE.L   SIZEL,SIZECODE
0000151A  14BC 0002                515                 MOVE.B   #2,(A2)        *flag data as long sized
0000151E                           516  
0000151E  4EB9 000020B4            517  or_ea          JSR      disp_instr
00001524  4201                     518                 CLR.B    D1
00001526  E799                     519                 ROL.L    #3,D1          *D1 holds the EA bits         
00001528  2601                     520                 MOVE.L   D1,D3          *move EA source bits to D3
0000152A  BE3C 0001                521                 CMP.B    #1,D7
0000152E  6700 001E                522                 BEQ      or_left_print
00001532  2C03                     523                 MOVE.L   D3,D6          *temp store D3 bits in D6 for next function call
00001534  2605                     524                 MOVE.L   D5,D3
00001536  4EB9 00001E24            525                 JSR      DR_CMP         *print Dn bits
0000153C  4EB9 0000216E            526                 JSR      print_comma
00001542  2606                     527                 MOVE.L   D6,D3
00001544  4EB9 00001DAE            528                 JSR      EA_SRC_beg
0000154A  6000 FB98                529                 BRA      prep
0000154E                           530                 
0000154E  4EB9 00001DAE            531  or_left_print  JSR      EA_SRC_beg     *print EA bits
00001554  2605                     532                 MOVE.L   D5,D3          *get D5 bits in D3 for function call
00001556  4EB9 0000216E            533                 JSR      print_comma
0000155C  4EB9 00001E24            534                 JSR      DR_CMP         *print Dn bits
00001562  6000 FB80                535                 BRA      prep
00001566                           536  
00001566                           537  * /or_handler
00001566                           538  *-----------------------------------------------------------------------------
00001566                           539  
00001566                           540  
00001566                           541  *----------------------------------------------------------------------------
00001566                           542  *add_handler
00001566                           543  *handles 'ADD'
00001566                           544  * heavily uses the or_handler function as the instruction formats are equivalent after the first nibble
00001566                           545  
00001566  23F9 0000406C 00004160   546  add_handler    MOVE.L  ADD,INST_NAME
00001570  E209                     547                 LSR.B   #1,D1
00001572  1A01                     548                 MOVE.B  D1,D5        *isolate direction bits
00001574  6500 FF4A                549                 BCS     or_Dn_right  *<ea> + Dn -> <ea>
00001578  6000 FF50                550                 BRA     or_Dn_left   *Dn + <ea> -> Dn
0000157C                           551         
0000157C                           552  * /add_handler
0000157C                           553  *----------------------------------------------------------------------------
0000157C                           554  
0000157C                           555  
0000157C                           556  *-----------------------------------------------------------------------------
0000157C                           557  *sub_handler
0000157C                           558  * handles 'SUB'
0000157C                           559  
0000157C  23F9 000040F8 00004160   560  sub_handler         MOVE.L  SUB,INST_NAME
00001586  4201                     561                      CLR.B   D1
00001588  E999                     562                      ROL.L   #4,D1
0000158A  2401                     563                      MOVE.L  D1,D2         *make a copy
0000158C  4242                     564                      CLR     D2
0000158E  E59A                     565                      ROL.L   #2,D2
00001590  6700 FEF6                566                      BEQ     suba_handler  *its suba (hardcoded size bits)
00001594  E209                     567                      LSR.B   #1,D1         *determine direction of sub
00001596  1A01                     568                      MOVE.B  D1,D5         *move Dn and direction bits to D5
00001598  6500 FF26                569                      BCS     or_Dn_right   * <ea> SUB Dn -> <ea>
0000159C  6000 FF2C                570                      BRA     or_Dn_left    * Dn SUB <ea> -> Dn            
000015A0                           571  
000015A0                           572  * /sub_handler
000015A0                           573  *-----------------------------------------------------------------------------
000015A0                           574  
000015A0                           575  *-----------------------------------------------------------------------------
000015A0                           576   * eor_handler  
000015A0                           577   * handles 'EOR'
000015A0                           578  
000015A0  23F9 00004084 00004160   579  eor_handler         MOVE.L   EOR,INST_NAME
000015AA  E209                     580                      LSR.B    #1,D1           *get rid of direction bit--we know its 1
000015AC  1A01                     581                      MOVE.B   D1,D5           *copy data register number in d1 to d5
000015AE  6000 FF10                582                      BRA      or_Dn_right
000015B2                           583                      
000015B2                           584  * /eor_handler
000015B2                           585  *-----------------------------------------------------------------------------
000015B2                           586  
000015B2                           587  
000015B2                           588  *-----------------------------------------------------------------------------
000015B2                           589  * cmp_handler
000015B2                           590  * handles 'CMP'
000015B2                           591  
000015B2  23F9 0000408C 00004160   592  cmp_handler         MOVE.L   CMP,INST_NAME
000015BC  E209                     593                      LSR.B    #1,D1        *get rid of hardcoded 0
000015BE  1A01                     594                      MOVE.B   D1,D5        *save Dn bits to D5
000015C0  6000 FF08                595                      BRA      or_Dn_left
000015C4                           596  
000015C4                           597  * /cmp_handler
000015C4                           598  *-----------------------------------------------------------------------------
000015C4                           599  
000015C4                           600  
000015C4                           601  *-----------------------------------------------------------------------------
000015C4                           602  *divsw_handler
000015C4                           603  *handles 'DIVS'(.W)
000015C4                           604  * .W is implicit
000015C4                           605  
000015C4  23F9 00004108 00004160   606  divsw_handler   MOVE.L DIV,INST_NAME
000015CE  33F9 00004130 00004168   607                  MOVE.W S,INST_NAME_EXT
000015D8  4EB9 000020B4            608  divsw_beg       JSR    disp_instr
000015DE  E209                     609                  LSR.B  #1,D1        *get rid of hardcoded bit
000015E0  4282                     610                  CLR.L  D2           *clear space in D2
000015E2  1401                     611                  MOVE.B D1,D2        *save Dn destination register to D2
000015E4  2802                     612                  MOVE.L D2,D4        *get them into D4 for use after next function call
000015E6  4201                     613                  CLR.B  D1
000015E8  E589                     614                  LSL.L  #2,D1        *Shift out size bits--we already know its a word
000015EA  E799                     615                  ROL.L  #3,D1        *D1 now holds the EA bits
000015EC  2601                     616                  MOVE.L D1,D3        *and move them to D3
000015EE  14BC 0001                617                  MOVE.B #1,(A2)      *indicate word for next call
000015F2  4EB9 00001DAE            618                  JSR    EA_SRC_beg   *print source EA info
000015F8  4EB9 0000216E            619                  JSR    print_comma
000015FE  2604                     620                  MOVE.L D4,D3        *move the destination register bits to D3 for next call
00001600  4EB9 00001E24            621                  JSR    DR_CMP       *print the data register
00001606  6000 FADC                622                  BRA    prep
0000160A                           623  
0000160A                           624  * /divsw_handler
0000160A                           625  *-----------------------------------------------------------------------------
0000160A                           626  
0000160A                           627                    
0000160A                           628  *-----------------------------------------------------------------------------
0000160A                           629  *muls_handler
0000160A                           630  * handles 'MULS'
0000160A                           631  
0000160A                           632  *uses divsw function as layout is similar after first 4 bits
0000160A                           633  
0000160A  4201                     634  muls_handler      CLR.B   D1
0000160C  E999                     635                    ROL.L   #4,D1             *get the next hex digit after 0xC
0000160E  2401                     636                    MOVE.L  D1,D2
00001610  E20A                     637                    LSR.B   #1,D2
00001612  6400 FB32                638                    BCC     inv_handler       *unsupported opcode
00001616  4202                     639                    CLR.B   D2
00001618  E59A                     640                    ROL.L   #2,D2             *get the size bits of the operation
0000161A  B43C 0003                641                    CMP.B   #3,D2
0000161E  6600 FB26                642                    BNE     inv_handler       *unsupported if size code != 11 at this point
00001622  23F9 00004100 00004160   643                    MOVE.L  MUL,INST_NAME     *now were sure its muls
0000162C  23F9 00004130 00004168   644                    MOVE.L  S,INST_NAME_EXT
00001636  4EB8 15D8                645                    JSR     divsw_beg
0000163A                           646  
0000163A                           647  */muls_handler
0000163A                           648  *-----------------------------------------------------------------------------
0000163A                           649  
0000163A                           650  
0000163A                           651  *-----------------------------------------------------------------------------
0000163A                           652  *subq_handler
0000163A                           653  * handles 'SUBQ' (data [1,8])
0000163A                           654  
0000163A  23F9 000040F8 00004160   655  subq_handler       MOVE.L  SUB,INST_NAME
00001644  23F9 0000412E 00004168   656  subq_det           MOVE.L  Q,INST_NAME_EXT
0000164E  4201                     657                     CLR.B   D1
00001650  E599                     658                     ROL.L   #2,D1            *isolate size bits
00001652  B23C 0000                659                     CMP.B   #0,D1
00001656  6700 0016                660                     BEQ     subq_byte
0000165A  B23C 0001                661                     CMP.B   #1,D1
0000165E  6700 0020                662                     BEQ     subq_word
00001662  B23C 0002                663                     CMP.B   #2,D1
00001666  6700 002A                664                     BEQ     subq_long
0000166A  6000 FADA                665                     BRA     inv_handler     *size > 2 means it's an unsupported opcode
0000166E  23F9 0000413C 00004148   666  subq_byte          MOVE.L  SIZEB,SIZECODE
00001678  14BC 0000                667                     MOVE.B  #0,(A2)
0000167C  6000 0028                668                     BRA     subq_ea
00001680  23F9 00004140 00004148   669  subq_word          MOVE.L  SIZEW,SIZECODE
0000168A  14BC 0001                670                     MOVE.B  #1,(A2)            *flag it as a word
0000168E  6000 0016                671                     BRA     subq_ea
00001692  23F9 00004144 00004148   672  subq_long          MOVE.L  SIZEL,SIZECODE
0000169C  24BC 00000002            673                     MOVE.L  #2,(A2)            *flag it as a long
000016A2  6000 0002                674                     BRA     subq_ea 
000016A6                           675  
000016A6  4201                     676  subq_ea            CLR.B   D1               *prep byte space
000016A8  E799                     677                     ROL.L   #3,D1            *get EA bits
000016AA  2601                     678                     MOVE.L  D1,D3            *put them in D3
000016AC  2202                     679                     MOVE.L  D2,D1            *move immediate data bits back to D1 for display
000016AE  4EB9 000020B4            680                     JSR     disp_instr
000016B4  B23C 0000                681                     CMP.B   #0,D1
000016B8  6700 0024                682                     BEQ     case_quick8     *8 (base 0) is represented as 000 in data field.
000016BC  43F9 0000416E            683  q_prints           LEA     imm_sign, A1    *load and print '#' character
000016C2  103C 000E                684                     MOVE.B  #14,D0
000016C6  4E4F                     685                     TRAP    #15
000016C8  103C 0003                686                     MOVE.B  #3,D0
000016CC  4E4F                     687                     TRAP    #15              *display immediate [1-8] data 
000016CE  4EB9 0000216E            688                     JSR     print_comma               
000016D4  4EB9 00001DAE            689                     JSR     EA_SRC_beg
000016DA  6000 FA08                690                     BRA     prep
000016DE                           691             
000016DE  123C 0008                692  case_quick8        MOVE.B  #8,D1           *move the number 8 to D1, replacing 0  
000016E2  60D8                     693                     BRA     q_prints     
000016E4                           694  
000016E4                           695  * /subq_handler
000016E4                           696  *-----------------------------------------------------------------------------
000016E4                           697  
000016E4                           698  
000016E4                           699  *-----------------------------------------------------------------------------
000016E4                           700  *addq_handler
000016E4                           701  *handles 'ADDQ', or adds with data [1,8]
000016E4                           702  
000016E4                           703  *uses subq_handler due to similar bit layout
000016E4                           704  
000016E4  23F9 0000406C 00004160   705  addq_handler      MOVE.L  ADD,INST_NAME
000016EE  6000 FF54                706                    BRA     subq_det          *SUBQ and ADDQ equivalent instruction layout hereafter   
000016F2                           707  
000016F2                           708  * /addq_handler
000016F2                           709  *-----------------------------------------------------------------------------
000016F2                           710  
000016F2                           711  
000016F2                           712  *-----------------------------------------------------------------------------
000016F2                           713  * cmpi_handler
000016F2                           714  * handles cmpi
000016F2                           715  
000016F2                           716  *D1 holds instruction info, then EA info (mode & reg)
000016F2                           717  *D2: holds the size of the operation (b,w,l)
000016F2                           718  
000016F2                           719  *size bits also indicate the size of immediate data after the instruction
000016F2                           720  
000016F2  23F9 0000408C 00004160   721  cmpi_handler       MOVE.L   CMP,INST_NAME
000016FC  13F9 00004126 00004168   722                     MOVE.B   I,INST_NAME_EXT
00001706  4201                     723                     CLR.B    D1
00001708  E599                     724                     ROL.L    #2,D1               *isolate the size bits
0000170A  1801                     725                     MOVE.B   D1,D4               *move size bits to D4
0000170C  B83C 0000                726                     CMP.B    #0,D4
00001710  6700 0012                727                     BEQ      cmpi_byte
00001714  B83C 0001                728                     CMP.B    #1,D4
00001718  6700 001C                729                     BEQ      cmpi_word
0000171C  B83C 0002                730                     CMP.B    #2,D4
00001720  6700 0026                731                     BEQ      cmpi_long
00001724  23F9 0000413C 00004148   732  cmpi_byte          MOVE.L   SIZEB,SIZECODE      *indicate the operation is a byte
0000172E  14BC 0000                733                     MOVE.B   #0,(A2)
00001732  6000 0022                734                     BRA      cmpi_ret
00001736  23F9 00004140 00004148   735  cmpi_word          MOVE.L   SIZEW,SIZECODE      *indicate the operation is a word
00001740  14BC 0001                736                     MOVE.B   #1,(A2)      
00001744  6000 0010                737                     BRA      cmpi_ret
00001748  23F9 00004144 00004148   738  cmpi_long          MOVE.L   SIZEL,SIZECODE      *indicate the operation is a long
00001752  14BC 0002                739                     MOVE.B   #2,(A2)  
00001756  DAFC 0002                740  cmpi_ret           ADDA     #word_len,A5        *set pointer to next word- all data in cmpi is either next word or next 2 words(long)
0000175A  4EB9 000020B4            741                     JSR      disp_instr
00001760  4201                     742                     CLR.B    D1
00001762  4EB9 00001F58            743                     JSR      DATA_MODE           *determine and print the immediate data based on size
00001768  0C12 0002                744                     CMP.B    #2,(A2)
0000176C  E799                     745                     ROL.L    #3,D1               *isolate EA info in D1
0000176E  2601                     746                     MOVE.L   D1,D3
00001770  4EB9 0000216E            747                     JSR      print_comma
00001776  4EB9 00001DB2            748                     JSR      EA_SRC              *obtain and print the destination information
0000177C  6000 F966                749                     BRA      prep
00001780                           750                     
00001780                           751  * /cmpi_handler
00001780                           752  *-----------------------------------------------------------------------------
00001780                           753  
00001780                           754  
00001780                           755  *-----------------------------------------------------------------------------
00001780                           756  *bclr_static and bclr_dynamic
00001780                           757  *(bclr_handler)
00001780                           758  *handles 'BCLR' with a data register or its static counterpart (no register)
00001780                           759  
00001780  E599                     760  bclr_static       ROL.L     #2,D1          *get 2 more bits-- are we sure its BCLR?
00001782  B23C 0022                761                    CMP.B     #34,D1         *static BCLR bits 11 to 6
00001786  6600 F9BE                762                    BNE       inv_handler    *unsupported opcode
0000178A  23F9 00004074 00004160   763                    MOVE.L    BCL,INST_NAME  *we now know its bclr
00001794  23F9 00004128 00004168   764                    MOVE.L    R,INST_NAME_EXT
0000179E  4EB9 000020B4            765                    JSR       disp_instr
000017A4  4201                     766                    CLR.B     D1             
000017A6  E799                     767                    ROL.L     #3,D1          *isolate the EA mode and register
000017A8  2601                     768                    MOVE.L    D1,D3
000017AA  DAFC 0002                769                    ADDA      #word_len,A5   *get the trailing immediate data
000017AE  4281                     770                    CLR.L     D1
000017B0                           771                    *MOVE.W    (A5),D1        *move it to D1
000017B0  4EB9 00001F58            772                    JSR       DATA_MODE      *and print it
000017B6  9AFC 0002                773                    SUBA      #word_len,A5   *return to instruction
000017BA  4EB9 0000216E            774                    JSR       print_comma
000017C0  4EB9 00001DAE            775                    JSR       EA_SRC_beg     *print EA dest information
000017C6  6000 F91C                776                    BRA       prep    
000017CA                           777  
000017CA  E209                     778  bclr_dynamic      LSR.B     #1,D1          *discard hardcoded bit 
000017CC  23F9 00004074 00004160   779                    MOVE.L    BCL,INST_NAME
000017D6  23F9 00004128 00004168   780                    MOVE.L    R,INST_NAME_EXT
000017E0  4EB9 000020B4            781                    JSR       disp_instr
000017E6  1601                     782                    MOVE.B    D1,D3          *store Dn bits in D3
000017E8  4EB9 00001E24            783                    JSR       DR_CMP         *print appropriate data register
000017EE  4EB9 0000216E            784                    JSR       print_comma
000017F4  4201                     785                    CLR.B     D1
000017F6  E589                     786                    LSL.L     #2,D1          *clear hardcoded bits
000017F8  E799                     787                    ROL.L     #3,D1          *get ea bits
000017FA  2601                     788                    MOVE.L    D1,D3          *put them in D3
000017FC  4EB9 00001DAE            789                    JSR       EA_SRC_beg     *print EA info
00001802  6000 F8E0                790                    BRA       prep
00001806                           791                   
00001806                           792  
00001806                           793  * /bclr_handler
00001806                           794  *-----------------------------------------------------------------------------
00001806                           795  
00001806                           796  
00001806                           797  *-----------------------------------------------------------------------------
00001806                           798  *ori_handler
00001806                           799  *handles 'ORI'
00001806                           800      
00001806                           801  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
00001806                           802  
00001806  23F9 0000407C 00004160   803  ori_handler       MOVE.L   ORI,INST_NAME
00001810  4201                     804                    CLR.B    D1
00001812  E599                     805                    ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
00001814  1801                     806                    MOVE.B   D1,D4           *move size bits to D2
00001816  4202                     807                    CLR.B    D2
00001818  E79A                     808                    ROL.L    #3,D2           *get EA mode bits
0000181A  B43C 0007                809                    CMP.B    #7,d2           *are EA mode bits 111?
0000181E  6700 F926                810                    BEQ      inv_handler     *invalid ORI type (SR,CCR)
00001822  B83C 0000                811                    CMP.B    #0,D4
00001826  6700 FEFC                812                    BEQ      cmpi_byte
0000182A  B83C 0001                813                    CMP.B    #1,D4
0000182E  6700 FF06                814                    BEQ      cmpi_word
00001832  B83C 0002                815                    CMP.B    #2,D4
00001836  6700 FF10                816                    BEQ      cmpi_long
0000183A                           817  
0000183A                           818  * /ori_handler
0000183A                           819  *-----------------------------------------------------------------------------
0000183A                           820  
0000183A                           821  
0000183A                           822  *-----------------------------------------------------------------------------
0000183A                           823  * addi_handler
0000183A                           824  * handles 'ADDI'
0000183A                           825  
0000183A                           826  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
0000183A                           827  
0000183A  23F9 0000406C 00004160   828  addi_handler      MOVE.L   ADD,INST_NAME
00001844  23F9 00004126 00004168   829                    MOVE.L   I,INST_NAME_EXT
0000184E  4201                     830                    CLR.B    D1
00001850  E599                     831                    ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
00001852  1801                     832                    MOVE.B   D1,D4           *move size bits to D2
00001854  B83C 0000                833                    CMP.B    #0,D4
00001858  6700 FECA                834                    BEQ      cmpi_byte
0000185C  B83C 0001                835                    CMP.B    #1,D4
00001860  6700 FED4                836                    BEQ      cmpi_word
00001864  B83C 0002                837                    CMP.B    #2,D4
00001868  6700 FEDE                838                    BEQ      cmpi_long
0000186C                           839  
0000186C                           840  * /addi_handler
0000186C                           841  *-----------------------------------------------------------------------------
0000186C                           842  
0000186C                           843  *-----------------------------------------------------------------------------
0000186C                           844  * eori_handler
0000186C                           845  * handles 'EORI'
0000186C                           846  
0000186C                           847  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
0000186C                           848  
0000186C  23F9 00004084 00004160   849  eori_handler      MOVE.L   EOR,INST_NAME
00001876  23F9 00004126 00004168   850                    MOVE.L   I,INST_NAME_EXT
00001880  4201                     851                    CLR.B    D1
00001882  E599                     852                    ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
00001884  1801                     853                    MOVE.B   D1,D4           *move size bits to D2
00001886  B83C 0000                854                    CMP.B    #0,D4
0000188A  6700 FE98                855                    BEQ      cmpi_byte
0000188E  B83C 0001                856                    CMP.B    #1,D4
00001892  6700 FEA2                857                    BEQ      cmpi_word
00001896  B83C 0002                858                    CMP.B    #2,D4
0000189A  6700 FEAC                859                    BEQ      cmpi_long
0000189E                           860  
0000189E                           861  
0000189E                           862  
0000189E                           863  * /eori_handler
0000189E                           864  *-----------------------------------------------------------------------------
0000189E                           865  
0000189E                           866  *-----------------------------------------------------------------------------
0000189E                           867  * subi_handler
0000189E                           868  * handles 'SUBI'
0000189E                           869  
0000189E                           870  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
0000189E                           871  
0000189E  23F9 000040F8 00004160   872  subi_handler     MOVE.L   SUB,INST_NAME
000018A8  23F9 00004126 00004168   873                   MOVE.L   I,INST_NAME_EXT
000018B2  4201                     874                   CLR.B    D1
000018B4  E599                     875                   ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
000018B6  1801                     876                   MOVE.B   D1,D4           *move size bits to D2
000018B8  B83C 0000                877                   CMP.B    #0,D4
000018BC  6700 FE66                878                   BEQ      cmpi_byte
000018C0  B83C 0001                879                   CMP.B    #1,D4
000018C4  6700 FE70                880                   BEQ      cmpi_word
000018C8  B83C 0002                881                   CMP.B    #2,D4
000018CC  6700 FE7A                882                   BEQ      cmpi_long
000018D0                           883  
000018D0                           884  * /subi_handler
000018D0                           885  *-----------------------------------------------------------------------------
000018D0                           886  
000018D0                           887  
000018D0                           888  *-----------------------------------------------------------------------------
000018D0                           889  *neg_handler
000018D0                           890  *handles neg
000018D0                           891  
000018D0                           892  *D1: holds opcode
000018D0                           893  *D4: holds size of operation (b,w,l)
000018D0                           894  
000018D0  23F9 0000404C 00004160   895  neg_handler      MOVE.L   NEG,INST_NAME
000018DA  4201                     896                   CLR.B    D1   
000018DC  E599                     897                   ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
000018DE  1801                     898                   MOVE.B   D1,D4           *move size bits to D4
000018E0  B83C 0000                899                   CMP.B    #0,D4           *determine size based on bits (00=byte) (01=word) (10=long)
000018E4  6700 0012                900                   BEQ      neg_byte
000018E8  B83C 0001                901                   CMP.B    #1,D4
000018EC  6700 0018                902                   BEQ      neg_word
000018F0  B83C 0002                903                   CMP.B    #2,D4
000018F4  6700 001E                904                   BEQ      neg_long
000018F8                           905    
000018F8  23F9 0000413C 00004148   906  neg_byte         MOVE.L   SIZEB,SIZECODE
00001902  6000 001A                907                   BRA      neg_ret
00001906  23F9 00004140 00004148   908  neg_word         MOVE.L   SIZEW,SIZECODE
00001910  6000 000C                909                   BRA      neg_ret
00001914  23F9 00004144 00004148   910  neg_long         MOVE.L   SIZEL,SIZECODE   
0000191E  4EB9 000020B4            911  neg_ret          JSR      disp_instr
00001924  E799                     912                   ROL.L    #3,D1           *isolate EA bits
00001926  2601                     913                   MOVE.L   D1,D3           *move those EA bits to D3
00001928  4EB9 00001DAE            914                   JSR      EA_SRC_beg      *display EA info we're negating
0000192E                           915  
0000192E                           916  
0000192E                           917  * /neg_handler
0000192E                           918  *-----------------------------------------------------------------------------
0000192E                           919  
0000192E                           920  
0000192E                           921  *-----------------------------------------------------------------------------
0000192E                           922  *bcc_handler
0000192E                           923  *handles 'BCS','BGE','BLT','BVC','BRA'
0000192E                           924  
0000192E                           925  *D1: holds the condition, displacement nibbles of instruction
0000192E                           926  *D3: holds the condition of instruction
0000192E                           927  *D4: holds the current address of this instruction
0000192E                           928  *A4: holds the pointer to bcc_tbl
0000192E                           929  *A5: holds the current address of this instruction
0000192E                           930  
0000192E  4201                     931  bcc_handler   CLR.B   D1
00001930  E999                     932                ROL.L   #4,D1
00001932  1601                     933                MOVE.B  D1,D3          *copy condition value to D3
00001934  49F9 0000414C            934                LEA     bcc_tbl,A4     *A4 now points to the bcc_tbl
0000193A  0C14 00FF                935  bcc_cond      CMP.B   #-1,(A4)       *have we reached the end of the table
0000193E  6700 0146                936                BEQ     inv_bcc_handler  * yes-invalid branch
00001942  B61C                     937                CMP.B   (A4)+,D3       *compare the next table value
00001944  6700 0004                938                BEQ     bcc_determiner * there's a match
00001948  60F0                     939                BRA     bcc_cond       *continue looping through the table
0000194A                           940  
0000194A  0C24 0005                941  bcc_determiner  CMP.B  #5,-(a4)      *determine path based on condition code from table (in data section)
0000194E  6700 0056                942                  BEQ    bcs_handler
00001952  0C14 000C                943                  CMP.B  #12,(a4)
00001956  6700 005C                944                  BEQ    bge_handler
0000195A  0C14 000D                945                  CMP.B  #13,(a4)
0000195E  6700 0062                946                  BEQ    blt_handler
00001962  0C14 0008                947                  CMP.B  #8,(a4)
00001966  6700 0068                948                  BEQ    bvc_handler
0000196A  0C14 0000                949                  CMP.B  #0,(a4)
0000196E  6700 006E                950                  BEQ    bra_handler
00001972  0C14 0004                951                  CMP.B  #4,(a4)
00001976  6700 0074                952                  BEQ    bccd_handler
0000197A  0C14 0006                953                  CMP.B  #6,(a4)
0000197E  6700 007A                954                  BEQ    bne_handler
00001982  0C14 0007                955                  CMP.B  #7,(a4)
00001986  6700 0080                956                  BEQ    beq_handler
0000198A  0C14 0009                957                  CMP.B  #9,(a4)
0000198E  6700 0086                958                  BEQ    bvs_handler
00001992  0C14 000E                959                  CMP.B  #$E,(a4)
00001996  6700 008C                960                  BEQ    bgt_handler
0000199A  0C14 000F                961                  CMP.B  #$F,(a4)
0000199E  6700 0092                962                  BEQ    ble_handler
000019A2  6000 00E2                963                  BRA    inv_bcc_handler      *before displaying unsupported opcode message,advance address pointer
000019A6                           964                                              *to account for known displacement after this unsupported branch
000019A6  23F9 000040A0 00004160   965  bcs_handler   MOVE.L  BCS,INST_NAME
000019B0  6000 008E                966                BRA     bcc_dispm
000019B4  23F9 000040A8 00004160   967  bge_handler   MOVE.L  BGE,INST_NAME
000019BE  6000 0080                968                BRA     bcc_dispm
000019C2  23F9 000040B0 00004160   969  blt_handler   MOVE.L  BLT,INST_NAME
000019CC  6000 0072                970                BRA     bcc_dispm
000019D0  23F9 000040B8 00004160   971  bvc_handler   MOVE.L  BVC,INST_NAME
000019DA  6000 0064                972                BRA     bcc_dispm
000019DE  23F9 000040C0 00004160   973  bra_handler   MOVE.L  BRA,INST_NAME
000019E8  6000 0056                974                BRA     bcc_dispm
000019EC  23F9 000040C8 00004160   975  bccd_handler  MOVE.L  BCC,INST_NAME
000019F6  6000 0048                976                BRA     bcc_dispm
000019FA  23F9 000040D0 00004160   977  bne_handler   MOVE.L  BNE,INST_NAME
00001A04  6000 003A                978                BRA     bcc_dispm
00001A08  23F9 000040D8 00004160   979  beq_handler   MOVE.L  BEQ,INST_NAME
00001A12  6000 002C                980                BRA     bcc_dispm
00001A16  23F9 000040E0 00004160   981  bvs_handler   MOVE.L  BVS,INST_NAME
00001A20  6000 001E                982                BRA     bcc_dispm
00001A24  23F9 000040E8 00004160   983  bgt_handler   MOVE.L  BGT,INST_NAME
00001A2E  6000 0010                984                BRA     bcc_dispm
00001A32  23F9 000040F0 00004160   985  ble_handler   MOVE.L  BLE,INST_NAME
00001A3C  6000 0002                986                BRA     bcc_dispm
00001A40                           987  
00001A40  280D                     988  bcc_dispm     MOVE.L  A5,D4            *copy current address to D4
00001A42  DAFC 0002                989                ADDA    #word_len,A5     *all Bcc instructions took up a word         
00001A46  4201                     990                CLR.B   D1               *now find the displacement- (A5 +- last 2 nibbles)
00001A48  E199                     991                ROL.L   #8,D1            *get the last 2 displacement nibbles
00001A4A  B23C 0000                992                CMP.B   #0,D1            *are the 8 displacement bits all 0?
00001A4E  6700 0016                993                BEQ     bcc_word_handler * yes- get the following displacement word
00001A52  B23C 000F                994                CMP.B   #$F,D1           *are all displacement bits 1?
00001A56  6700 0012                995                BEQ     bcc_long_handler * yes-get the displacement long
00001A5A  4681                     996  bcc_calc      NOT.L   D1               *ones complement
00001A5C  5281                     997                ADDI.L  #1,D1            *twos complement 
00001A5E  5404                     998                ADDI.B  #2,D4            *account for PC displacement 2 bytes ahead of current address
00001A60  9841                     999                SUB.W   D1,D4            *calculate displacement address  ****.L OR .W
00001A62  6000 000A               1000                BRA     bcc_complete
00001A66                          1001                
00001A66  321D                    1002  bcc_word_handler  MOVE.W (A5)+,D1    *put 16 displacement bits in D1
00001A68  60F0                    1003                    BRA     bcc_calc
00001A6A                          1004                    
00001A6A  221D                    1005  bcc_long_handler  MOVE.L (A5)+,D1    *put 32 displacement bits in D1
00001A6C  60EC                    1006                    BRA     bcc_calc
00001A6E                          1007  
00001A6E  4EB9 000020B4           1008  bcc_complete  JSR     disp_instr
00001A74  2044                    1009                MOVE.L  D4,A0      *move displacement address to A0 for next function
00001A76  4EB9 00002184           1010                JSR     print_addr_sgn
00001A7C  4EB9 00002108           1011                JSR     hex_2_ascii
00001A82  6000 F660               1012                BRA     prep
00001A86                          1013                     
00001A86  4201                    1014  inv_bcc_handler    CLR.B D1         
00001A88  E199                    1015                     ROL.L #8,D1          *get the 8 bit displacement of this unsupported branch
00001A8A  B23C 0000               1016                     CMP.B #0,D1          *did the branch need a word displacement
00001A8E  6700 000E               1017                     BEQ   inv_bcc_word   * branch included a trailing word displacement
00001A92  B03C 00FF               1018                     CMP.B #$FF,D0        *did the branch need a long displacement
00001A96  6700 000E               1019                     BEQ   inv_bcc_long   * branch included a trailing long displacement
00001A9A  6000 F6AA               1020                     BRA   inv_handler    *branch instruction was self-contained
00001A9E  DAFC 0002               1021  inv_bcc_word       ADDA #word_len,A5    *skip over the word displacement
00001AA2  6000 F6A2               1022                     BRA  inv_handler
00001AA6  DAFC 0004               1023  inv_bcc_long       ADDA #long_len,A5    *skip over the long displacement
00001AAA  6000 F69A               1024                     BRA  inv_handler
00001AAE                          1025  
00001AAE                          1026   */bcc_handler            
00001AAE                          1027  *-----------------------------------------------------------------------------
00001AAE                          1028  
00001AAE                          1029  *-----------------------------------------------------------------------------
00001AAE                          1030   * shift_roll_handler   
00001AAE                          1031   * handles 'LSR','LSL','ASR','ASL','ROL','ROR'
00001AAE                          1032  
00001AAE                          1033   
00001AAE                          1034   *A5: holds the current address of this instruction
00001AAE                          1035   *D2: used to check if its a shift or roll, immediate or register
00001AAE                          1036   *D3: holds the size (b,w,l) of the operation
00001AAE                          1037   *D4: holds the immediate data (1-7) or the register number of the source
00001AAE                          1038   *D5: flags source as immediate or register 1=reg, 0=imm (only used in sr_reg)
00001AAE                          1039   
00001AAE  4201                    1040  _shift_roll_handler  CLR.B    D1
00001AB0  E999                    1041                       ROL.L    #4,D1            *get next 4 bits in this shift/roll
00001AB2  2401                    1042                       MOVE.L   D1,D2
00001AB4  E20A                    1043                       LSR.B    #1,D2            *set the carry to be the direction of this shift/rotate
00001AB6  6500 0010               1044                       BCS      sr_type_resolve  * carry is set- its leftwards
00001ABA  23F9 00004128 00004168  1045                       MOVE.L   R,INST_NAME_EXT  *we know its a rightwards operation
00001AC4  6000 000C               1046                       BRA      sr_type_resolve_beg  * carry is set- rightwards
00001AC8                          1047  
00001AC8                          1048  *now determine if its a memory or register shift                  
00001AC8  23F9 0000412C 00004168  1049  sr_type_resolve      MOVE.L   L,INST_NAME_EXT   *we know its a leftwards operation
00001AD2  1802                    1050  sr_type_resolve_beg  MOVE.B   D2,D4          *D4 now holds the count/register bits
00001AD4  4202                    1051                       CLR.B    D2
00001AD6  E59A                    1052                       ROL.L    #2,D2          *get next 2 (size) bits
00001AD8  1602                    1053                       MOVE.B   D2,D3          *move size bits to D3 
00001ADA  4202                    1054                       CLR.B    D2             *clear size bits from D2
00001ADC  B63C 0003               1055                       CMP.B    #3,D3          *are size bits 11?
00001AE0  6700 0006               1056                       BEQ      sr_mem         * yes-memory shift
00001AE4  6000 005C               1057                       BRA      sr_reg         * no-register shift
00001AE8                          1058                       
00001AE8                          1059  *its a memory shift/roll,so exact instruction lies in D4. First get type, then get direction later        
00001AE8  B83C 0000               1060  sr_mem               CMP.B   #0,D4          *D4 holds instruction type. which one is it?
00001AEC  6700 0016               1061                       BEQ     as_handler
00001AF0  B83C 0001               1062                       CMP.B   #1,D4
00001AF4  6700 001C               1063                       BEQ     ls_handler
00001AF8  B83C 0003               1064                       CMP.B   #3,D4
00001AFC  6700 0022               1065                       BEQ     ro_handler
00001B00  6000 F644               1066                       BRA     inv_handler    *unsupported
00001B04                          1067                       
00001B04  23F9 00004098 00004160  1068  as_handler           MOVE.L  AS,INST_NAME   *its AS(R/L)
00001B0E  6000 001E               1069                       BRA     sr_mem_ret
00001B12  23F9 00004094 00004160  1070  ls_handler           MOVE.L  LS,INST_NAME   *its LS(R/L)
00001B1C  6000 0010               1071                       BRA     sr_mem_ret
00001B20  23F9 0000409C 00004160  1072  ro_handler           MOVE.L  RO,INST_NAME   *its RO(R/L)
00001B2A  6000 0002               1073                       BRA     sr_mem_ret
00001B2E                          1074  
00001B2E  4EB9 000020B4           1075  sr_mem_ret           JSR     disp_instr     *display the instruction (eg 'ASR','ROL')  
00001B34  E79A                    1076                       ROL.L   #3,D2          *partition EA bits            
00001B36  1602                    1077                       MOVE.B  D2,D3          *and send them to D3 for next function call
00001B38  4EB9 00001DAE           1078                       JSR     EA_SRC_beg     *display EA info
00001B3E  6000 F5A4               1079                       BRA     prep
00001B42                          1080  
00001B42                          1081  *its a register shift/roll so D4 holds the register/immediate shift count
00001B42  E38A                    1082  sr_reg               LSL.L   #1,D2          *send i/r bit to carry
00001B44  6500 000A               1083                       BCS     sr_reg_type
00001B48  1A3C 0000               1084                       MOVE.B  #0,D5              *flag operation as immediate shift on register
00001B4C  6000 0006               1085                       BRA     sr_reg_type_beg
00001B50                          1086                       
00001B50  1A3C 0001               1087  sr_reg_type          MOVE.B  #1,D5              *flag operation as register shift on register
00001B54  4202                    1088  sr_reg_type_beg      CLR.B   D2 
00001B56  B63C 0000               1089                       CMP.B   #0,D3              *compare size bits to determine operation size
00001B5A  6700 0012               1090                       BEQ     sr_byte    
00001B5E  B63C 0001               1091                       CMP.B   #1,D3
00001B62  6700 0018               1092                       BEQ     sr_word    
00001B66  B63C 0002               1093                       CMP.B   #2,D3
00001B6A  6700 001E               1094                       BEQ     sr_long
00001B6E                          1095  
00001B6E  23F9 0000413C 00004148  1096  sr_byte              MOVE.L  SIZEB,SIZECODE     *its a byte operation
00001B78  6000 001E               1097                       BRA     sr_reg_ret
00001B7C  23F9 00004140 00004148  1098  sr_word              MOVE.L  SIZEW,SIZECODE     *itsva a word operation
00001B86  6000 0010               1099                       BRA     sr_reg_ret
00001B8A  23F9 00004144 00004148  1100  sr_long              MOVE.L  SIZEL,SIZECODE     *its a long operation
00001B94  6000 0002               1101                       BRA     sr_reg_ret  
00001B98                          1102  
00001B98  4202                    1103  sr_reg_ret           CLR.B   D2
00001B9A  E59A                    1104                       ROL.L   #2,D2              *get the 2 type identifying bits
00001B9C  B43C 0000               1105                       CMP.B   #0,D2
00001BA0  6700 0016               1106                       BEQ     as_reg
00001BA4  B43C 0001               1107                       CMP.B   #1,D2
00001BA8  6700 001C               1108                       BEQ     ls_reg
00001BAC  B43C 0003               1109                       CMP.B   #3,D2
00001BB0  6700 0022               1110                       BEQ     ro_reg
00001BB4  6000 F590               1111                       BRA     inv_handler        *its unsupported
00001BB8                          1112                       
00001BB8  23F9 00004098 00004160  1113  as_reg               MOVE.L  AS,INST_NAME       *its AS(L/R)
00001BC2  6000 0054               1114                       BRA     sr_reg_final
00001BC6                          1115  
00001BC6  23F9 00004094 00004160  1116  ls_reg               MOVE.L  LS,INST_NAME       *its LS(L/R)
00001BD0  6000 0046               1117                       BRA     sr_reg_final
00001BD4                          1118                       
00001BD4  23F9 0000409C 00004160  1119  ro_reg               MOVE.L  RO,INST_NAME       *its RO(L/R)
00001BDE  6000 0038               1120                       BRA     sr_reg_final
00001BE2                          1121  
00001BE2  1604                    1122  sr_reg_print_src     MOVE.B  D4,D3              *move source bits to D3
00001BE4  2204                    1123                       MOVE.L  D4,D1              *and to D1
00001BE6  BA3C 0001               1124                       CMP.B   #1,D5
00001BEA  6700 001E               1125                       BEQ     sr_reg_print_Dn
00001BEE  B23C 0000               1126                       CMP.B   #0,D1              *we know source is immediate-- is it 000(= #8)?
00001BF2  6700 001E               1127                       BEQ     rs_0_shift_handler * yes-load D1 with appropriate dislay data 
00001BF6                          1128  sr_reg_print_imm     *JSR     data_mode_print        *identify and print immediate data
00001BF6  43F9 0000416E           1129                       LEA     imm_sign,A1        *load up the pound sign
00001BFC  103C 000E               1130                       MOVE.B  #14,D0
00001C00  4E4F                    1131                       TRAP    #15
00001C02  103C 0003               1132                       MOVE.B  #3,D0              *prep the shift count for display
00001C06  4E4F                    1133                       TRAP    #15
00001C08  4E75                    1134                       RTS                      
00001C0A  4EB9 00001E24           1135  sr_reg_print_Dn      JSR     DR_CMP                 *identify and print dest register
00001C10  4E75                    1136                       RTS
00001C12                          1137  
00001C12  123C 0008               1138  rs_0_shift_handler   MOVE.B  #8,D1
00001C16  60DE                    1139                       BRA     sr_reg_print_imm
00001C18                          1140                
00001C18  4EB9 000020B4           1141  sr_reg_final         JSR     disp_instr
00001C1E  4202                    1142                       CLR.B   D2
00001C20  E79A                    1143                       ROL.L   #3,D2          *get dest Dn bits in D2
00001C22  4EB8 1BE2               1144                       JSR     sr_reg_print_src   *determine if source is register/immediate based on D5 flag, print
00001C26  4EB9 0000216E           1145                       JSR     print_comma
00001C2C  1602                    1146                       MOVE.B  D2,D3          *move dest bits to D3
00001C2E  4EB9 00001E24           1147                       JSR     DR_CMP         *print destination register
00001C34  DAFC 0002               1148                       ADDA    #word_len,A5   *reg shift/roll took up a word
00001C38  6000 F4AA               1149                       BRA     prep           
00001C3C                          1150                                      
00001C3C                          1151   * /_shift_roll_handler  
00001C3C                          1152  *-----------------------------------------------------------------------------
00001C3C                          1153  
00001C3C                          1154                          
00001C3C                          1155  *-----------------------------------------------------------------------------
00001C3C                          1156  * lea_handler
00001C3C                          1157  * handles lea
00001C3C                          1158  
00001C3C                          1159  *D1: holds opcode instruction
00001C3C                          1160  *D2: holds register bits
00001C3C                          1161  
00001C3C  E209                    1162  lea_handler       LSR.B     #1,D1          *hardcoded bit
00001C3E  2401                    1163                    MOVE.L    D1,D2          *save dest An bits to D2
00001C40  4201                    1164                    CLR.B     D1
00001C42  E589                    1165                    LSL.L     #2,D1          *hardcoded bits
00001C44  E799                    1166                    ROL.L     #3,D1
00001C46  2601                    1167                    MOVE.L    D1,D3          *get EA bits into D3
00001C48  23F9 00004044 00004160  1168                    MOVE.L    LEA,INST_NAME
00001C52  4EB9 000020B4           1169                    JSR       disp_instr       
00001C58  4EB9 00001DAE           1170                    JSR       EA_SRC_beg
00001C5E  4EB9 0000216E           1171                    JSR       print_comma
00001C64  2602                    1172                    MOVE.L    D2,D3
00001C66  4EB9 00001E88           1173                    JSR       PRINT_INNER_An     
00001C6C  6000 F476               1174                    BRA       prep
00001C70                          1175                    
00001C70                          1176                    
00001C70                          1177  * /lea_handler
00001C70                          1178  *-----------------------------------------------------------------------------
00001C70                          1179  
00001C70                          1180  
00001C70                          1181  *-----------------------------------------------------------------------------
00001C70                          1182  *jsr_handler
00001C70                          1183  *handles 'JSR'
00001C70                          1184  
00001C70  23F9 00004054 00004160  1185  jsr_handler       MOVE.L  JSR,INST_NAME
00001C7A  4EB9 000020B4           1186                    JSR     disp_instr
00001C80  4202                    1187                    CLR.B   D2            *clear byte space for next few bits
00001C82  E79A                    1188                    ROL.L   #3,D2         *save EA bits into D2
00001C84  2602                    1189                    MOVE.L  D2,D3
00001C86  4EB9 00001DAE           1190                    JSR     EA_SRC_beg
00001C8C  6000 F456               1191                    BRA     prep
00001C90                          1192  
00001C90                          1193  * /jsr_handler
00001C90                          1194  *-----------------------------------------------------------------------------
00001C90                          1195  
00001C90                          1196  
00001C90                          1197  *-----------------------------------------------------------------------------
00001C90                          1198  *movem_handler
00001C90                          1199  *handles 'MOVEM'
00001C90                          1200  
00001C90                          1201  *An list corresponds to higher byte
00001C90                          1202  *Dn list corresponds to lower byte
00001C90                          1203  
00001C90                          1204  *D2:holds first register in sublist
00001C90                          1205  *D3:holds the number of successive 1's shifted out of a list (register train)
00001C90                          1206  *D4:holds number of iterations for shifting out the bits in the list bytes. also the register number.
00001C90                          1207  *D5:holds the An list byte
00001C90                          1208  *D6:holds the Dn list byte
00001C90                          1209  
00001C90  23F9 0000403C 00004160  1210  movem_handler  MOVE.L  MOV,INST_NAME
00001C9A  23F9 00004134 00004168  1211                 MOVE.L  EM,INST_NAME_EXT
00001CA4  B23C 0008               1212                 CMP.B   #$8,D1
00001CA8  6700 0026               1213                 BEQ     movem_dn
00001CAC  4201                    1214  movem_an       CLR.B   D1
00001CAE  E589                    1215                 LSL.L   #2,D1
00001CB0  6500 0010               1216                 BCS     movem_long
00001CB4                          1217                 
00001CB4  23F9 00004140 00004148  1218  movem_word     MOVE.L  SIZEW,SIZECODE
00001CBE  6000 0018               1219                 BRA     movem_list
00001CC2  23F9 00004144 00004148  1220  movem_long     MOVE.L  SIZEL,SIZECODE
00001CCC  6000 000A               1221                 BRA     movem_list
00001CD0                          1222  
00001CD0  4201                    1223  movem_dn       CLR.B   D1
00001CD2  E589                    1224                 LSL.L   #2,D1
00001CD4  65EC                    1225                 BCS     movem_long
00001CD6  60DC                    1226                 BRA     movem_word
00001CD8                          1227  
00001CD8  4EB9 000020B4           1228  movem_list     JSR     disp_instr
00001CDE  DAFC 0002               1229                 ADDA    #word_len,A5                 *get to register list word
00001CE2  3A15                    1230                 MOVE.W  (A5),D5                      *move entire list to D5
00001CE4  1C05                    1231                 MOVE.B  D5,D6                        *move lower order byte (Dn list) to D6
00001CE6  E04D                    1232                 LSR.W   #word_len*4,D5               *shift the An list to the lower order of D5                  
00001CE8  7801                    1233                 MOVE.L  #1,D4                        *init loop counter/register number
00001CEA  4282                    1234                 CLR.L   D2                           *clear D2, which is holding first register in train
00001CEC  4283                    1235                 CLR.L   D3                           *set train counter to 1
00001CEE  6000 0002               1236                 BRA     movem_dn_list_loop           *first take care or the Dn list
00001CF2                          1237     
00001CF2  B83C 0008               1238  movem_dn_list_loop     CMP.B  #word_len*4,D4        *have we done the register list [d0,d6]?
00001CF6  6700 0024               1239                         BEQ    movem_dn_last         * yes get the last register bit (d7)
00001CFA  E20E                    1240                         LSR.B  #1,D6                 *shift out a (Dn) bit. 1 if its in the list, 0 if not
00001CFC  6500 0006               1241                         BCS    movem_dn_list_status_1  *a register was identified--check status of register train
00001D00  5244                    1242                         ADDI   #1,D4
00001D02  60EE                    1243                         BRA    movem_dn_list_loop    *check status
00001D04                          1244                      
00001D04  C744                    1245  movem_dn_list_status_1 EXG    D3,D4                 *print appropriate data register corresponding to shifted out bit
00001D06  5343                    1246                         SUBI   #1,D3
00001D08  4EB9 00001E24           1247                         JSR    DR_CMP
00001D0E  4EB9 0000219A           1248                         JSR    print_slash
00001D14  5243                    1249                         ADDI   #1,D3
00001D16  C744                    1250                         EXG    D3,D4
00001D18  5244                    1251                         ADDI   #1,D4
00001D1A  60D6                    1252                         BRA    movem_dn_list_loop   *return to the loop                                   
00001D1C                          1253                          
00001D1C  E20E                    1254  movem_dn_last          LSR.B  #1,D6
00001D1E  6500 0006               1255                         BCS    movem_d7_print
00001D22  6000 0010               1256                         BRA    movem_an_list_prep
00001D26                          1257                          
00001D26  163C 0007               1258  movem_d7_print         MOVE.B #7,D3
00001D2A  103C 0001               1259                         MOVE.B #1,D0                 *flag d7 as having been printed for next round of An's
00001D2E  4EB9 00001E24           1260                         JSR    DR_CMP
00001D34                          1261                         
00001D34  CB46                    1262  movem_an_list_prep     EXG    D5,D6                 *get higher order (an) byte
00001D36  7801                    1263                         MOVE.L #1,D4                 *init loop
00001D38  4203                    1264                         CLR.B  D3   
00001D3A  B83C 0008               1265  movem_an_list_loop     CMP.B  #word_len*4,D4        *have we done the register list [d0,d6]?
00001D3E  6700 0024               1266                         BEQ    movem_an_last         * yes get the last register bit (d7)
00001D42  E20E                    1267                         LSR.B  #1,D6                 *shift out a (Dn) bit. 1 if its in the list, 0 if not
00001D44  6500 0006               1268                         BCS    movem_an_list_status_1  *a register was identified--check status of register train
00001D48  5244                    1269                         ADDI   #1,D4
00001D4A  60EE                    1270                         BRA    movem_an_list_loop    *check status
00001D4C                          1271                      
00001D4C  C744                    1272  movem_an_list_status_1 EXG    D3,D4                 *continue in same way as Dn loop
00001D4E  5343                    1273                         SUBI   #1,D3
00001D50  4EB9 0000219A           1274                         JSR    print_slash
00001D56  4EB9 00001E88           1275                         JSR    PRINT_INNER_AN
00001D5C  5243                    1276                         ADDI   #1,D3
00001D5E  C744                    1277                         EXG    D3,D4
00001D60  5244                    1278                         ADDI   #1,D4
00001D62  60D6                    1279                         BRA    movem_an_list_loop                                      
00001D64                          1280                          
00001D64  E20E                    1281  movem_an_last          LSR.B  #1,D6
00001D66  6500 0006               1282                         BCS    movem_a7_print
00001D6A  6000 0012               1283                         BRA    movem_ea
00001D6E                          1284                          
00001D6E  163C 0007               1285  movem_a7_print         MOVE.B #7,D3
00001D72  4EB9 0000219A           1286                         JSR    print_slash
00001D78  4EB9 00001E88           1287                         JSR    PRINT_INNER_AN
00001D7E                          1288                
00001D7E                          1289               
00001D7E  4EB9 0000216E           1290  movem_ea       JSR     print_comma
00001D84  4201                    1291                 CLR.B   D1
00001D86  E799                    1292                 ROL.L   #3,D1            *get EA bits
00001D88  2601                    1293                 MOVE.L  D1,D3            *and put them into D3
00001D8A  4EB9 00001DAE           1294                 JSR     EA_SRC_beg       *identify and print destination
00001D90  6000 F352               1295                 BRA     prep
00001D94                          1296  
00001D94                          1297  * /movem_handler
00001D94                          1298  *-----------------------------------------------------------------------------
00001D94                          1299  
00001D94                          1300  *-----------------------------------------------------------------------------
00001D94                          1301  * rts_handler
00001D94                          1302  * handles 'RTS'
00001D94                          1303  
00001D94  4281                    1304  rts_handler    CLR.L  D1                    *rts all hardcoded
00001D96  23F9 0000405C 00004160  1305                 MOVE.L RTS,INST_NAME
00001DA0  4EB9 000020B4           1306                 JSR    disp_instr
00001DA6  DAFC 0002               1307                 ADDA   #word_len,A5          *rts took up a word
00001DAA  6000 F338               1308                 BRA    prep
00001DAE                          1309  
00001DAE                          1310  * /rts_handler
00001DAE                          1311  *-----------------------------------------------------------------------------
00001DAE                          1312  
00001DAE                          1313  
00001DAE                          1314  
00001DAE                          1315  *below functions also increment address pointer A5 depending on data fetch size for immediate,absolute addresses
00001DAE                          1316  
00001DAE  DAFC 0002               1317  EA_SRC_beg  ADDA   #word_len,A5             *increment pointer to next word in address range
00001DB2                          1318  
00001DB2                          1319              *(xxx).W, (xxx).L, #<data>        
00001DB2  0C03 0007               1320  EA_SRC      CMPI.B #$7, D3            *Compares if its 111
00001DB6  6700 002E               1321                 BEQ FILTER_EA_MODE
00001DBA                          1322  
00001DBA                          1323              *Dn
00001DBA  0C03 0000               1324              CMPI.B #$0, D3           *Compares if its 000
00001DBE                          1325                  
00001DBE  6700 0060               1326                  BEQ DATA_REGISTER
00001DC2                          1327                  
00001DC2  0C03 0001               1328              CMPI.B #1, D3               *001
00001DC6  6700 0050               1329                  BEQ ADDRESS_MODE
00001DCA                          1330                  
00001DCA                          1331              *(An)
00001DCA  0C03 0002               1332              CMPI.B #$2, D3            *Compares if its 010
00001DCE  6700 0094               1333                  BEQ CLOSED_PARAN
00001DD2                          1334                  
00001DD2                          1335              *(An)+
00001DD2  0C03 0003               1336              CMPI.B #$3, D3            *Compares if its 011
00001DD6  6700 00F0               1337                  BEQ POSTFIX_PLUS
00001DDA                          1338              
00001DDA                          1339              *-(An)                  *Compares if its 100
00001DDA  0C03 0004               1340              CMPI.B #$4, D3
00001DDE  6700 0116               1341                  BEQ PREFIX_MINUS
00001DE2                          1342                  
00001DE2  6600 0024               1343                  BNE INVALID_MODE      *e.g. ARI,PCI
00001DE6                          1344  
00001DE6                          1345  FILTER_EA_MODE
00001DE6                          1346          *Rotate to get register as byte
00001DE6  4203                    1347          CLR.B  D3
00001DE8  E79B                    1348          ROL.L  #3,D3
00001DEA                          1349           
00001DEA                          1350          *(xxx).W
00001DEA  0C03 0000               1351          CMPI.B #$0, D3
00001DEE  6700 0134               1352              BEQ WORD_MODE
00001DF2                          1353              
00001DF2                          1354          *(xxx).L
00001DF2  0C03 0001               1355          CMPI.B #$1, D3
00001DF6  6700 0146               1356              BEQ LONG_MODE
00001DFA                          1357              
00001DFA                          1358          *# <data>
00001DFA  0C03 0004               1359          CMPI.B #$4, D3
00001DFE  6700 0158               1360              BEQ DATA_MODE
00001E02  6600 0004               1361              BNE INVALID_MODE
00001E06  4E75                    1362      RTS
00001E08                          1363  
00001E08                          1364  
00001E08                          1365  INVALID_MODE    *unsupported mode eg PCD,PCI
00001E08  227C 0000411C           1366      MOVE.L  #INV,A1
00001E0E  103C 000E               1367      MOVE.B  #14,D0
00001E12  4E4F                    1368      TRAP    #15
00001E14                          1369      
00001E14  544D                    1370      ADDA    #2,A5   ******* inv opcodes take up a word
00001E16                          1371      
00001E16  4E75                    1372      RTS
00001E18                          1373      
00001E18                          1374  *An
00001E18                          1375  ADDRESS_MODE  *Get register to get what Dn to go to
00001E18  4203                    1376      CLR.B  D3
00001E1A  E79B                    1377      ROL.L  #3,D3
00001E1C  6000 006A               1378      BRA    PRINT_INNER_An
00001E20                          1379  
00001E20                          1380  * Dn
00001E20                          1381  DATA_REGISTER    *Get register to get what Dn to go to
00001E20  4203                    1382      CLR.B  D3
00001E22  E79B                    1383      ROL.L  #3,D3
00001E24                          1384      
00001E24  0C03 0000               1385  DR_CMP  CMPI.B #0, D3
00001E28  6700 016A               1386          BEQ PRINT_D0
00001E2C  0C03 0001               1387      CMPI.B #1, D3
00001E30  6700 0174               1388          BEQ PRINT_D1
00001E34  0C03 0002               1389      CMPI.B #2, D3
00001E38  6700 017E               1390          BEQ PRINT_D2
00001E3C  0C03 0003               1391      CMPI.B #3, D3
00001E40  6700 0188               1392          BEQ PRINT_D3
00001E44  0C03 0004               1393      CMPI.B #4, D3
00001E48  6700 0192               1394          BEQ PRINT_D4
00001E4C  0C03 0005               1395      CMPI.B #5, D3
00001E50  6700 019C               1396          BEQ PRINT_D5
00001E54  0C03 0006               1397      CMPI.B #6, D3
00001E58  6700 01A6               1398          BEQ PRINT_D6
00001E5C  0C03 0007               1399      CMPI.B #7, D3
00001E60  6700 01B0               1400          BEQ PRINT_D7
00001E64                          1401      
00001E64                          1402  * (An)
00001E64                          1403  CLOSED_PARAN  *Get register to get what Dn to go to
00001E64  4203                    1404      CLR.B  D3
00001E66  E79B                    1405      ROL.L  #3,D3
00001E68                          1406      *Prints '('
00001E68  43F9 00004170           1407      LEA open_paren, A1
00001E6E  103C 000E               1408      MOVE.B #14, D0
00001E72  4E4F                    1409      TRAP #15
00001E74                          1410      
00001E74                          1411      *Print The appropriate value of An *Needed to use JSR & RTS
00001E74  4EB9 00001E88           1412      JSR PRINT_INNER_An
00001E7A                          1413     
00001E7A                          1414      *Prints ')'
00001E7A  43F9 00004172           1415      LEA closed_paren, A1
00001E80  103C 000E               1416      MOVE.B #14, D0
00001E84  4E4F                    1417      TRAP #15
00001E86  4E75                    1418      RTS
00001E88                          1419      
00001E88                          1420  *Prints the An in (An) and returns to the original method   
00001E88                          1421  PRINT_INNER_An
00001E88  0C43 0000               1422      CMPI  #0, D3
00001E8C  6700 0196               1423          BEQ    PRINT_A0
00001E90  0C43 0001               1424      CMPI #1, D3
00001E94  6700 01A0               1425          BEQ PRINT_A1
00001E98  0C43 0002               1426      CMPI #2, D3
00001E9C  6700 01AA               1427          BEQ PRINT_A2
00001EA0  0C43 0003               1428      CMPI #3, D3
00001EA4  6700 01B4               1429          BEQ PRINT_A3
00001EA8  0C43 0004               1430      CMPI #4, D3
00001EAC  6700 01BE               1431          BEQ PRINT_A4
00001EB0  0C43 0005               1432      CMPI #5, D3
00001EB4  6700 01C8               1433          BEQ PRINT_A5
00001EB8  0C43 0006               1434      CMPI #6, D3
00001EBC  6700 01D2               1435          BEQ PRINT_A6
00001EC0  0C43 0007               1436      CMPI #7, D3
00001EC4  6700 01DC               1437          BEQ PRINT_A7
00001EC8                          1438  
00001EC8                          1439  * (An)+
00001EC8                          1440  POSTFIX_PLUS
00001EC8  4203                    1441      CLR.B  D3
00001ECA  E79B                    1442      ROL.L  #3,D3
00001ECC                          1443      
00001ECC                          1444      *Prints '('
00001ECC  43F9 00004170           1445      LEA open_paren, A1
00001ED2  103C 000E               1446      MOVE.B #14, D0
00001ED6  4E4F                    1447      TRAP #15
00001ED8                          1448  
00001ED8                          1449      
00001ED8                          1450      *Print The appropriate value of An
00001ED8  4EB8 1E88               1451      JSR PRINT_INNER_An
00001EDC                          1452      
00001EDC                          1453      *Prints ')'
00001EDC  43F9 00004172           1454      LEA closed_paren, A1
00001EE2  103C 000E               1455      MOVE.B #14, D0
00001EE6  4E4F                    1456      TRAP #15
00001EE8                          1457      
00001EE8                          1458       *Prints '+'
00001EE8  43F9 00004174           1459      LEA plus_sign, A1
00001EEE  103C 000E               1460      MOVE.B #14, D0
00001EF2  4E4F                    1461      TRAP #15
00001EF4  4E75                    1462      RTS
00001EF6                          1463      
00001EF6                          1464  *-(An)
00001EF6  4203                    1465  PREFIX_MINUS   CLR.B  D3
00001EF8  E79B                    1466      ROL.L  #3,D3
00001EFA                          1467      
00001EFA                          1468       *Prints '-'
00001EFA  43F9 00004176           1469      LEA neg_sign, A1
00001F00  103C 000E               1470      MOVE.B #14, D0
00001F04  4E4F                    1471      TRAP #15
00001F06                          1472      
00001F06                          1473      *Prints '('
00001F06  43F9 00004170           1474      LEA open_paren, A1
00001F0C  103C 000E               1475      MOVE.B #14, D0
00001F10  4E4F                    1476      TRAP #15
00001F12                          1477      
00001F12                          1478      *Print The appropriate value of An *Needed to use JSR & RTS
00001F12  4EB8 1E88               1479      JSR PRINT_INNER_An
00001F16                          1480      
00001F16                          1481      
00001F16                          1482      *Prints ')'
00001F16  43F9 00004172           1483      LEA closed_paren, A1
00001F1C  103C 000E               1484      MOVE.B #14, D0
00001F20  4E4F                    1485      TRAP #15
00001F22                          1486   
00001F22  4E75                    1487      RTS
00001F24                          1488      
00001F24                          1489  *(xxx).W 
00001F24  48E7 4000               1490  WORD_MODE  MOVEM.L  D1,-(SP)      *save calling state of D1
00001F28  4281                    1491             CLR.L    D1
00001F2A                          1492             *ADDA     #word_len,A5  *increment the pointer to the next address by the length of the next WORD fetched from memory
00001F2A  4EB9 00002184           1493             JSR      print_addr_sgn
00001F30  305D                    1494             MOVE.W   (A5)+,A0      *move that word value to A0 for display
00001F32  4EB9 00002108           1495             JSR      hex_2_ascii   *convert/display the word
00001F38  4CDF 0002               1496             MOVEM.L  (SP)+,D1      *restore D1
00001F3C  4E75                    1497             RTS
00001F3E                          1498      
00001F3E                          1499  *(xxx).L 
00001F3E  48E7 4000               1500  LONG_MODE  MOVEM.L  D1,-(SP)      *save calling state of D1
00001F42  4281                    1501             CLR.L    D1
00001F44                          1502             *ADDA     #long_len,A5 *increment the pointer to the next address by the length of the next LONG fetched from memory
00001F44  4EB9 00002184           1503             JSR      print_addr_sgn
00001F4A  205D                    1504             MOVE.L   (A5)+,A0      *move that long value to A0 for display
00001F4C  4EB9 00002108           1505             JSR      hex_2_ascii   *convert/display the long in A0
00001F52  4CDF 0002               1506             MOVEM.L  (SP)+,D1      *restore D1
00001F56  4E75                    1507             RTS
00001F58                          1508             
00001F58                          1509  
00001F58                          1510  *#<data>
00001F58  48E7 4000               1511  DATA_MODE  MOVEM.L  D1,-(SP)        *save calling state of D1
00001F5C  4281                    1512             CLR.L    D1 
00001F5E  0C12 0001               1513             CMP.B    #1,(A2)         *is immediate data flagged as a word?
00001F62  6700 000A               1514             BEQ      word_data_handler
00001F66  0C12 0002               1515             CMP.B    #2,(A2)         *is immediate data flagged as a long?
00001F6A  6700 0008               1516             BEQ      long_data_handler         
00001F6E                          1517  
00001F6E                          1518                                      *then its a byte held as a word 
00001F6E                          1519  
00001F6E                          1520  *byte_data_handler *ADDA     #byte_len,A5
00001F6E                          1521   *                 MOVE.B   (A5)+,D1     *get immediate byte data and increment address by a byte
00001F6E                          1522    *                BRA      data_mode_print
00001F6E                          1523                  
00001F6E                          1524  word_data_handler *ADDA     #word_len,A5
00001F6E  321D                    1525                    MOVE.W   (A5)+,D1     *get immediate word data and increment address by a word
00001F70  6000 0008               1526                    BRA      data_mode_print
00001F74                          1527  
00001F74                          1528  long_data_handler *ADDA     #long_len,A5
00001F74  221D                    1529                    MOVE.L   (A5)+,D1     *get immediate long data and increment address by a long
00001F76  6000 0002               1530                    BRA      data_mode_print
00001F7A                          1531  
00001F7A  43F9 0000416E           1532  data_mode_print   LEA      imm_sign, A1    *load and print '#' character
00001F80  103C 000E               1533                    MOVE.B   #14, D0
00001F84  4E4F                    1534                    TRAP     #15  
00001F86  2041                    1535                    MOVE.L   D1,A0
00001F88  4EB9 00002108           1536                    JSR      hex_2_ascii  *print the hex data
00001F8E  4CDF 0002               1537                    MOVEM.L  (SP)+,D1     *restore D1
00001F92  4E75                    1538                    RTS
00001F94                          1539  
00001F94  43F9 00001FA2           1540  PRINT_D0 LEA D0_MESS, A1
00001F9A  103C 000E               1541      MOVE.B #14, D0
00001F9E  4E4F                    1542      TRAP #15
00001FA0  4E75                    1543      RTS
00001FA2= 4430 0000               1544  D0_MESS  DC.W 'D0',0
00001FA6                          1545  
00001FA6                          1546  
00001FA6  43F9 00001FB4           1547  PRINT_D1 LEA D1_MESS, A1
00001FAC  103C 000E               1548      MOVE.B #14, D0
00001FB0  4E4F                    1549      TRAP #15
00001FB2  4E75                    1550      RTS
00001FB4= 4431 0000               1551  D1_MESS  DC.W 'D1',0
00001FB8                          1552  
00001FB8                          1553  
00001FB8  43F9 00001FC6           1554  PRINT_D2 LEA D2_MESS, A1
00001FBE  103C 000E               1555      MOVE.B #14, D0
00001FC2  4E4F                    1556      TRAP #15
00001FC4  4E75                    1557      RTS
00001FC6= 4432 0000               1558  D2_MESS  DC.W 'D2',0
00001FCA                          1559  
00001FCA                          1560  
00001FCA  43F9 00001FD8           1561  PRINT_D3 LEA D3_MESS, A1
00001FD0  103C 000E               1562      MOVE.B #14, D0
00001FD4  4E4F                    1563      TRAP #15
00001FD6  4E75                    1564      RTS
00001FD8= 4433 0000               1565  D3_MESS  DC.W 'D3',0
00001FDC                          1566  
00001FDC                          1567  
00001FDC  43F9 00001FEA           1568  PRINT_D4 LEA D4_MESS, A1
00001FE2  103C 000E               1569      MOVE.B #14, D0
00001FE6  4E4F                    1570      TRAP #15
00001FE8  4E75                    1571      RTS
00001FEA= 4434 0000               1572  D4_MESS  DC.W 'D4',0
00001FEE                          1573  
00001FEE                          1574  
00001FEE  43F9 00001FFC           1575  PRINT_D5 LEA D5_MESS, A1
00001FF4  103C 000E               1576      MOVE.B #14, D0
00001FF8  4E4F                    1577      TRAP #15
00001FFA  4E75                    1578      RTS
00001FFC= 4435 0000               1579  D5_MESS  DC.W 'D5',0
00002000                          1580  
00002000                          1581  
00002000  43F9 0000200E           1582  PRINT_D6 LEA D6_MESS, A1
00002006  103C 000E               1583      MOVE.B #14, D0
0000200A  4E4F                    1584      TRAP #15
0000200C  4E75                    1585      RTS
0000200E= 4436 0000               1586  D6_MESS  DC.W 'D6',0
00002012                          1587  
00002012  43F9 00002020           1588  PRINT_D7 LEA D7_MESS, A1
00002018  103C 000E               1589      MOVE.B #14, D0
0000201C  4E4F                    1590      TRAP #15
0000201E  4E75                    1591      RTS
00002020= 4437 0000               1592  D7_MESS  DC.W 'D7',0
00002024                          1593      
00002024                          1594  
00002024  43F9 00002032           1595  PRINT_A0 LEA A0_MESS, A1
0000202A  103C 000E               1596      MOVE.B #14, D0
0000202E  4E4F                    1597      TRAP #15
00002030  4E75                    1598      RTS
00002032= 4130 0000               1599  A0_MESS DC.W 'A0',0
00002036                          1600  
00002036  43F9 00002044           1601  PRINT_A1 LEA A1_MESS, A1
0000203C  103C 000E               1602      MOVE.B #14, D0
00002040  4E4F                    1603      TRAP #15
00002042  4E75                    1604      RTS
00002044= 4131 0000               1605  A1_MESS DC.W 'A1',0
00002048                          1606  
00002048  43F9 00002056           1607  PRINT_A2 LEA A2_MESS, A1
0000204E  103C 000E               1608      MOVE.B #14, D0
00002052  4E4F                    1609      TRAP #15
00002054  4E75                    1610      RTS
00002056= 4132 0000               1611  A2_MESS DC.W 'A2',0
0000205A                          1612  
0000205A  43F9 00002068           1613  PRINT_A3 LEA A3_MESS, A1
00002060  103C 000E               1614      MOVE.B #14, D0
00002064  4E4F                    1615      TRAP #15
00002066  4E75                    1616      RTS
00002068= 4133 0000               1617  A3_MESS DC.W 'A3',0
0000206C                          1618  
0000206C  43F9 0000207A           1619  PRINT_A4 LEA A4_MESS, A1
00002072  103C 000E               1620      MOVE.B #14, D0
00002076  4E4F                    1621      TRAP #15
00002078  4E75                    1622      RTS
0000207A= 4134 0000               1623  A4_MESS DC.W 'A4',0
0000207E                          1624  
0000207E  43F9 0000208C           1625  PRINT_A5 LEA A5_MESS, A1
00002084  103C 000E               1626      MOVE.B #14, D0
00002088  4E4F                    1627      TRAP #15
0000208A  4E75                    1628      RTS
0000208C= 4135 0000               1629  A5_MESS DC.W 'A5',0
00002090                          1630  
00002090  43F9 0000209E           1631  PRINT_A6 LEA A6_MESS, A1
00002096  103C 000E               1632      MOVE.B #14, D0
0000209A  4E4F                    1633      TRAP #15
0000209C  4E75                    1634      RTS
0000209E= 4136 0000               1635  A6_MESS DC.W 'A6',0
000020A2                          1636  
000020A2  43F9 000020B0           1637  PRINT_A7 LEA A7_MESS, A1
000020A8  103C 000E               1638      MOVE.B #14, D0
000020AC  4E4F                    1639      TRAP #15
000020AE  4E75                    1640      RTS
000020B0= 4137 0000               1641  A7_MESS DC.W 'A7',0
000020B4                          1642                
000020B4                          1643  *-----------------------------------------------------------------------------------------
000020B4                          1644  *disp_instr
000020B4                          1645  * displays the instruction name in assembly and the address of the instruction
000020B4                          1646  
000020B4  48E7 4000               1647  disp_instr    MOVEM.L D1, -(SP)     *save state of D1 before using it below
000020B8                          1648  
000020B8  4EB9 00002184           1649                JSR     print_addr_sgn *print '$'
000020BE  204D                    1650                MOVEA.L A5,A0          *load A0 with the current address for the next function
000020C0  4EB9 00002108           1651                JSR     hex_2_ascii    *convert the hex addr to ascii to print
000020C6                          1652                
000020C6  43F9 0000417F           1653                LEA     space,A1
000020CC  103C 000E               1654                MOVE.B  #14,D0
000020D0  4E4F                    1655                TRAP    #15
000020D2                          1656                
000020D2  43F9 00004160           1657                LEA.L   INST_NAME,A1  *move the (assembly) name of this instruction into A1
000020D8  103C 000E               1658                MOVE.B  #14,D0
000020DC  4E4F                    1659                TRAP    #15
000020DE                          1660                
000020DE  43F9 00004168           1661                LEA     INST_NAME_EXT,A1  *if the instruction name was longer than 32 bits
000020E4  103C 000E               1662                MOVE.B  #14,D0
000020E8  4E4F                    1663                TRAP    #15
000020EA                          1664                
000020EA  43F9 00004148           1665                LEA.L   SIZECODE,A1       *print size of operation
000020F0  103C 000E               1666                MOVE.B  #14,D0
000020F4  4E4F                    1667                TRAP    #15
000020F6                          1668                
000020F6  43F9 0000417F           1669                LEA     space,A1
000020FC  103C 000E               1670                MOVE.B  #14,D0
00002100  4E4F                    1671                TRAP    #15
00002102                          1672                
00002102                          1673                
00002102  4CDF 0002               1674                MOVEM.L  (SP)+,D1         *restore D1
00002106  4E75                    1675                RTS
00002108                          1676                
00002108                          1677  * /disp_instr
00002108                          1678  *-----------------------------------------------------------------------------------------  
00002108                          1679  
00002108                          1680  
00002108                          1681  *----------------------------------------------------------------------------------------- 
00002108                          1682  *hex_2_ascii
00002108                          1683  * converts a hex number to its ascii string equivalent (0s in MSB positions).
00002108                          1684  
00002108                          1685  * move A0 into D3 and split first part of address and second part of address 
00002108                          1686  *   to D3 and D4 respectively
00002108                          1687  
00002108                          1688  *D3:less significant word of address
00002108                          1689  *D4:more significant word of address 
00002108                          1690  *D5:holds iteration number
00002108                          1691  *D6:index into table
00002108                          1692  
00002108                          1693  h2a_regs        REG     D1/D3-D6/A0/A4
00002108                          1694  
00002108  48E7 5E88               1695  hex_2_ascii     MOVEM.L h2a_regs,-(SP)  *save state of registers before call                                
0000210C  4285                    1696                  CLR.L   D5              *clear iteration counter
0000210E  4281                    1697                  CLR.L   D1
00002110  4286                    1698                  CLR.L   D6
00002112  2808                    1699                  MOVE.L  A0,D4           *save address in D4
00002114  2604                    1700                  MOVE.L  D4,D3           *and move it to D3
00002116  4244                    1701                  CLR.W   D4              
00002118  4843                    1702                  SWAP    D3              *partition the first and second long of the address
0000211A  4243                    1703                  CLR.W   D3
0000211C  49F9 00004000           1704  h2a_prep        LEA.L   string_tbl,A4
00002122  E99C                    1705                  ROL.L   #4,D4           *roll first byte over for analysis
00002124  B834 6801               1706  h2a_loop        CMP.B   1(A4,D6.L),D4   *find hex/ascii match in table
00002128  6700 0016               1707                  BEQ     h2a_match
0000212C  BC3C 0020               1708                  cmp.b   #32,d6
00002130  6C00 0006               1709                  BGE     h2a_f 
00002134  5486                    1710                  ADDI.L  #2,D6
00002136  60EC                    1711                  BRA     h2a_loop
00002138  123C 000F               1712  h2a_f           MOVE.B  #$F,D1
0000213C  6000 0006               1713                  BRA     h2a_match_cont        
00002140  1234 6000               1714  h2a_match       MOVE.B  (A4,D6.W),D1    *move the match to D1
00002144  103C 0006               1715  h2a_match_cont  MOVE.B  #6,D0           *display the value in D1
00002148  4E4F                    1716                  TRAP    #15
0000214A  4204                    1717                  CLR.B   D4
0000214C  4206                    1718                  CLR.B   D6
0000214E  5245                    1719                  ADDI    #1,D5           *increment loop counter
00002150  BA3C 0008               1720                  CMP.B   #h2a_its,D5     *have we done every nibble
00002154  6C00 0012               1721                  BGE     h2a_ret
00002158  BA3C 0004               1722                  CMP.B   #h2a_its-4,D5   *are we halfway done (time to get second part of addr?)
0000215C  6700 0004               1723                  BEQ     h2a_swap
00002160  60BA                    1724                  BRA     h2a_prep
00002162  2803                    1725  h2a_swap        MOVE.L  D3,D4           *move second part of word to D4 
00002164  4286                    1726                  CLR.L   D6              *clear the index into the string table               
00002166  60B4                    1727                  BRA     h2a_prep
00002168                          1728  
00002168  4CDF 117A               1729  h2a_ret         MOVEM.L  (SP)+,h2a_regs   *restore state of registers 
0000216C  4E75                    1730                  RTS
0000216E                          1731                  
0000216E  =00000008               1732  h2a_its         EQU     8
0000216E                          1733  
0000216E                          1734  * /hex_2_ascii
0000216E                          1735  *----------------------------------------------------------------------------------------- 
0000216E                          1736  * the following functions print characters commonly used by this program
0000216E                          1737  
0000216E  48E7 0040               1738  print_comma   MOVEM.L A1,-(SP)
00002172  43F9 00004178           1739                LEA     comma,A1
00002178  103C 000E               1740                MOVE.B  #14,D0
0000217C  4E4F                    1741                TRAP    #15    
0000217E  4CDF 0200               1742                MOVEM.L (SP)+,A1
00002182  4E75                    1743                RTS    
00002184                          1744                
00002184  48E7 0040               1745  print_addr_sgn MOVEM.L A1,-(SP)
00002188  43F9 0000416C           1746                 LEA     addr_sign,A1
0000218E  103C 000E               1747                 MOVE.B  #14,D0
00002192  4E4F                    1748                 TRAP    #15    
00002194  4CDF 0200               1749                 MOVEM.L (SP)+,A1
00002198  4E75                    1750                 RTS    
0000219A                          1751                 
0000219A  48E7 0040               1752  print_slash    MOVEM.L A1,-(SP)
0000219E  43F9 0000417A           1753                 LEA     slash,A1
000021A4  103C 000E               1754                 MOVE.B  #14,D0
000021A8  4E4F                    1755                 TRAP    #15    
000021AA  4CDF 0200               1756                 MOVEM.L (SP)+,A1
000021AE  4E75                    1757                 RTS    
000021B0                          1758                 
000021B0  48E7 0040               1759  print_hyphen   MOVEM.L A1,-(SP)
000021B4  43F9 00004176           1760                 LEA     neg_sign,A1
000021BA  103C 000E               1761                 MOVE.B  #14,D0
000021BE  4E4F                    1762                 TRAP    #15    
000021C0  4CDF 0200               1763                 MOVEM.L (SP)+,A1
000021C4  4E75                    1764                 RTS                 
000021C6                          1765                 
000021C6  43F9 0000417C           1766  done          LEA     nl,A1
000021CC  103C 000E               1767                MOVE.B  #14,D0
000021D0  4E4F                    1768                TRAP    #15
000021D2  43F9 00004258           1769                LEA     done_msg,A1
000021D8  103C 000E               1770                MOVE.B  #14,D0
000021DC  4E4F                    1771                TRAP    #15
000021DE  103C 0009               1772                MOVE.B  #9,D0         *indicate end of simulation
000021E2  4E4F                    1773                TRAP    #15
000021E4                          1774                
000021E4  43F9 0000421E           1775  addr_err      LEA     bad_addr,A1   *load the error msg into A1
000021EA  103C 000E               1776                MOVE.B  #14,D0       *indicate output
000021EE  4E4F                    1777                TRAP    #15
000021F0  43F9 0000417C           1778                LEA     nl,A1        *load new line into A1
000021F6  103C 000E               1779                MOVE.B  #14,D0        *indicate output
000021FA  4E4F                    1780                TRAP    #15
000021FC  4282                    1781                CLR.L   D2            *reset msb index for further iterations
000021FE  6000 EE04               1782                BRA     disp_msg      *go back to welcome msg
00002202                          1783                           
00002202  43F9 0000416E           1784  fatal_err     LEA     imm_sign,A1   *load the error msg into A1
00002208  103C 000E               1785                MOVE.B  #14,D0       *indicate output
0000220C  4E4F                    1786                TRAP    #15
0000220E  43F9 0000417C           1787                LEA     nl,A1        *load new line into A1
00002214  103C 000E               1788                MOVE.B  #14,D0        *indicate output
00002218  4E4F                    1789                TRAP    #15
0000221A  4282                    1790                CLR.L   D2            *reset msb index for further iterations
0000221C  60A8                    1791                BRA     done         *go back to welcome msg
0000221E                          1792                
0000221E                          1793  *-------------------------------------------------------------------------------------------------------------------------------------------              
00004000                          1794  data          ORG     $4000
00004000                          1795                
00004000                          1796  *string table for converting user input addresses from ascii to hex      
00004000= 30 00                   1797  string_tbl    DC.B    $30,$0      *{ascii,hex}
00004002= 31 01                   1798                DC.B    $31,$1          
00004004= 32 02                   1799                DC.B    $32,$2 
00004006= 33 03                   1800                DC.B    $33,$3
00004008= 34 04                   1801                DC.B    $34,$4
0000400A= 35 05                   1802                DC.B    $35,$5
0000400C= 36 06                   1803                DC.B    $36,$6
0000400E= 37 07                   1804                DC.B    $37,$7
00004010= 38 08                   1805                DC.B    $38,$8
00004012= 39 09                   1806                DC.B    $39,$9            
00004014= 41 0A                   1807                DC.B    $41,$A
00004016= 42 0B                   1808                DC.B    $42,$B
00004018= 43 0C                   1809                DC.B    $43,$C
0000401A= 44 0D                   1810                DC.B    $44,$D
0000401C= 45 0E                   1811                DC.B    $45,$E
0000401E= 46 0F                   1812                DC.B    $46,$F
00004020                          1813                
00004020                          1814               *hex_1
00004020                          1815               *contains first hex digit of the instruction with corresponding mappings
00004020                          1816               *also contains all supported instructions in the comment field
00004020                          1817                * 1 means the mapping is ambiguous (and we have to read more bits in instruction) 0 means its not.
00004020                          1818                * -1 means the instruction isnt one that can be disassembled in this program             
00004020= 01 01                   1819  hex_1         DC.B    $01,$01  * 'MOVE.B','MOVEA.B'
00004022= 03 01                   1820                DC.B    $03,$01  * 'MOVE.W','MOVEA.W'
00004024= 02 01                   1821                DC.B    $02,$01  * 'MOVEA.L','MOVEA.L'
00004026= 04 01                   1822                DC.B    $04,$01  * 'MOVEM','LEA','NEG','JSR','RTS','NOP'
00004028= 0D 01                   1823                DC.B    $0D,$01  * 'ADD','ADDA'
0000402A= 00 01                   1824                DC.B    $00,$01  * 'ORI','BCLR','CMPI','ADDI','EORI','SUBI'
0000402C= 0B 01                   1825                DC.B    $0B,$01  * 'EOR','CMP'
0000402E= 0E 00                   1826                DC.B    $0E,$00  * 'LSR','LSL','ASR','ASL','ROL','ROR' (determined in shift_roll_handler)
00004030= 06 00                   1827                DC.B    $06,$00  * Bcc('BCS','BGE','BLT','BVC','BRA','BCC','BNE','BEQ','BVS','BGT','BLE')
00004032= 09 00                   1828                DC.B    $09,$00  * 'SUB','SUBA' (determined in sub_handler)
00004034= 05 01                   1829                DC.B    $05,$01  * 'SUBQ','ADDQ'
00004036= 0C 00                   1830                DC.B    $0C,$00  * 'MULS'
00004038= 08 01                   1831                DC.B    $08,$01  * 'OR','DIVS(word)'
0000403A= FF FF                   1832                DC.B    -1,-1    * unsupported instruction-first hex val is not one in the table above
0000403C                          1833  
0000403C                          1834  *below table holds ascii codes for instruction printing
0000403C                          1835  *MOVEA         DC.L    'MOVEA',0
0000403C                          1836  *MOVEM         DC.L    'MOVEM',0              
0000403C= 4D4F5600 00000000       1837  MOV           DC.L    'MOV',0
00004044= 4C454100 00000000       1838  LEA           DC.L    'LEA',0
0000404C= 4E454700 00000000       1839  NEG           DC.L    'NEG',0 
00004054= 4A535200 00000000       1840  JSR           DC.L    'JSR',0
0000405C= 52545300 00000000       1841  RTS           DC.L    'RTS',0
00004064= 4E4F5000 00000000       1842  NOP           DC.L    'NOP',0
0000406C= 41444400 00000000       1843  ADD           DC.L    'ADD',0
00004074= 42434C00 00000000       1844  BCL           DC.L    'BCL',0
0000407C                          1845  *ADDA          DC.L    'ADDA',0
0000407C= 4F524900 00000000       1846  ORI           DC.L    'ORI',0
00004084                          1847  *BCLR          DC.L    'BCLR',0
00004084                          1848  *CMPI          DC.L    'CMPI',0
00004084= 454F5200 00000000       1849  EOR           DC.L    'EOR',0
0000408C= 434D5000 00000000       1850  CMP           DC.L    'CMP',0
00004094= 4C53 0000               1851  LS            DC.W    'LS',0    *LSL,LSR
00004098= 4153 0000               1852  AS            DC.W    'AS',0    *ASL,ASR
0000409C= 524F 0000               1853  RO            DC.W    'RO',0    *ROL,ROR
000040A0= 42435300 00000000       1854  BCS           DC.L    'BCS',0
000040A8= 42474500 00000000       1855  BGE           DC.L    'BGE',0
000040B0= 424C5400 00000000       1856  BLT           DC.L    'BLT',0
000040B8= 42564300 00000000       1857  BVC           DC.L    'BVC',0
000040C0= 42524100 00000000       1858  BRA           DC.L    'BRA',0
000040C8= 42434300 00000000       1859  BCC           DC.L    'BCC',0
000040D0= 424E4500 00000000       1860  BNE           DC.L    'BNE',0
000040D8= 42455100 00000000       1861  BEQ           DC.L    'BEQ',0
000040E0= 42565300 00000000       1862  BVS           DC.L    'BVS',0
000040E8= 42475400 00000000       1863  BGT           DC.L    'BGT',0
000040F0= 424C4500 00000000       1864  BLE           DC.L    'BLE',0
000040F8= 53554200 00000000       1865  SUB           DC.L    'SUB',0
00004100= 4D554C00 00000000       1866  MUL           DC.L    'MUL',0
00004108= 44495600 00000000       1867  DIV           DC.L    'DIV',0
00004110= 4F52 0000               1868  OR            DC.W    'OR',0
00004114= 44415400 00000000       1869  DAT           DC.L    'DAT',0   *DATA
0000411C= 494E5600 00000000       1870  INV           DC.L    'INV',0   *used for displaying unsupported addressing modes e.g --  MOVE.L 8(A4,D0),5(A4)
00004124                          1871  
00004124                          1872  *below holds extended codes to append to the instruction
00004124= 41 00                   1873  A             DC.B    'A',0
00004126= 49 00                   1874  I             DC.B    'I',0
00004128= 52 00                   1875  R             DC.B    'R',0
0000412A= 4D 00                   1876  M             DC.B    'M',0
0000412C= 4C 00                   1877  L             DC.B    'L',0
0000412E= 51 00                   1878  Q             DC.B    'Q',0
00004130= 53 00                   1879  S             DC.B    'S',0
00004132= 45 00                   1880  E             DC.B    'E',0
00004134= 454D 0000               1881  EM            DC.W    'EM',0
00004138= 4541 0000               1882  EA            DC.W    'EA',0
0000413C                          1883  
0000413C                          1884  *below holds ascii size strings to load to variable SIZECODE            
0000413C= 2E42 0000               1885  SIZEB         DC.W    '.B',00
00004140= 2E57 0000               1886  SIZEW         DC.W    '.W',0
00004144= 2E4C 0000               1887  SIZEL         DC.W    '.L',00
00004148                          1888  SIZECODE      DS.L    1
0000414C                          1889  
0000414C                          1890  *below establishes lengths of data units
0000414C  =00000001               1891  byte_len      EQU     1
0000414C  =00000002               1892  word_len      EQU     2
0000414C  =00000004               1893  long_len      EQU     4            
0000414C                          1894                
0000414C                          1895  * holds the condition of each branch                
0000414C= 05                      1896  bcc_tbl       DC.B    %0101 *BCS
0000414D= 0C                      1897                DC.B    %1100 *BGE
0000414E= 0D                      1898                DC.B    %1101 *BLT
0000414F= 08                      1899                DC.B    %1000 *BVC
00004150= 00                      1900                DC.B    %0000 *BRA  
00004151= 04                      1901                DC.B    %0100 *BCC
00004152= 06                      1902                DC.B    %0110 *BNE
00004153= 07                      1903                DC.B    %0111 *BEQ
00004154= 09                      1904                DC.B    %1001 *BVS
00004155= 0E                      1905                DC.B    %1110 *BGT
00004156= 0F                      1906                DC.B    %1111 *BLE   
00004157= FF                      1907                DC.B    -1    *invalid branch type
00004158                          1908                
00004158                          1909  *below holds shift counts for arithmetic/logical shifts
00004158= 00                      1910  shift_tbl     DC.B    %000
00004159= 01                      1911                DC.B    %001
0000415A= 02                      1912                DC.B    %010
0000415B= 03                      1913                DC.B    %011
0000415C= 04                      1914                DC.B    %100
0000415D= 05                      1915                DC.B    %101
0000415E= 06                      1916                DC.B    %110
0000415F= 07                      1917                DC.B    %111                              
00004160                          1918  
00004160                          1919  *below variables hold the name of the instruction
00004160                          1920  INST_NAME     DS.L    2         *holds the instruction to be printed (e.g. ADD.L; MOVE.B)
00004168                          1921  INST_NAME_EXT DS.L    1         *holds any part of instruction over 32 bits (eg last M in MOVEM)
0000416C                          1922  
0000416C                          1923  *below characters are used for printing
0000416C= 24 00                   1924  addr_sign     DC.B    '$',0
0000416E= 23 00                   1925  imm_sign      DC.B    '#',0
00004170= 28 00                   1926  open_paren    DC.B    '(',0
00004172= 29 00                   1927  closed_paren  DC.B    ')',0
00004174= 2B 00                   1928  plus_sign     DC.B    '+',0
00004176= 2D 00                   1929  neg_sign      DC.B    '-',0
00004178= 2C 00                   1930  comma         DC.B    ',',0
0000417A= 2F 00                   1931  slash         DC.B    '/',0
0000417C= 0D 0A 00                1932  nl            DC.B    '',CR,LF,0
0000417F= 20 20 20 20 00          1933  space         DC.B    '    ',0
00004184                          1934  
00004184                          1935  *below holds intro messages to user                       
00004184= 50 6C 65 61 73 65 ...   1936  display_start DC.B    'Please enter a maximum 32-bit starting memory address in hex (-1 to quit): ',CR,LF,0
000041D2= 50 6C 65 61 73 65 ...   1937  display_end   DC.B    'Please enter a maximum 32-bit ending memory address in hex (-1 to quit): ',CR,LF,0
0000421E= 50 6C 65 61 73 65 ...   1938  bad_addr      DC.B    'Please enter an even, eight digit hex address',CR,LF,0
0000424E                          1939  
0000424E                          1940  
0000424E                          1941  *below variables store the starting and ending addresses the user provides
0000424E                          1942  user_start    DS.L    1
00004252                          1943  user_end      DS.L    1
00004256                          1944  
00004256= 2D31                    1945  exit_val      DC.W    $2D31  *sentinel exit value
00004258                          1946               
00004258= 64 6F 6E 65 00          1947  done_msg      DC.B    'done',0
0000425D                          1948  
0000425D                          1949  
0000425D                          1950                END     start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A                   4124
A0_MESS             2032
A1_MESS             2044
A2_MESS             2056
A3_MESS             2068
A4_MESS             207A
A5_MESS             208C
A6_MESS             209E
A7_MESS             20B0
ADD                 406C
ADDA_BEG            142C
ADDA_HANDLER        1422
ADDA_LONG_HANDLER   1452
ADDA_SAVE_DATA      1460
ADDA_WORD_HANDLER   1440
ADDI_HANDLER        183A
ADDQ_HANDLER        16E4
ADDRESS_MODE        1E18
ADDR_ERR            21E4
ADDR_SIGN           416C
ADD_HANDLER         1566
AS                  4098
AS_HANDLER          1B04
AS_REG              1BB8
BAD_ADDR            421E
BCC                 40C8
BCCD_HANDLER        19EC
BCC_CALC            1A5A
BCC_COMPLETE        1A6E
BCC_COND            193A
BCC_DETERMINER      194A
BCC_DISPM           1A40
BCC_HANDLER         192E
BCC_LONG_HANDLER    1A6A
BCC_TBL             414C
BCC_WORD_HANDLER    1A66
BCL                 4074
BCLR_DYNAMIC        17CA
BCLR_STATIC         1780
BCS                 40A0
BCS_HANDLER         19A6
BEQ                 40D8
BEQ_HANDLER         1A08
BGE                 40A8
BGE_HANDLER         19B4
BGT                 40E8
BGT_HANDLER         1A24
BLE                 40F0
BLE_HANDLER         1A32
BLT                 40B0
BLT_HANDLER         19C2
BNE                 40D0
BNE_HANDLER         19FA
BRA                 40C0
BRA_HANDLER         19DE
BVC                 40B8
BVC_HANDLER         19D0
BVS                 40E0
BVS_HANDLER         1A16
BYTE_LEN            1
CASE_QUICK8         16DE
CHAR_CONVERT        106E
CHECK_FIRST         1134
CLOSED_PARAN        1E64
CLOSED_PAREN        4172
CMP                 408C
CMPA_HANDLER        1494
CMPA_OR_CMP         1394
CMPI_BYTE           1724
CMPI_HANDLER        16F2
CMPI_LONG           1748
CMPI_RET            1756
CMPI_WORD           1736
CMP_HANDLER         15B2
COMMA               4178
CONVERSION          1056
CR                  D
D0_MESS             1FA2
D1_MESS             1FB4
D2_MESS             1FC6
D3_MESS             1FD8
D4_MESS             1FEA
D5_MESS             1FFC
D6_MESS             200E
D7_MESS             2020
DAT                 4114
DATA                4000
DATA_MODE           1F58
DATA_MODE_PRINT     1F7A
DATA_REGISTER       1E20
DISPLAY_END         41D2
DISPLAY_START       4184
DISP_INSTR          20B4
DISP_MSG            1004
DIV                 4108
DIVSW_BEG           15D8
DIVSW_HANDLER       15C4
DONE                21C6
DONE_MSG            4258
DR_CMP              1E24
E                   4132
EA                  4138
EA_SRC              1DB2
EA_SRC_BEG          1DAE
EM                  4134
END_ADDR            1096
END_CONV            1094
EOR                 4084
EORI_HANDLER        186C
EOR_HANDLER         15A0
EXIT_VAL            4256
FATAL_ERR           2202
FILTER_EA_MODE      1DE6
GET_DATA            13E2
GET_NEXT_BYTE       105C
H2A_F               2138
H2A_ITS             8
H2A_LOOP            2124
H2A_MATCH           2140
H2A_MATCH_CONT      2144
H2A_PREP            211C
H2A_REGS            117A
H2A_RET             2168
H2A_SWAP            2162
HEX_1               4020
HEX_2_ASCII         2108
I                   4126
IMM_SIGN            416E
INST_NAME           4160
INST_NAME_EXT       4168
INST_PARSE          117C
INV                 411C
INVALID_MODE        1E08
INV_BCC_HANDLER     1A86
INV_BCC_LONG        1AA6
INV_BCC_WORD        1A9E
INV_HANDLER         1146
IS_IT_MOVEM         12F0
JSR                 4054
JSR_HANDLER         1C70
L                   412C
LEA                 4044
LEA_HANDLER         1C3C
LEA_RESOLVE         12D4
LF                  A
LONG_DATA_HANDLER   1F74
LONG_LEN            4
LONG_MODE           1F3E
LS                  4094
LS_HANDLER          1B12
LS_REG              1BC6
M                   412A
MATCH_FOUND         1170
MOV                 403C
MOVEA_HANDLER       11FE
MOVEM_A7_PRINT      1D6E
MOVEM_AN            1CAC
MOVEM_AN_LAST       1D64
MOVEM_AN_LIST_LOOP  1D3A
MOVEM_AN_LIST_PREP  1D34
MOVEM_AN_LIST_STATUS_1  1D4C
MOVEM_CHECK         1300
MOVEM_D7_PRINT      1D26
MOVEM_DN            1CD0
MOVEM_DN_LAST       1D1C
MOVEM_DN_LIST_LOOP  1CF2
MOVEM_DN_LIST_STATUS_1  1D04
MOVEM_EA            1D7E
MOVEM_HANDLER       1C90
MOVEM_LIST          1CD8
MOVEM_LONG          1CC2
MOVEM_RESOLVE       12E6
MOVEM_WORD          1CB4
MOVE_EA             1208
MOVE_HANDLER        11F0
MUL                 4100
MULS_HANDLER        160A
NEG                 404C
NEG_BYTE            18F8
NEG_HANDLER         18D0
NEG_LONG            1914
NEG_RESOLVE         12B6
NEG_RET             191E
NEG_SIGN            4176
NEG_WORD            1906
NL                  417C
NOP                 4064
NOP_HANDLER         140A
OPEN_PAREN          4170
OR                  4110
ORI                 407C
ORI_HANDLER         1806
OR_BYTE             14EC
OR_DN_LEFT          14CA
OR_DN_RIGHT         14C0
OR_EA               151E
OR_HANDLER          14A0
OR_LEFT_PRINT       154E
OR_LONG             1510
OR_SIZE             14D4
OR_WORD             14FE
PLUS_SIGN           4174
POSTFIX_PLUS        1EC8
PREFIX_MINUS        1EF6
PREP                10E4
PRINT_A0            2024
PRINT_A1            2036
PRINT_A2            2048
PRINT_A3            205A
PRINT_A4            206C
PRINT_A5            207E
PRINT_A6            2090
PRINT_A7            20A2
PRINT_ADDR_SGN      2184
PRINT_COMMA         216E
PRINT_D0            1F94
PRINT_D1            1FA6
PRINT_D2            1FB8
PRINT_D3            1FCA
PRINT_D4            1FDC
PRINT_D5            1FEE
PRINT_D6            2000
PRINT_D7            2012
PRINT_HYPHEN        21B0
PRINT_INNER_AN      1E88
PRINT_SLASH         219A
PUSH_BYTE           1082
Q                   412E
Q_PRINTS            16BC
R                   4128
RO                  409C
RO_HANDLER          1B20
RO_REG              1BD4
RS_0_SHIFT_HANDLER  1C12
RTS                 405C
RTS_HANDLER         1D94
S                   4130
SHIFT_TBL           4158
SIZEB               413C
SIZECODE            4148
SIZEL               4144
SIZEW               4140
SLASH               417A
SPACE               417F
SR_BYTE             1B6E
SR_LONG             1B8A
SR_MEM              1AE8
SR_MEM_RET          1B2E
SR_REG              1B42
SR_REG_FINAL        1C18
SR_REG_PRINT_DN     1C0A
SR_REG_PRINT_IMM    1BF6
SR_REG_PRINT_SRC    1BE2
SR_REG_RET          1B98
SR_REG_TYPE         1B50
SR_REG_TYPE_BEG     1B54
SR_TYPE_RESOLVE     1AC8
SR_TYPE_RESOLVE_BEG  1AD2
SR_WORD             1B7C
STACK               7000
START               1000
START_ADDR          1000
STRING_TBL          4000
SUB                 40F8
SUBA_HANDLER        1488
SUBI_HANDLER        189E
SUBQ_BYTE           166E
SUBQ_DET            1644
SUBQ_EA             16A6
SUBQ_HANDLER        163A
SUBQ_LONG           1692
SUBQ_WORD           1680
SUB_HANDLER         157C
USER_END            4252
USER_START          424E
WORD_DATA_HANDLER   1F6E
WORD_LEN            2
WORD_MODE           1F24
_0_HANDLER          1320
_11_HANDLER         1366
_11_RESOLVE         1376
_13_HANDLER         130A
_1_HANDLER          11C6
_2_HANDLER          125C
_3_HANDLER          1232
_4_HANDLER          128A
_4_RESOLVE          12C6
_5_HANDLER          13D2
_8_CHECK            13C0
_8_HANDLER          13A4
_SHIFT_ROLL_HANDLER  1AAE
