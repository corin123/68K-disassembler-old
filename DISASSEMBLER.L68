00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/15/2018 11:39:04 PM

00000000                             1  *-----------------------------------------------------------------------------------------------
00000000                             2  *                                  Disassembler program
00000000                             3  *                                      Winter 2018
00000000                             4  
00000000                             5  *               Written by : Sean Coulter, Corin Ennis, Antony Mbugua
00000000                             6  *               Description: A program to disassemble Motorola 68K source files
00000000                             7  *-----------------------------------------------------------------------------------------------            
00000000                             8              
00000000  =0000000D                  9  CR         EQU   $0D
00000000  =0000000A                 10  LF         EQU   $0A
00000000  =00007000                 11  stack      EQU   $7000
00000000  =00001000                 12  start_addr EQU   $1000
00000000                            13                
00001000                            14  start         ORG     start_addr             
00001000                            15                
00001000  4FF8 7000                 16                lea     stack,sp
00001004  DAFC 0600                 17                adda.w  #$600,a5
00001008  DCFC 0700                 18                adda.w  #$700,a6
0000100C                            19                
0000100C                            20                
0000100C                            21   *D1: sentinel exit value
0000100C                            22   *D2: index of MSB
0000100C                            23   *D3: length of user input string
0000100C                            24   *D4: index of pointer to string table
0000100C                            25   *D6: ascii value holding MSB
0000100C                            26   *D7: max valid input
0000100C                            27                
0000100C  4244                      28                CLR      D4                 *register used in address calculation
0000100E  4247                      29                CLR      D7                 *register used for address calculation
00001010                            30  
00001010  BDCD                      31  prep          CMPA.L   A5,A6              *have we read from start-end?
00001012  6D00 0E64                 32                BLT      done               * yes-end            
00001016  103C 0005                 33                MOVE.B   #5,D0              *pause for user to hit enter
0000101A  4E4F                      34                TRAP     #15
0000101C  43F9 0000416C             35                LEA      nl,A1              *make an new line
00001022  103C 000E                 36                MOVE.B   #14,D0
00001026  4E4F                      37                TRAP     #15
00001028  49F9 00004020             38                LEA      hex_1,A4           *pointer to hex_1 table in A4
0000102E  227C 00000000             39                MOVEA.L  #0,A1              *clearing variables
00001034  23FC 00000000 0000413E    40                MOVE.L   #0,SIZECODE
0000103E  23FC 00000000 00004158    41                MOVE.L   #0,INST_NAME_EXT
00001048                            42                *CLR.L    A0
00001048  4280                      43                CLR.L    D0
0000104A  4281                      44                CLR.L    D1
0000104C  4282                      45                CLR.L    D2
0000104E  4283                      46                CLR.L    D3
00001050  4284                      47                CLR.L    D4
00001052  4285                      48                CLR.L    D5
00001054  4286                      49                CLR.L    D6
00001056  4287                      50                CLR.L    D7
00001058                            51                *MOVE.W   #16,D0            *put 16 bits in D0 for the LSL instruction thats in 2 lines
00001058  3215                      52                MOVE.W   (A5),D1            *move the instruction thats pointed to by starting address
0000105A  2641                      53                MOVE.L   D1,A3              *and copy it to A3
0000105C  4841                      54                SWAP     D1
0000105E                            55                *MOVE.W   D1,D2              *and copy it to D2
0000105E                            56                *LSL.L    D0,D1              *shift the word to the left
0000105E  E999                      57                ROL.L    #4,D1              *isolate the first hex digit
00001060                            58               
00001060  B21C                      59  check_first   CMP.B   (A4)+,D1            *compare with the next value in the hex table
00001062  6700 0038                 60                BEQ     match_found         *theres a match with the value in the table
00001066  524C                      61                ADDA    #1,A4               *increment the pointer to the table
00001068  0C14 00FF                 62                CMP.B   #$FF,(A4)           *have we reached the end of the hex table?
0000106C  6700 0004                 63                BEQ     inv_handler         * yes-no matches (so output DATA)
00001070  60EE                      64                BRA     check_first         *keep searching through the table for a match           
00001072                            65       
00001072                            66  *-----------------------------------------------------------------------------
00001072                            67  * inv_handler
00001072                            68  * handles unsupported instruction names
00001072                            69  * prints DATA for instruction name 
00001072                            70                  
00001072  23F9 0000410C 00004150    71  inv_handler   MOVE.L  DAT,INST_NAME
0000107C  23F9 0000411C 00004158    72                MOVE.L  A,INST_NAME_EXT
00001086                            73                *MOVE.B  #12,D5
00001086                            74                *ROL.L   D5,D1             *line up rest of the instruction
00001086  4EB9 00001DA6             75                JSR     disp_instr
0000108C                            76                *MOVE.L  D1,A0
0000108C  204B                      77                MOVE.L  A3,A0
0000108E  4EB9 00001DFA             78                JSR     hex_2_ascii       *convert/display the unsupported opcode
00001094  DAFC 0002                 79                ADDA    #word_len,A5
00001098  6000 FF76                 80                BRA     prep
0000109C                            81                
0000109C                            82  * /inv_handler
0000109C                            83  *-----------------------------------------------------------------------------
0000109C                            84  
0000109C                            85  **below functions handle instructions that are supported in this program**
0000109C                            86  
0000109C  0C14 0001                 87  match_found   CMP.B   #1,(A4)             *check if the mapping is ambiguous
000010A0  6700 0006                 88                BEQ     inst_parse          * it is- get the next hex digit
000010A4  6000 0208                 89                BRA     get_data            * its not-- just branch straight to the corresponding function
000010A8                            90                            
000010A8  B23C 0001                 91  inst_parse    CMP.B   #1,D1            *based on the first digit, decide how to decode next value.
000010AC  6700 0044                 92                BEQ     _1_handler
000010B0  B23C 0003                 93                CMP.B   #3,D1
000010B4  6700 00A8                 94                BEQ     _3_handler
000010B8  B23C 0002                 95                CMP.B   #2,D1
000010BC  6700 00CA                 96                BEQ     _2_handler
000010C0  B23C 0004                 97                CMP.B   #4,D1
000010C4  6700 00F0                 98                BEQ     _4_handler
000010C8  B23C 000D                 99                CMP.B   #13,D1
000010CC  6700 0118                100                BEQ     _13_handler
000010D0  B23C 0000                101                CMP.B   #0,D1
000010D4  6700 0126                102                BEQ     _0_handler
000010D8  B23C 000B                103                CMP.B   #11,D1
000010DC  6700 0164                104                BEQ     _11_handler
000010E0  B23C 0008                105                CMP.B   #8,D1
000010E4  6700 018A                106                BEQ     _8_handler
000010E8  B23C 0005                107                CMP.B   #5,D1
000010EC  6700 01B0                108                BEQ     _5_handler
000010F0  6080                     109                BRA     inv_handler
000010F2                           110  
000010F2                           111  *The following functions determine where to go if the first hex value is shared between instructions             
000010F2                           112  *---------------           
000010F2  4201                     113  _1_handler    CLR.B   D1
000010F4  23F9 0000403C 00004150   114                MOVE.L  MOV,INST_NAME
000010FE  23F9 00004132 0000413E   115                MOVE.L  SIZEB,SIZECODE
00001108  14BC 0000                116                MOVE.B  #0,(A2)        *flag data as byte
0000110C  E799                     117                ROL.L   #3,D1          *isolate dest. An or Dn bits (t.b.d. if MOVE or MOVEA)
0000110E  1401                     118                MOVE.B  D1,D2          *and move them to D2
00001110  4201                     119                CLR.B   D1
00001112  E799                     120                ROL.L   #3,D1          *isolate dest. mode bits in D1.B
00001114  B23C 0001                121                CMP.B   #1,D1          *is mode == 001?
00001118  6700 0010                122                BEQ     movea_handler * yes- its movea
0000111C                           123                
0000111C  23F9 00004128 00004158   124  move_handler MOVE.L  E,INST_NAME_EXT
00001126  6000 000C                125               BRA     move_ea
0000112A                           126                    
0000112A  23F9 0000412E 00004158   127  movea_handler MOVE.L EA,INST_NAME_EXT     
00001134                           128  
00001134  1801                     129  move_ea       MOVE.B D1,D4         *save dest mode bits to D4
00001136  4201                     130                CLR.B  D1
00001138  E799                     131                ROL.L  #3,D1
0000113A  2601                     132                MOVE.L D1,D3         *save source mode/reg bits in D3
0000113C  4EB9 00001DA6            133                JSR    disp_instr    *print MOVEA.(X) or MOVE.(X)
00001142  4EB9 00001AA0            134                JSR    EA_SRC_beg    *print source information
00001148                           135                
00001148  E69A                     136                ROR.L  #3,D2         *roll dest register bits to left fringe
0000114A  1404                     137                MOVE.B D4,D2         *move dest mode bits to right fringe
0000114C  2602                     138                MOVE.L D2,D3         *move these same bits to D3
0000114E                           139                
0000114E                           140                *MOVE.B #29,D0        *prep D0 as index for number of shift
0000114E                           141                *LSL.L  D0,D2         *shift An or Dn bits to the left fringe
0000114E                           142                *MOVE.B D4,D2         *save mode bits to the right fringe
0000114E                           143                *MOVE.L D2,D3         *move these mode/reg bits to D3 for next function
0000114E  4EB9 00001E4C            144                JSR    print_comma
00001154  4EB9 00001AA4            145                JSR    EA_SRC        *prints destination mode/register
0000115A  6000 FEB4                146                BRA    prep
0000115E                           147  
0000115E                           148  *--------------- 
0000115E                           149  *---------------
0000115E  4201                     150  _3_handler    CLR.B   D1
00001160  23F9 0000403C 00004150   151                MOVE.L  MOV,INST_NAME
0000116A  23F9 00004136 0000413E   152                MOVE.L  SIZEW,SIZECODE
00001174  14BC 0001                153                MOVE.B  #1,(A2)        *flag data as word
00001178  E799                     154                ROL.L   #3,D1          *isolate dest. An or Dn bits (t.b.d. if MOVE or MOVEA)
0000117A  1401                     155                MOVE.B  D1,D2          *and move them to D2
0000117C  4201                     156                CLR.B   D1
0000117E  E799                     157                ROL.L   #3,D1          *isolate dest. mode bits in D1.B
00001180  B23C 0001                158                CMP.B   #1,D1          *is mode == 001?
00001184  67A4                     159                BEQ     movea_handler * yes- its movea (function is subset of _1_handler)
00001186  6094                     160                BRA     move_handler  * no- its move (function is subset of _1_handler)
00001188                           161                
00001188                           162  *--------------- 
00001188                           163  *--------------- 
00001188  4201                     164  _2_handler    CLR.B   D1
0000118A  23F9 0000403C 00004150   165                MOVE.L  MOV,INST_NAME
00001194  23F9 0000413A 0000413E   166                MOVE.L  SIZEL,SIZECODE
0000119E  14BC 0002                167                MOVE.B  #2,(A2)        *flag data as long
000011A2  E799                     168                ROL.L   #3,D1          *isolate dest. An or Dn bits (t.b.d. if MOVE or MOVEA)
000011A4  1401                     169                MOVE.B  D1,D2          *and move them to D2
000011A6  4201                     170                CLR.B   D1
000011A8  E799                     171                ROL.L   #3,D1          *isolate dest. mode bits in D1.B
000011AA  B23C 0001                172                CMP.B   #1,D1          *is mode == 001?
000011AE  6700 FF7A                173                BEQ     movea_handler * yes- its movea (function is subset of _1_handler)
000011B2  6000 FF68                174                BRA     move_handler  * no- its move (function is subset of _1_handler)
000011B6                           175  
000011B6                           176  
000011B6                           177  *--------------- 
000011B6                           178  *--------------- 
000011B6  B27C 4E71                179  _4_handler    CMP.W   #$4E71,D1        *is it nop
000011BA  6700 011A                180                BEQ     nop_handler      * its nop
000011BE  B27C 4E75                181                CMP.W   #$4E75,D1        *is it rts
000011C2  6700 08C6                182                BEQ     rts_handler     * its rts
000011C6  4201                     183                CLR.B   D1               *get byte space ready for next digit
000011C8  E999                     184                ROL.L   #4,D1            *get the next digit
000011CA  B23C 000E                185                CMP.B   #$E,D1           *is the next digit E (but we know its not rts,nop)
000011CE  6700 0832                186                BEQ     jsr_handler      * its jsr
000011D2  B23C 0004                187                CMP.B   #$4,D1           *is the next digit 4
000011D6  6700 0560                188                BEQ     neg_handler      * its neg
000011DA                           189                                         *now its either lea,movem
000011DA  2401                     190                MOVE.L  D1,D2            *make a copy
000011DC  E20A                     191                LSR.B   #1,D2            *lea and movem differentiated by current MSB        
000011DE  6500 07EE                192                BCS     lea_handler      * carry set- lea
000011E2  6000 0846                193                BRA     movem_handler    * carry not set-movem
000011E6                           194  
000011E6                           195  *--------------- 
000011E6                           196  *--------------- 
000011E6  4201                     197  _13_handler     CLR.B   D1
000011E8  E999                     198                  ROL.L   #4,D1
000011EA  2401                     199                  MOVE.L  D1,D2          *make a copy
000011EC  4202                     200                  CLR.B   D2             *clear byte space for next roll
000011EE  E59A                     201                  ROL.L   #2,D2          *get size bits
000011F0  B43C 0003                202                  CMP.B   #3,D2          *are size bits 11?
000011F4  6700 00F6                203                  BEQ     adda_handler
000011F8  6000 0236                204                  BRA     add_handler
000011FC                           205  
000011FC                           206  *--------------- 
000011FC                           207  *--------------- 
000011FC  4201                     208  _0_handler      CLR.B D1
000011FE  E999                     209                  ROL.L #4,D1         *the next 4 bits will determine the instruction exactly
00001200  B23C 0000                210                  CMP.B #0,D1
00001204  6700 0474                211                  BEQ   ori_handler
00001208  B23C 0004                212                  CMP.B #4,D1
0000120C  6700 04F8                213                  BEQ   subi_handler
00001210  B23C 000A                214                  CMP.B #$A,D1
00001214  6700 04BE                215                  BEQ   eori_handler
00001218  B23C 0008                216                  CMP.B #8,D1
0000121C  6700 0400                217                  BEQ   bclr_static
00001220  B23C 000C                218                  CMP.B #$C,D1
00001224  6700 0372                219                  BEQ   cmpi_handler
00001228  B23C 0006                220                  CMP.B #6,D1
0000122C  6700 0474                221                  BEQ   addi_handler
00001230                           222                                      *at this point its BCLR or its unsupported
00001230  2401                     223                  MOVE.L D1,D2        *make a copy
00001232  4202                     224                  CLR.B  D2
00001234  E59A                     225                  ROL.L  #2,D2        *get next 2 hardcoded bits
00001236  B43C 0002                226                  CMP.B  #2,D2        *BCLR bits defined as 10
0000123A  6700 040C                227                  BEQ    bclr_dynamic  *BCLR with a Dn (dynamic)
0000123E  6000 FE32                228                  BRA    inv_handler   *unsupported instruction
00001242                           229  
00001242                           230  *--------------- 
00001242                           231  *--------------- 
00001242  4201                     232  _11_handler     CLR.B   D1          
00001244  E999                     233                  ROL.L   #4,D1      *get next hex digit
00001246  1401                     234                  MOVE.B  D1,D2      *make a temp copy
00001248  E20A                     235                  LSR.B   #1,D2      * eor and cmp can be differentiated by lsb in 2nd digit. check carry
0000124A  6500 0006                236                  BCS     _11_check  *check if its eor,cpma(long), or cmpm(unsupported)
0000124E  6000 022C                237                  BRA     cmp_handler   *its cmp or cmpa
00001252  2401                     238  _11_check       MOVE.L  D1,D2       *make a copy
00001254  4202                     239                  CLR.B   D2
00001256  E59A                     240                  ROL.L   #2,D2
00001258  B43C 0002                241                  CMP.B   #2,D2
0000125C  6700 0100                242                  BEQ     cmpa_handler    *its cmpa (long)
00001260  4202                     243                  CLR.B   D2              *down to eor or cmpm
00001262  E79A                     244                  ROL.L   #3,D2           *get EA mode
00001264  B43C 0001                245                  CMP.B   #1,D2
00001268  6700 FE08                246                  BEQ     inv_handler     *cmpm
0000126C  6000 01FC                247                  BRA     eor_handler     *eor
00001270                           248  
00001270                           249  *---------------
00001270                           250  *---------------
00001270  4201                     251  _8_handler      CLR.B   D1
00001272  E999                     252                  ROL.L   #4,D1
00001274  2401                     253                  MOVE.L  D1,D2
00001276  E20A                     254                  LSR.B   #1,D2
00001278  6500 0012                255                  BCS     _8_check              
0000127C  4202                     256                  CLR.B   D2                  *carry not set- OR or DIVU
0000127E  E59A                     257                  ROL.L   #2,D2
00001280  B43C 0003                258                  CMP.B   #3,D2
00001284  6700 FDEC                259                  BEQ     inv_handler         *DIVU
00001288  6000 00E0                260                  BRA     or_handler
0000128C                           261                  
0000128C  4202                     262  _8_check        CLR.B   D2                  *its OR, DIVS, or SBCD
0000128E  E59A                     263                  ROL.L   #2,D2
00001290  B43C 0003                264                  CMP.B   #3,D2
00001294  6700 01F8                265                  BEQ     divsw_handler       *between or and divs.w, only divs.w can have a size 11
00001298  4202                     266                  CLR.B   D2
0000129A  6000 00CE                267                  BRA     or_handler
0000129E                           268                      
0000129E                           269  *---------------
0000129E                           270  *--------------- 
0000129E  4201                     271  _5_handler      CLR.B   D1
000012A0  E999                     272                  ROL.L   #4,D1
000012A2  1401                     273                  MOVE.B  D1,D2               *D2 now holds the immediate data
000012A4  E20A                     274                  LSR.B   #1,D2               *check if carry is set-- this will determine branch
000012A6  6500 0238                275                  BCS     subq_handler
000012AA  6000 02DE                276                  BRA     addq_handler
000012AE                           277                  
000012AE                           278  *---------------
000012AE                           279  *--------------- 
000012AE                           280  
000012AE                           281  *we can go directly to the function since the first hex val maps directly to an instruction
000012AE  B23C 0006                282  get_data      CMP.B   #6,D1
000012B2  6700 04E2                283                BEQ     bcc_handler
000012B6  B23C 000E                284                CMP.B   #$E,D1
000012BA  6700 05AA                285                BEQ     _shift_roll_handler
000012BE  B23C 0009                286                CMP.B   #9,D1
000012C2  6700 0182                287                BEQ     sub_handler
000012C6  B23C 0005                288                CMP.B   #5,D1
000012CA  6700 0214                289                BEQ     subq_handler
000012CE  B23C 000C                290                CMP.B   #$C,D1
000012D2  6700 01F4                291                BEQ     muls_handler
000012D6                           292  *----------------------------------------------------------------------------
000012D6                           293  *----------------------------------------------------------------------------              
000012D6                           294  *----------------------------------------------------------------------------
000012D6                           295  *nop_handler
000012D6                           296  *handles 'NOP'
000012D6                           297  
000012D6  23F9 00004064 00004150   298  nop_handler   MOVE.L  NOP,INST_NAME 
000012E0  544D                     299                ADDA    #2,A5         *nop took up a word- set A5 to the next instruction
000012E2  4EB9 00001DA6            300                JSR     disp_instr
000012E8  6000 FD26                301                BRA     prep
000012EC                           302  
000012EC                           303  * /nop_handler
000012EC                           304  *----------------------------------------------------------------------------
000012EC                           305  
000012EC                           306  
000012EC                           307  *----------------------------------------------------------------------------
000012EC                           308  *adda_handler
000012EC                           309  *handles 'ADDA'
000012EC                           310  
000012EC  23F9 0000406C 00004150   311  adda_handler       MOVE.L ADD,INST_NAME  *we know its valid instr ADDA
000012F6  33F9 0000411C 00004158   312  adda_beg           MOVE.W A,INST_NAME_EXT
00001300  E209                     313                     LSR.B  #1,D1                *send the size bit to carry
00001302  6500 0018                314                     BCS    adda_long_handler    *carry is set->ADDA.W
00001306  6000 0002                315                     BRA    adda_word_handler    *carry not set->ADDA.L
0000130A                           316                     
0000130A  23F9 00004136 0000413E   317  adda_word_handler  MOVE.L SIZEW,SIZECODE
00001314  14BC 0001                318                     MOVE.B #1,(A2)
00001318  6000 0010                319                     BRA    adda_save_data
0000131C                           320                     
0000131C  23F9 0000413A 0000413E   321  adda_long_handler  MOVE.L SIZEL,SIZECODE
00001326  14BC 0002                322                     MOVE.B #2,(A2)
0000132A                           323                              
0000132A  4EB9 00001DA6            324  adda_save_data     JSR    disp_instr
00001330  1A01                     325                     MOVE.B D1,D5             *move the 3 An bits to D5 temporarily
00001332  E599                     326                     ROL.L  #2,D1             *get hardcoded size bits
00001334  4201                     327                     CLR.B  D1                *and clear the byte space
00001336  E799                     328                     ROL.L  #3,D1
00001338  2601                     329                     MOVE.L D1,D3             *send EA bits to D3
0000133A  4EB9 00001AA0            330                     JSR    EA_SRC_beg
00001340  4EB9 00001E4C            331                     JSR    print_comma
00001346  C745                     332                     EXG    D3,D5             *send An bits to D3 for function call
00001348  4EB9 00001B7A            333                     JSR    PRINT_INNER_An
0000134E  6000 FCC0                334                     BRA    prep                     
00001352                           335  
00001352                           336  * /adda_handler
00001352                           337  *----------------------------------------------------------------------------
00001352                           338  
00001352                           339  
00001352                           340  *-----------------------------------------------------------------------------
00001352                           341  * suba_handler
00001352                           342  * handles 'SUBA'
00001352                           343  
00001352                           344  *uses adda_handler due to similar bit layout
00001352                           345  
00001352  23F9 000040EC 00004150   346  suba_handler       MOVE.L   SUB,INST_NAME
0000135C  6098                     347                     BRA      adda_beg
0000135E                           348  
0000135E                           349  * /suba_handler
0000135E                           350  *-----------------------------------------------------------------------------
0000135E                           351  
0000135E                           352  
0000135E                           353  *-----------------------------------------------------------------------------
0000135E                           354  * cmpa_handler
0000135E                           355  * handles 'CMPA'
0000135E                           356  
0000135E                           357  *uses adda_handler due to similar bit layout
0000135E                           358  
0000135E  23F9 0000408C 00004150   359  cmpa_handler       MOVE.L   CMP,INST_NAME
00001368  608C                     360                     BRA      adda_beg
0000136A                           361  
0000136A                           362  * /cmpa_handler
0000136A                           363  *-----------------------------------------------------------------------------
0000136A                           364  
0000136A                           365  
0000136A                           366  *-----------------------------------------------------------------------------
0000136A                           367  *or_handler
0000136A                           368  *handles 'OR'
0000136A                           369  
0000136A                           370  *D7 holds the direction flag
0000136A                           371  *D5 holds source/destination bits
0000136A                           372  *D4 holds the 2 size bits
0000136A                           373  *D3 holds the parameters used for jumps to EA handlers
0000136A                           374  
0000136A                           375  *Dn_left means the Dn is the dest
0000136A                           376  *Dn_right means the Dn is the source
0000136A                           377  
0000136A  E59A                     378  or_handler     ROL.L    #2,D2
0000136C  B43C 0000                379                 CMP.B    #0,D2
00001370  6700 FD00                380                 BEQ      inv_handler    *SBCD
00001374  23F9 00004104 00004150   381                 MOVE.L   OR,INST_NAME
0000137E  E209                     382                 LSR.B    #1,D1          *shift the direction bit to carry-- D1 now also holds the data register of the operation
00001380  1A01                     383                 MOVE.B   D1,D5          *move source/destination (undertermined) Dn bits to D5
00001382  6500 0006                384                 BCS      or_Dn_right    * <ea> OR Dn
00001386  6000 000C                385                 BRA      or_Dn_left     * Dn OR <ea>
0000138A                           386                 
0000138A  4201                     387  or_Dn_right    CLR.B    D1
0000138C  E599                     388                 ROL.L    #2,D1
0000138E  1801                     389                 MOVE.B   D1,D4          *D4 holds the size of the operation
00001390  6000 000C                390                 BRA      or_size
00001394                           391  
00001394  1E3C 0001                392  or_Dn_left     MOVE.B   #1,D7          *flag operation as Dn_left
00001398  4201                     393                 CLR.B    D1
0000139A  E599                     394                 ROL.L    #2,D1
0000139C  1801                     395                 MOVE.B   D1,D4          *D4 holds the size of the operation
0000139E  B83C 0000                396  or_size        CMP.B    #0,D4
000013A2  6700 0012                397                 BEQ      or_byte
000013A6  B83C 0001                398                 CMP.B    #1,D4
000013AA  6700 001C                399                 BEQ      or_word
000013AE  B83C 0002                400                 CMP.B    #2,D4
000013B2  6700 0026                401                 BEQ      or_long
000013B6                           402                 
000013B6  23F9 00004132 0000413E   403  or_byte        MOVE.L   SIZEB,SIZECODE
000013C0  14BC 0000                404                 MOVE.B   #0,(A2)        *flag data as byte sized
000013C4  6000 0022                405                 BRA      or_ea
000013C8                           406  
000013C8  23F9 00004136 0000413E   407  or_word        MOVE.L   SIZEW,SIZECODE
000013D2  14BC 0001                408                 MOVE.B   #1,(A2)        *flag data as word sized
000013D6  6000 0010                409                 BRA      or_ea
000013DA                           410  
000013DA  23F9 0000413A 0000413E   411  or_long        MOVE.L   SIZEL,SIZECODE
000013E4  14BC 0002                412                 MOVE.B   #2,(A2)        *flag data as long sized
000013E8                           413  
000013E8  4EB9 00001DA6            414  or_ea          JSR      disp_instr
000013EE  4201                     415                 CLR.B    D1
000013F0  E799                     416                 ROL.L    #3,D1          *D1 holds the EA bits         
000013F2  2601                     417                 MOVE.L   D1,D3          *move EA source bits to D3
000013F4  BE3C 0001                418                 CMP.B    #1,D7
000013F8  6700 001E                419                 BEQ      or_left_print
000013FC  2C03                     420                 MOVE.L   D3,D6          *temp store D3 bits in D6 for next function call
000013FE  2605                     421                 MOVE.L   D5,D3
00001400  4EB9 00001B16            422                 JSR      DR_CMP         *print Dn bits
00001406  4EB9 00001E4C            423                 JSR      print_comma
0000140C  2606                     424                 MOVE.L   D6,D3
0000140E  4EB9 00001AA0            425                 JSR      EA_SRC_beg
00001414  6000 FBFA                426                 BRA      prep
00001418                           427                 
00001418  4EB9 00001AA0            428  or_left_print  JSR      EA_SRC_beg     *print EA bits
0000141E  2605                     429                 MOVE.L   D5,D3          *get D5 bits in D3 for function call
00001420  4EB9 00001E4C            430                 JSR      print_comma
00001426  4EB9 00001B16            431                 JSR      DR_CMP         *print Dn bits
0000142C  6000 FBE2                432                 BRA      prep
00001430                           433  
00001430                           434  * /or_handler
00001430                           435  *-----------------------------------------------------------------------------
00001430                           436  
00001430                           437  
00001430                           438  *----------------------------------------------------------------------------
00001430                           439  *add_handler
00001430                           440  *handles 'ADD'
00001430                           441  * heavily uses the or_handler function as the instruction formats are equivalent after the first nibble
00001430                           442  
00001430  23F9 0000406C 00004150   443  add_handler    MOVE.L  ADD,INST_NAME
0000143A  E209                     444                 LSR.B   #1,D1
0000143C  1A01                     445                 MOVE.B  D1,D5        *isolate direction bits
0000143E  6500 FF4A                446                 BCS     or_Dn_right  *<ea> + Dn -> <ea>
00001442  6000 FF50                447                 BRA     or_Dn_left   *Dn + <ea> -> Dn
00001446                           448                 
00001446                           449  * /add_handler
00001446                           450  *----------------------------------------------------------------------------
00001446                           451  
00001446                           452  
00001446                           453  *-----------------------------------------------------------------------------
00001446                           454  *sub_handler
00001446                           455  * handles 'SUB'
00001446                           456  
00001446  23F9 000040EC 00004150   457  sub_handler         MOVE.L  SUB,INST_NAME
00001450  4201                     458                      CLR.B   D1
00001452  E999                     459                      ROL.L   #4,D1
00001454  2401                     460                      MOVE.L  D1,D2         *make a copy
00001456  4242                     461                      CLR     D2
00001458  E59A                     462                      ROL.L   #2,D2
0000145A  6700 FEF6                463                      BEQ     suba_handler  *its suba (hardcoded size bits)
0000145E  E209                     464                      LSR.B   #1,D1         *determine direction of sub
00001460  1A01                     465                      MOVE.B  D1,D5         *move Dn and direction bits to D5
00001462  6500 FF26                466                      BCS     or_Dn_right   * <ea> SUB Dn -> <ea>
00001466  6000 FF2C                467                      BRA     or_Dn_left    * Dn SUB <ea> -> Dn            
0000146A                           468  
0000146A                           469  * /sub_handler
0000146A                           470  *-----------------------------------------------------------------------------
0000146A                           471  
0000146A                           472  *-----------------------------------------------------------------------------
0000146A                           473   * eor_handler  
0000146A                           474   * handles 'EOR'
0000146A                           475  
0000146A  23F9 00004084 00004150   476  eor_handler         MOVE.L   EOR,INST_NAME
00001474  E209                     477                      LSR.B    #1,D1           *get rid of direction bit--we know its 1
00001476  1A01                     478                      MOVE.B   D1,D5           *copy data register number in d1 to d5
00001478  6000 FF10                479                      BRA      or_Dn_right
0000147C                           480                      
0000147C                           481  * /eor_handler
0000147C                           482  *-----------------------------------------------------------------------------
0000147C                           483  
0000147C                           484  
0000147C                           485  *-----------------------------------------------------------------------------
0000147C                           486  * cmp_handler
0000147C                           487  * handles 'CMP'
0000147C                           488  
0000147C  23F9 0000408C 00004150   489  cmp_handler         MOVE.L   CMP,INST_NAME
00001486  E209                     490                      LSR.B    #1,D1        *get rid of hardcoded 0
00001488  1A01                     491                      MOVE.B   D1,D5        *save Dn bits to D5
0000148A  6000 FF08                492                      BRA      or_Dn_left
0000148E                           493  
0000148E                           494  * /cmp_handler
0000148E                           495  *-----------------------------------------------------------------------------
0000148E                           496  
0000148E                           497  
0000148E                           498  *-----------------------------------------------------------------------------
0000148E                           499  *divsw_handler
0000148E                           500  *handles 'DIVS'(.W)
0000148E                           501  * .W is implicit
0000148E                           502  
0000148E  23F9 000040FC 00004150   503  divsw_handler   MOVE.L DIV,INST_NAME
00001498  33F9 00004126 00004158   504                  MOVE.W S,INST_NAME_EXT
000014A2  E209                     505  divsw_beg       LSR.B  #1,D1        *get rid of hardcoded bit
000014A4  4282                     506                  CLR.L  D2           *clear space in D2
000014A6  1401                     507                  MOVE.B D1,D2        *save Dn operation register to D2
000014A8  2602                     508                  MOVE.L D2,D3        *get them into D3 for next function
000014AA  4EB9 00001B16            509                  JSR    DR_CMP       *print the data register
000014B0  4EB9 00001E4C            510                  JSR    print_comma
000014B6  4201                     511                  CLR.B  D1
000014B8  E589                     512                  LSL.L  #2,D1        *Shift out size bits--we already know its a word
000014BA  E799                     513                  ROL.L  #3,D1        *D1 now holds the EA bits
000014BC  2601                     514                  MOVE.L D1,D3        *and move them to D3
000014BE  4EB9 00001AA0            515                  JSR    EA_SRC_beg
000014C4  6000 FB4A                516                  BRA    prep
000014C8                           517  
000014C8                           518  * /divsw_handler
000014C8                           519  *-----------------------------------------------------------------------------
000014C8                           520  
000014C8                           521  
000014C8                           522  *-----------------------------------------------------------------------------
000014C8                           523  *muls_handler
000014C8                           524  * handles 'MULS'
000014C8                           525  
000014C8                           526  *uses divsw function as layout is similar after first 4 bits
000014C8                           527  
000014C8  23F9 000040F4 00004150   528  muls_handler      MOVE.L  MUL,INST_NAME
000014D2  23F9 00004126 00004158   529                    MOVE.L  S,INST_NAME_EXT
000014DC  4EB8 14A2                530                    JSR     divsw_beg
000014E0                           531  
000014E0                           532  */muls_handler
000014E0                           533  *-----------------------------------------------------------------------------
000014E0                           534  
000014E0                           535  
000014E0                           536  *-----------------------------------------------------------------------------
000014E0                           537  *subq_handler
000014E0                           538  * handles 'SUBQ' (data [1,8])
000014E0                           539  
000014E0  23F9 000040EC 00004150   540  subq_handler       MOVE.L  SUB,INST_NAME
000014EA  23F9 00004124 00004158   541  subq_det           MOVE.L  Q,INST_NAME_EXT
000014F4  4201                     542                     CLR.B   D1
000014F6  E599                     543                     ROL.L   #2,D1            *isolate size bits
000014F8  B23C 0000                544                     CMP.B   #0,D1
000014FC  6700 0016                545                     BEQ     subq_byte
00001500  B23C 0001                546                     CMP.B   #1,D1
00001504  6700 0020                547                     BEQ     subq_word
00001508  B23C 0002                548                     CMP.B   #2,D1
0000150C  6700 002A                549                     BEQ     subq_long
00001510  6000 FB60                550                     BRA     inv_handler     *size > 2 means it's an unsupported opcode
00001514  23F9 00004132 0000413E   551  subq_byte          MOVE.L  SIZEB,SIZECODE
0000151E  14BC 0000                552                     MOVE.B  #0,(A2)
00001522  6000 0028                553                     BRA     subq_ea
00001526  23F9 00004136 0000413E   554  subq_word          MOVE.L  SIZEW,SIZECODE
00001530  14BC 0001                555                     MOVE.B  #1,(A2)            *flag it as a word
00001534  6000 0016                556                     BRA     subq_ea
00001538  23F9 0000413A 0000413E   557  subq_long          MOVE.L  SIZEL,SIZECODE
00001542  24BC 00000002            558                     MOVE.L  #2,(A2)            *flag it as a long
00001548  6000 0002                559                     BRA     subq_ea 
0000154C                           560  
0000154C  4201                     561  subq_ea            CLR.B   D1               *prep byte space
0000154E  E799                     562                     ROL.L   #3,D1            *get EA bits
00001550  2601                     563                     MOVE.L  D1,D3            *put them in D3
00001552  2202                     564                     MOVE.L  D2,D1            *move immediate data bits back to D1 for display
00001554  4EB9 00001DA6            565                     JSR     disp_instr
0000155A  B23C 0000                566                     CMP.B   #0,D1
0000155E  6700 0024                567                     BEQ     case_quick8     *8 (base 0) is represented as 000 in data field.
00001562  43F9 0000415E            568  q_prints           LEA     imm_sign, A1    *load and print '#' character
00001568  103C 000E                569                     MOVE.B  #14,D0
0000156C  4E4F                     570                     TRAP    #15
0000156E  103C 0003                571                     MOVE.B  #3,D0
00001572  4E4F                     572                     TRAP    #15              *display immediate [1-8] data 
00001574  4EB9 00001E4C            573                     JSR     print_comma               
0000157A  4EB9 00001AA0            574                     JSR     EA_SRC_beg
00001580  6000 FA8E                575                     BRA     prep
00001584                           576             
00001584  123C 0008                577  case_quick8        MOVE.B  #8,D1           *move the number 8 to D1, replacing 0  
00001588  60D8                     578                     BRA     q_prints     
0000158A                           579  
0000158A                           580  * /subq_handler
0000158A                           581  *-----------------------------------------------------------------------------
0000158A                           582  
0000158A                           583  
0000158A                           584  *-----------------------------------------------------------------------------
0000158A                           585  *addq_handler
0000158A                           586  *handles 'ADDQ', or adds with data [1,8]
0000158A                           587  
0000158A                           588  *uses subq_handler due to similar bit layout
0000158A                           589  
0000158A  23F9 0000406C 00004150   590  addq_handler      MOVE.L  ADD,INST_NAME
00001594  6000 FF54                591                    BRA     subq_det          *SUBQ and ADDQ equivalent instruction layout hereafter   
00001598                           592  
00001598                           593  * /addq_handler
00001598                           594  *-----------------------------------------------------------------------------
00001598                           595  
00001598                           596  
00001598                           597  *-----------------------------------------------------------------------------
00001598                           598  * cmpi_handler
00001598                           599  * handles cmpi
00001598                           600  
00001598                           601  *D1 holds instruction info, then EA info (mode & reg)
00001598                           602  *D2: holds the size of the operation (b,w,l)
00001598                           603  
00001598  23F9 0000408C 00004150   604  cmpi_handler       MOVE.L   CMP,INST_NAME
000015A2  13F9 0000411E 00004158   605                     MOVE.B   I,INST_NAME_EXT
000015AC  4201                     606                     CLR.B    D1
000015AE  E599                     607                     ROL.L    #2,D1     *isolate the size bits
000015B0  1801                     608                     MOVE.B   D1,D4     *move size bits to D4
000015B2  B83C 0000                609                     CMP.B    #0,D4
000015B6  6700 0012                610                     BEQ      cmpi_byte
000015BA  B83C 0001                611                     CMP.B    #1,D4
000015BE  6700 001C                612                     BEQ      cmpi_word
000015C2  B83C 0002                613                     CMP.B    #2,D4
000015C6  6700 0026                614                     BEQ      cmpi_long
000015CA  23F9 00004132 0000413E   615  cmpi_byte          MOVE.L   SIZEB,SIZECODE
000015D4  14BC 0000                616                     MOVE.B   #0,(A2)
000015D8  6000 0022                617                     BRA      cmpi_ret
000015DC  23F9 00004136 0000413E   618  cmpi_word          MOVE.L   SIZEW,SIZECODE
000015E6  14BC 0001                619                     MOVE.B   #1,(A2)
000015EA  6000 0010                620                     BRA      cmpi_ret
000015EE  23F9 0000413A 0000413E   621  cmpi_long          MOVE.L   SIZEL,SIZECODE   
000015F8  14BC 0002                622                     MOVE.B   #2,(A2)            
000015FC  4EB9 00001DA6            623  cmpi_ret           JSR      disp_instr
00001602  4201                     624                     CLR.B    D1
00001604  4EB9 00001C4A            625                     JSR      DATA_MODE           *determine and print the immediate data based on size
0000160A  E799                     626                     ROL.L    #3,D1               *isolate EA info in D1
0000160C  2601                     627                     MOVE.L   D1,D3
0000160E  4EB9 00001E4C            628                     JSR      print_comma
00001614  4EB9 00001AA0            629                     JSR      EA_SRC_beg
0000161A  6000 F9F4                630                     BRA      prep
0000161E                           631                     
0000161E                           632  * /cmpi_handler
0000161E                           633  *-----------------------------------------------------------------------------
0000161E                           634  
0000161E                           635  
0000161E                           636  *-----------------------------------------------------------------------------
0000161E                           637  *bclr_static and bclr_dynamic
0000161E                           638  *(bclr_handler)
0000161E                           639  *handles 'BCLR' with a data register or its static counterpart (no register)
0000161E                           640  
0000161E  E599                     641  bclr_static       ROL.L     #2,D1          *get 2 more bits-- are we sure its BCLR?
00001620  B23C 0022                642                    CMP.B     #34,D1         *static BCLR bits 11 to 6
00001624  6600 FA4C                643                    BNE       inv_handler    *unsupported opcode
00001628  23F9 00004074 00004150   644                    MOVE.L    BCL,INST_NAME   *we now know its bclr
00001632  23F9 00004120 00004158   645                    MOVE.L    R,INST_NAME_EXT
0000163C  4201                     646                    CLR.B     D1             
0000163E  E799                     647                    ROL.L     #3,D1          *isolate the EA mode and register
00001640  2601                     648                    MOVE.L    D1,D3
00001642  4EB9 00001AA0            649                    JSR       EA_SRC_beg     
00001648                           650  
00001648  E209                     651  bclr_dynamic      LSR.B     #1,D1          *discard hardcoded bit 
0000164A  23F9 00004074 00004150   652                    MOVE.L    BCL,INST_NAME
00001654  23F9 00004120 00004158   653                    MOVE.L    R,INST_NAME_EXT
0000165E  1601                     654                    MOVE.B    D1,D3          *store Dn bits in D3
00001660  4EB9 00001B16            655                    JSR       DR_CMP         *print appropriate data register
00001666  4EB9 00001E4C            656                    JSR       print_comma
0000166C  E799                     657                    ROL.L     #3,D1          *get ea bits
0000166E  2601                     658                    MOVE.L    D1,D3          *put them in D3
00001670  4EB9 00001AA0            659                    JSR       EA_SRC_beg     *print EA info
00001676  6000 F998                660                    BRA       prep
0000167A                           661                   
0000167A                           662  
0000167A                           663  * /bclr_handler
0000167A                           664  *-----------------------------------------------------------------------------
0000167A                           665  
0000167A                           666  
0000167A                           667  *-----------------------------------------------------------------------------
0000167A                           668  *ori_handler
0000167A                           669  *handles 'ORI'
0000167A                           670      
0000167A                           671  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
0000167A                           672  
0000167A  23F9 0000407C 00004150   673  ori_handler       MOVE.L   ORI,INST_NAME
00001684  4201                     674                    CLR.B    D1
00001686  E599                     675                    ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
00001688  1801                     676                    MOVE.B   D1,D4           *move size bits to D2
0000168A  B83C 0000                677                    CMP.B    #0,D4
0000168E  6700 FF3A                678                    BEQ      cmpi_byte
00001692  B83C 0001                679                    CMP.B    #1,D4
00001696  6700 FF44                680                    BEQ      cmpi_word
0000169A  B83C 0002                681                    CMP.B    #2,D4
0000169E  6700 FF4E                682                    BEQ      cmpi_long
000016A2                           683  
000016A2                           684  * /ori_handler
000016A2                           685  *-----------------------------------------------------------------------------
000016A2                           686  
000016A2                           687  *-----------------------------------------------------------------------------
000016A2                           688  * addi_handler
000016A2                           689  * handles 'ADDI'
000016A2                           690  
000016A2                           691  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
000016A2                           692  
000016A2  23F9 0000406C 00004150   693  addi_handler      MOVE.L   ADD,INST_NAME
000016AC  23F9 0000411E 00004158   694                    MOVE.L   I,INST_NAME_EXT
000016B6  4201                     695                    CLR.B    D1
000016B8  E599                     696                    ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
000016BA  1801                     697                    MOVE.B   D1,D4           *move size bits to D2
000016BC  B83C 0000                698                    CMP.B    #0,D4
000016C0  6700 FF08                699                    BEQ      cmpi_byte
000016C4  B83C 0001                700                    CMP.B    #1,D4
000016C8  6700 FF12                701                    BEQ      cmpi_word
000016CC  B83C 0002                702                    CMP.B    #2,D4
000016D0  6700 FF1C                703                    BEQ      cmpi_long
000016D4                           704  
000016D4                           705  * /addi_handler
000016D4                           706  *-----------------------------------------------------------------------------
000016D4                           707  
000016D4                           708  *-----------------------------------------------------------------------------
000016D4                           709  * eori_handler
000016D4                           710  * handles 'EORI'
000016D4                           711  
000016D4                           712  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
000016D4                           713  
000016D4  23F9 00004084 00004150   714  eori_handler      MOVE.L   EOR,INST_NAME
000016DE  23F9 0000411E 00004158   715                    MOVE.L   I,INST_NAME_EXT
000016E8  4201                     716                    CLR.B    D1
000016EA  E599                     717                    ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
000016EC  1801                     718                    MOVE.B   D1,D4           *move size bits to D2
000016EE  B83C 0000                719                    CMP.B    #0,D4
000016F2  6700 FED6                720                    BEQ      cmpi_byte
000016F6  B83C 0001                721                    CMP.B    #1,D4
000016FA  6700 FEE0                722                    BEQ      cmpi_word
000016FE  B83C 0002                723                    CMP.B    #2,D4
00001702  6700 FEEA                724                    BEQ      cmpi_long
00001706                           725  
00001706                           726  
00001706                           727  
00001706                           728  * /eori_handler
00001706                           729  *-----------------------------------------------------------------------------
00001706                           730  
00001706                           731  *-----------------------------------------------------------------------------
00001706                           732  * subi_handler
00001706                           733  * handles 'SUBI'
00001706                           734  
00001706                           735  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
00001706                           736  
00001706  23F9 000040EC 00004150   737  subi_handler     MOVE.L   SUB,INST_NAME
00001710  23F9 0000411E 00004158   738                   MOVE.L   I,INST_NAME_EXT
0000171A  4201                     739                   CLR.B    D1
0000171C  E599                     740                   ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
0000171E  1801                     741                   MOVE.B   D1,D4           *move size bits to D2
00001720  B83C 0000                742                   CMP.B    #0,D4
00001724  6700 FEA4                743                   BEQ      cmpi_byte
00001728  B83C 0001                744                   CMP.B    #1,D4
0000172C  6700 FEAE                745                   BEQ      cmpi_word
00001730  B83C 0002                746                   CMP.B    #2,D4
00001734  6700 FEB8                747                   BEQ      cmpi_long
00001738                           748  
00001738                           749  * /subi_handler
00001738                           750  *-----------------------------------------------------------------------------
00001738                           751  
00001738                           752  
00001738                           753  *-----------------------------------------------------------------------------
00001738                           754  *neg_handler
00001738                           755  *handles neg
00001738                           756  
00001738                           757  *D1: holds opcode
00001738                           758  *D2: holds size of operation (b,w,l)
00001738                           759  
00001738  23F9 0000404C 00004150   760  neg_handler      MOVE.L   NEG,INST_NAME
00001742  4201                     761                   CLR.B    D1   
00001744  E599                     762                   ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
00001746  1801                     763                   MOVE.B   D1,D4           *move size bits to D2
00001748  B83C 0000                764                   CMP.B    #0,D4
0000174C  6700 0012                765                   BEQ      neg_byte
00001750  B83C 0001                766                   CMP.B    #1,D4
00001754  6700 0018                767                   BEQ      neg_word
00001758  B83C 0002                768                   CMP.B    #2,D4
0000175C  6700 001E                769                   BEQ      neg_long
00001760                           770    
00001760  23F9 00004132 0000413E   771  neg_byte         MOVE.L   SIZEB,SIZECODE
0000176A  6000 001A                772                   BRA      neg_ret
0000176E  23F9 00004136 0000413E   773  neg_word         MOVE.L   SIZEW,SIZECODE
00001778  6000 000C                774                   BRA      neg_ret
0000177C  23F9 0000413A 0000413E   775  neg_long         MOVE.L   SIZEL,SIZECODE   
00001786  4EB9 00001DA6            776  neg_ret          JSR      disp_instr
0000178C  E799                     777                   ROL.L    #3,D1           *isolate EA bits
0000178E  2601                     778                   MOVE.L   D1,D3           *move those EA bits to D3
00001790  4EB9 00001AA0            779                   JSR      EA_SRC_beg      *display EA info we're negating
00001796                           780  
00001796                           781  
00001796                           782  * /neg_handler
00001796                           783  *-----------------------------------------------------------------------------
00001796                           784  
00001796                           785  
00001796                           786  *-----------------------------------------------------------------------------
00001796                           787  *bcc_handler
00001796                           788  *handles 'BCS','BGE','BLT','BVC','BRA'
00001796                           789  
00001796                           790  *D1: holds the condition, displacement nibbles of instruction
00001796                           791  *D3: holds the condition of instruction
00001796                           792  *D4: holds the current address of this instruction
00001796                           793  *A4: holds the pointer to bcc_tbl
00001796                           794  *A5: holds the current address of this instruction
00001796                           795  
00001796  4201                     796  bcc_handler   CLR.B   D1
00001798  E999                     797                ROL.L   #4,D1
0000179A  1601                     798                MOVE.B  D1,D3          *copy condition value to D3
0000179C  49F9 00004142            799                LEA     bcc_tbl,A4     *A4 now points to the bcc_tbl
000017A2  0C14 00FF                800  bcc_cond      CMP.B   #-1,(A4)       *have we reached the end of the table
000017A6  6700 F8CA                801                BEQ     inv_handler    * yes-invalid branch
000017AA  B61C                     802                CMP.B   (A4)+,D3       *compare the next table value
000017AC  6700 0004                803                BEQ     bcc_determiner * there's a match
000017B0  60F0                     804                BRA     bcc_cond       *continue looping through the table
000017B2                           805  
000017B2  0C24 0005                806  bcc_determiner  CMP.B  #5,-(a4)
000017B6  6700 0026                807                  BEQ    bcs_handler
000017BA  0C14 000C                808                  CMP.B  #12,(a4)
000017BE  6700 002C                809                  BEQ    bge_handler
000017C2  0C14 000D                810                  CMP.B  #13,(a4)
000017C6  6700 0032                811                  BEQ    blt_handler
000017CA  0C14 0008                812                  CMP.B  #8,(a4)
000017CE  6700 0038                813                  BEQ    bvc_handler
000017D2  0C14 0000                814                  CMP.B  #0,(a4)
000017D6  6700 003E                815                  BEQ    bra_handler
000017DA  6000 F896                816                  BRA    inv_handler
000017DE                           817  
000017DE  23F9 000040C4 00004150   818  bcs_handler   MOVE.L  BCS,INST_NAME
000017E8  6000 0036                819                BRA     bcc_dispm
000017EC  23F9 000040CC 00004150   820  bge_handler   MOVE.L  BGE,INST_NAME
000017F6  6000 0028                821                BRA     bcc_dispm
000017FA  23F9 000040D4 00004150   822  blt_handler   MOVE.L  BLT,INST_NAME
00001804  6000 001A                823                BRA     bcc_dispm
00001808  23F9 000040DC 00004150   824  bvc_handler   MOVE.L  BVC,INST_NAME
00001812  6000 000C                825                BRA     bcc_dispm
00001816  23F9 000040E4 00004150   826  bra_handler   MOVE.L  BRA,INST_NAME
00001820                           827  
00001820  280D                     828  bcc_dispm     MOVE.L  A5,D4            *copy current address to D4
00001822  DAFC 0002                829                ADDA    #word_len,A5     *all Bcc instructions took up a word         
00001826  4201                     830                CLR.B   D1               *now find the displacement- (A5 +- last 2 nibbles)
00001828  E199                     831                ROL.L   #8,D1            *get the last 2 displacement nibbles
0000182A  B23C 0000                832                CMP.B   #0,D1            *are the 8 displacement bits all 0?
0000182E  6700 0016                833                BEQ     bcc_word_handler * yes- get the following displacement word
00001832  B23C 000F                834                CMP.B   #$F,D1           *are all displacement bits 1?
00001836  6700 0012                835                BEQ     bcc_long_handler * yes-get the displacement long
0000183A  4681                     836  bcc_calc      NOT.L   D1               *ones complement **************** .L OR .w
0000183C  5281                     837                ADDI.L  #1,D1            *twos complement 
0000183E                           838  
0000183E  5404                     839                ADDI.B  #2,D4            *account for PC displacement 2 bytes ahead of current address
00001840  9841                     840                SUB.W   D1,D4            *calculate displacement address  ****.L OR .W
00001842  6000 000A                841                BRA     bcc_complete
00001846                           842                
00001846  321D                     843  bcc_word_handler  MOVE.W (A5)+,D1    *put 16 displacement bits in D1
00001848  60F0                     844                    BRA     bcc_calc
0000184A                           845                    
0000184A  221D                     846  bcc_long_handler  MOVE.L (A5)+,D1    *put 32 displacement bits in D1
0000184C  60EC                     847                    BRA     bcc_calc
0000184E                           848  
0000184E  4EB9 00001DA6            849  bcc_complete  JSR     disp_instr
00001854  2044                     850                MOVE.L  D4,A0      *move displacement address to A0 for next function
00001856  4EB9 00001E62            851                JSR     print_addr_sgn
0000185C  4EB9 00001DFA            852                JSR     hex_2_ascii
00001862  6000 F7AC                853                BRA     prep
00001866                           854                
00001866                           855   */bcc_handler            
00001866                           856  *-----------------------------------------------------------------------------
00001866                           857  
00001866                           858  *-----------------------------------------------------------------------------
00001866                           859   * shift_roll_handler   
00001866                           860   * handles 'LSR','LSL','ASR','ASL','ROL','ROR'
00001866                           861  
00001866                           862   
00001866                           863   *A5: holds the current address of this instruction
00001866                           864   *D2: used to check if its a shift or roll, immediate or register
00001866                           865   *D3: holds the size (b,w,l) of the operation
00001866                           866   *D4: holds the immediate data (1-7) or the register number of the source
00001866                           867   *D5: holds the destination register being shifted/rotated
00001866                           868   *D6: holds invalid destination flag
00001866                           869   *D7: holds invalid source flag
00001866                           870   
00001866  4201                     871  _shift_roll_handler  CLR.B    D1
00001868  E999                     872                       ROL.L    #4,D1
0000186A  1401                     873                       MOVE.B   D1,D2
0000186C  E202                     874                       ASR.B    #1,D2          *set the carry to be the direction of this shift/rotate
0000186E  6500 00A6                875                       BCS      _left_handler  * carry is set- its leftwards
00001872  6000 0002                876                       BRA      _right_handler * carry is set- rightwards
00001876                           877                       
00001876                           878  *------------------
00001876                           879  *------------------                    
00001876  2401                     880  _right_handler       MOVE.L   D1,D2          *recopy D1 to D2
00001878  4202                     881                       CLR.B    D2             *clear instruction data not needed now
0000187A  2602                     882                       MOVE.L   D2,D3          *copy instruction data used later to D3
0000187C  E79A                     883                       ROL.L    #3,D2          *shift and roll bits until we isolate the type (asr,lsr,ror)
0000187E  4202                     884                       CLR.B    D2             *""
00001880  E59A                     885                       ROL.L    #2,D2          *At this point we've isolated the type
00001882  B43C 0000                886                       CMP.B    #0,D2
00001886  6700 0016                887                       BEQ      asr_handler    *its asr
0000188A  B43C 0001                888                       CMP.B    #1,D2
0000188E  6700 0036                889                       BEQ      lsr_handler    *its lsr
00001892  B43C 0003                890                       CMP.B    #3,D2
00001896  6700 0056                891                       BEQ      ror_handler    *its ror
0000189A  6000 0614                892                       BRA      fatal_err      *its invalid
0000189E                           893  *------------------
0000189E                           894                      
0000189E  23F9 000040A4 00004150   895  asr_handler          MOVE.L   ASR,INST_NAME
000018A8  E78B                     896                       LSL.L    #3,D3          *shift until the mode bit is set to carry. D3 now holds size of operation
000018AA  6500 0006                897                       BCS      reg_asr        * carrys on- its a register source
000018AE                           898                       *CMP.B    #8,D3          * carrys off- is the immediate data too large?
000018AE                           899                       *BGT      flag_source    
000018AE  6000 000C                900                       BRA      imm_asr        * go to immediate data handler
000018B2                           901  flag_source
000018B2                           902                      
000018B2  4EB9 000019B6            903  reg_asr              JSR      save_srh_data
000018B8                           904                       
000018B8  6000 0110                905                       BRA      prep_srh_disp
000018BC                           906  
000018BC  4EB9 000019B6            907  imm_asr              JSR      save_srh_data  *saves source(imm) data, destination register
000018C2                           908                       
000018C2                           909                       
000018C2  6000 0106                910                       BRA      prep_srh_disp  
000018C6                           911  *------------------
000018C6                           912  
000018C6  23F9 00004094 00004150   913  lsr_handler          MOVE.L   LSR,INST_NAME
000018D0  E78B                     914                       LSL.L    #3,D3
000018D2  6500 0006                915                       BCS      reg_lsr
000018D6  6000 000C                916                       BRA      imm_lsr
000018DA                           917                       
000018DA  4EB9 000019B6            918  reg_lsr              JSR      save_srh_data
000018E0                           919                       
000018E0  6000 00E8                920                       BRA      prep_srh_disp
000018E4                           921  
000018E4  4EB9 000019B6            922  imm_lsr              JSR      save_srh_data  *saves source(imm) data, destination register
000018EA                           923                       
000018EA  6000 00DE                924                       BRA      prep_srh_disp
000018EE                           925  *------------------
000018EE                           926  
000018EE  23F9 000040BC 00004150   927  ror_handler          MOVE.L   ROR,INST_NAME
000018F8  E78B                     928                       LSL.L    #3,D3
000018FA  6500 0006                929                       BCS      reg_ror
000018FE  6000 000C                930                       BRA      imm_ror
00001902                           931  
00001902  4EB9 000019B6            932  reg_ror              JSR      save_srh_data
00001908                           933                       
00001908  6000 00C0                934                       BRA      prep_srh_disp
0000190C                           935  
0000190C  4EB9 000019B6            936  imm_ror              JSR      save_srh_data  *saves source(imm) data, destination register
00001912                           937                       
00001912  6000 00B6                938                       BRA      prep_srh_disp
00001916                           939  *------------------
00001916                           940  *------------------
00001916  2401                     941  _left_handler        MOVE.L   D1,D2          *recopy D1 to D2
00001918  4202                     942                       CLR.B    D2
0000191A  2602                     943                       MOVE.L   D2,D3
0000191C  E79A                     944                       ROL.L    #3,D2
0000191E  4202                     945                       CLR.B    D2
00001920  E59A                     946                       ROL.L    #2,D2
00001922  B43C 0000                947                       CMP.B    #0,D2
00001926  6700 0016                948                       BEQ      asl_handler
0000192A  B43C 0001                949                       CMP.B    #1,D2
0000192E  6700 0036                950                       BEQ      lsl_handler
00001932  B43C 0003                951                       CMP.B    #3,D2
00001936  6700 0056                952                       BEQ      rol_handler
0000193A  6000 0574                953                       BRA      fatal_err    
0000193E                           954  *------------------
0000193E                           955  
0000193E                           956  
0000193E  23F9 000040AC 00004150   957  asl_handler          MOVE.L   ASL,INST_NAME
00001948  E78B                     958                       LSL.L    #3,D3
0000194A  6500 0006                959                       BCS      reg_asl
0000194E  6000 000C                960                       BRA      imm_asl       
00001952                           961                       
00001952  4EB9 000019B6            962  reg_asl              JSR      save_srh_data
00001958                           963                       
00001958  6000 0070                964                       BRA      prep_srh_disp
0000195C                           965  
0000195C  4EB9 000019B6            966  imm_asl              JSR      save_srh_data  *saves source(imm) data, destination register
00001962                           967                       
00001962  6000 0066                968                       BRA      prep_srh_disp
00001966                           969  *------------------        
00001966                           970                                
00001966                           971  
00001966  23F9 0000409C 00004150   972  lsl_handler          MOVE.L   LSL,INST_NAME
00001970  E78B                     973                       LSL.L    #3,D3
00001972  6500 0006                974                       BCS      reg_lsl
00001976  6000 000C                975                       BRA      imm_lsl
0000197A                           976                       
0000197A  4EB9 000019B6            977  reg_lsl              JSR      save_srh_data
00001980                           978                       
00001980  6000 0048                979                       BRA      prep_srh_disp
00001984                           980  
00001984  4EB9 000019B6            981  imm_lsl              JSR      save_srh_data  *saves source(imm) data, destination register
0000198A                           982                       
0000198A  6000 003E                983                       BRA      prep_srh_disp
0000198E                           984  *------------------
0000198E                           985  
0000198E                           986  
0000198E  23F9 000040B4 00004150   987  rol_handler          MOVE.L   ROL,INST_NAME
00001998  E78B                     988                       LSL.L    #3,D3
0000199A  6500 0006                989                       BCS      reg_rol
0000199E  6000 000C                990                       BRA      imm_rol
000019A2                           991                       
000019A2  4EB9 000019B6            992  reg_rol              JSR      save_srh_data
000019A8                           993                       
000019A8  6000 0020                994                       BRA      prep_srh_disp
000019AC                           995  
000019AC  4EB9 000019B6            996  imm_rol              JSR      save_srh_data  *saves source(imm) data, destination register
000019B2                           997                       
000019B2  6000 0016                998                       BRA      prep_srh_disp
000019B6                           999  *------------------                    
000019B6                          1000                                       
000019B6                          1001                       
000019B6  2401                    1002  save_srh_data        MOVE.L   D1,D2          *recopy D1 to D2
000019B8  E20A                    1003                       LSR.B    #1,D2          *isolate the 3 source bits
000019BA  1A02                    1004                       MOVE.B   D2,D5          *save the source bits to D4
000019BC  4201                    1005                       CLR.B    D1             *prep the byte space
000019BE  EA99                    1006                       ROR.L    #5,D1
000019C0  4201                    1007                       CLR.B    D1
000019C2  E699                    1008                       ROR.L    #3,D1          *get the last 3 bits of the instruction
000019C4  1A01                    1009                       MOVE.B   D1,D5          *D5 now holds the destination register
000019C6                          1010                       
000019C6                          1011                       *load source bits to a2
000019C6                          1012                       *load dest bits to a3
000019C6                          1013                       *jump to antonys routine, then exit
000019C6                          1014                       
000019C6  544D                    1015                       ADDA     #2,A5
000019C8                          1016                       
000019C8  4E75                    1017                       RTS
000019CA                          1018                       
000019CA  6000 03DA               1019  prep_srh_disp        BRA      disp_instr             
000019CE                          1020              
000019CE                          1021   * /_shift_roll_handler  
000019CE                          1022  *-----------------------------------------------------------------------------
000019CE                          1023  
000019CE                          1024                          
000019CE                          1025  *-----------------------------------------------------------------------------
000019CE                          1026  * lea_handler
000019CE                          1027  * handles lea
000019CE                          1028  
000019CE                          1029  *D1: holds opcode instruction
000019CE                          1030  *D2: holds register bits
000019CE                          1031  
000019CE  E209                    1032  lea_handler       LSR.B     #1,D1          *hardcoded bit
000019D0  2401                    1033                    MOVE.L    D1,D2          *save dest An bits to D2
000019D2  4201                    1034                    CLR.B     D1
000019D4  E589                    1035                    LSL.L     #2,D1          *hardcoded bits
000019D6  E799                    1036                    ROL.L     #3,D1
000019D8  2601                    1037                    MOVE.L    D1,D3          *get EA bits into D3
000019DA  23F9 00004044 00004150  1038                    MOVE.L    LEA,INST_NAME
000019E4  4EB9 00001DA6           1039                    JSR       disp_instr       
000019EA  4EB9 00001AA0           1040                    JSR       EA_SRC_beg
000019F0  4EB9 00001E4C           1041                    JSR       print_comma
000019F6  2602                    1042                    MOVE.L    D2,D3
000019F8  4EB9 00001B7A           1043                    JSR       PRINT_INNER_An     
000019FE  6000 F610               1044                    BRA       prep
00001A02                          1045                    
00001A02                          1046                    
00001A02                          1047  * /lea_handler
00001A02                          1048  *-----------------------------------------------------------------------------
00001A02                          1049  
00001A02                          1050  
00001A02                          1051  *-----------------------------------------------------------------------------
00001A02                          1052  *jsr_handler
00001A02                          1053  *handles 'JSR'
00001A02                          1054  
00001A02  E599                    1055  jsr_handler       ROL.L   #2,D1
00001A04  B23C 003A               1056                    CMP.B   #$3A,D1       *make sure its really JSR based on next bits
00001A08  6600 F668               1057                    BNE     inv_handler
00001A0C  23F9 00004054 00004150  1058                    MOVE.L  JSR,INST_NAME
00001A16  4EB9 00001DA6           1059                    JSR     disp_instr
00001A1C  E799                    1060                    ROL.L   #3,D1         *save EA bits into D1
00001A1E  2601                    1061                    MOVE.L  D1,D3
00001A20  4EB9 00001AA0           1062                    JSR     EA_SRC_beg
00001A26  6000 F5E8               1063                    BRA     prep
00001A2A                          1064  
00001A2A                          1065  * /jsr_handler
00001A2A                          1066  *-----------------------------------------------------------------------------
00001A2A                          1067  
00001A2A                          1068  
00001A2A                          1069  *-----------------------------------------------------------------------------
00001A2A                          1070  *movem_handler
00001A2A                          1071  *handles 'MOVEM'
00001A2A                          1072  
00001A2A  23F9 0000403C 00004150  1073  movem_handler  MOVE.L  MOV,INST_NAME
00001A34  23F9 0000412A 00004158  1074                 MOVE.L  EM,INST_NAME_EXT
00001A3E  B23C 0008               1075                 CMP.B   #$8,D1
00001A42  6700 0028               1076                 BEQ     movem_dn
00001A46  1401                    1077  movem_an       MOVE.B  D1,D2
00001A48  4201                    1078                 CLR.B   D1
00001A4A  E589                    1079                 LSL.L   #2,D1
00001A4C  6500 0010               1080                 BCS     movem_long
00001A50                          1081                 
00001A50  23F9 00004136 0000413E  1082  movem_word     MOVE.L  SIZEW,SIZECODE
00001A5A  6000 0018               1083                 BRA     movem_ea
00001A5E  23F9 0000413A 0000413E  1084  movem_long     MOVE.L  SIZEL,SIZECODE
00001A68  6000 000A               1085                 BRA     movem_ea
00001A6C                          1086  
00001A6C  4201                    1087  movem_dn       CLR.B   D1
00001A6E  E589                    1088                 LSL.L   #2,D1
00001A70  65EC                    1089                 BCS     movem_long
00001A72  60DC                    1090                 BRA     movem_word
00001A74                          1091  
00001A74  4EB9 00001DA6           1092  movem_ea       JSR     disp_instr
00001A7A  4201                    1093                 CLR.B   D1
00001A7C  E799                    1094                 ROL.L   #3,D1
00001A7E  2601                    1095                 MOVE.L  D1,D3
00001A80  4EB9 00001AA0           1096                 JSR     EA_SRC_beg
00001A86  6000 F588               1097                 BRA     prep
00001A8A                          1098  
00001A8A                          1099  * /movem_handler
00001A8A                          1100  *-----------------------------------------------------------------------------
00001A8A                          1101  
00001A8A                          1102  *-----------------------------------------------------------------------------
00001A8A                          1103  * rts_handler
00001A8A                          1104  * handles 'RTS'
00001A8A                          1105  
00001A8A  4281                    1106  rts_handler    CLR.L  D1                    *rts all hardcoded
00001A8C  23F9 0000405C 00004150  1107                 MOVE.L RTS,INST_NAME
00001A96  4EB9 00001DA6           1108                 JSR    disp_instr
00001A9C  6000 F572               1109                 BRA    prep
00001AA0                          1110  
00001AA0                          1111  * /rts_handler
00001AA0                          1112  *-----------------------------------------------------------------------------
00001AA0                          1113  
00001AA0                          1114  
00001AA0                          1115  
00001AA0                          1116  *below functions also increment address pointer A5 depending on data fetch size for immediate,absolute addresses
00001AA0                          1117  
00001AA0  DAFC 0002               1118  EA_SRC_beg  ADDA   #word_len,A5
00001AA4                          1119  
00001AA4                          1120              *(xxx).W, (xxx).L, #<data>        
00001AA4  0C03 0007               1121  EA_SRC      CMPI.B #$7, D3            *Compares if its 111
00001AA8  6700 002E               1122                 BEQ FILTER_EA_MODE
00001AAC                          1123  
00001AAC                          1124              *Dn
00001AAC  0C03 0000               1125              CMPI.B #$0, D3           *Compares if its 000
00001AB0                          1126                  
00001AB0  6700 0060               1127                  BEQ DATA_REGISTER
00001AB4                          1128                  
00001AB4  0C03 0001               1129              CMPI.B #1, D3               *001
00001AB8  6700 0050               1130                  BEQ ADDRESS_MODE
00001ABC                          1131                  
00001ABC                          1132              *(An)
00001ABC  0C03 0002               1133              CMPI.B #$2, D3            *Compares if its 010
00001AC0  6700 0094               1134                  BEQ CLOSED_PARAN
00001AC4                          1135                  
00001AC4                          1136              *(An)+
00001AC4  0C03 0003               1137              CMPI.B #$3, D3            *Compares if its 011
00001AC8  6700 00F0               1138                  BEQ POSTFIX_PLUS
00001ACC                          1139              
00001ACC                          1140              *-(An)                  *Compares if its 100
00001ACC  0C03 0004               1141              CMPI.B #$4, D3
00001AD0  6700 0116               1142                  BEQ PREFIX_MINUS
00001AD4                          1143                  
00001AD4  6600 0024               1144                  BNE INVALID_MODE      *e.g. ARI,PCI
00001AD8                          1145  
00001AD8                          1146  FILTER_EA_MODE
00001AD8                          1147          *Rotate to get register as byte
00001AD8  4203                    1148          CLR.B  D3
00001ADA  E79B                    1149          ROL.L  #3,D3
00001ADC                          1150           
00001ADC                          1151          *(xxx).W
00001ADC  0C03 0000               1152          CMPI.B #$0, D3
00001AE0  6700 0134               1153              BEQ WORD_MODE
00001AE4                          1154              
00001AE4                          1155          *(xxx).L
00001AE4  0C03 0001               1156          CMPI.B #$1, D3
00001AE8  6700 0146               1157              BEQ LONG_MODE
00001AEC                          1158              
00001AEC                          1159          *# <data>
00001AEC  0C03 0004               1160          CMPI.B #$4, D3
00001AF0  6700 0158               1161              BEQ DATA_MODE
00001AF4  6600 0004               1162              BNE INVALID_MODE
00001AF8  4E75                    1163      RTS
00001AFA                          1164  
00001AFA                          1165  
00001AFA                          1166  INVALID_MODE    *unsupported mode eg PCD,PCI
00001AFA  227C 00004114           1167      MOVE.L  #INV,A1
00001B00  103C 000E               1168      MOVE.B  #14,D0
00001B04  4E4F                    1169      TRAP    #15
00001B06                          1170      
00001B06  544D                    1171      ADDA    #2,A5   ******* inv opcodes take up a word
00001B08                          1172      
00001B08  4E75                    1173      RTS
00001B0A                          1174      
00001B0A                          1175  *An
00001B0A                          1176  ADDRESS_MODE  *Get register to get what Dn to go to
00001B0A  4203                    1177      CLR.B  D3
00001B0C  E79B                    1178      ROL.L  #3,D3
00001B0E  6000 006A               1179      BRA    PRINT_INNER_An
00001B12                          1180  
00001B12                          1181  * Dn
00001B12                          1182  DATA_REGISTER    *Get register to get what Dn to go to
00001B12  4203                    1183      CLR.B  D3
00001B14  E79B                    1184      ROL.L  #3,D3
00001B16                          1185      
00001B16  0C03 0000               1186  DR_CMP  CMPI.B #0, D3
00001B1A  6700 016A               1187          BEQ PRINT_D0
00001B1E  0C03 0001               1188      CMPI.B #1, D3
00001B22  6700 0174               1189          BEQ PRINT_D1
00001B26  0C03 0002               1190      CMPI.B #2, D3
00001B2A  6700 017E               1191          BEQ PRINT_D2
00001B2E  0C03 0003               1192      CMPI.B #3, D3
00001B32  6700 0188               1193          BEQ PRINT_D3
00001B36  0C03 0004               1194      CMPI.B #4, D3
00001B3A  6700 0192               1195          BEQ PRINT_D4
00001B3E  0C03 0005               1196      CMPI.B #5, D3
00001B42  6700 019C               1197          BEQ PRINT_D5
00001B46  0C03 0006               1198      CMPI.B #6, D3
00001B4A  6700 01A6               1199          BEQ PRINT_D6
00001B4E  0C03 0007               1200      CMPI.B #7, D3
00001B52  6700 01B0               1201          BEQ PRINT_D7
00001B56                          1202      
00001B56                          1203  * (An)
00001B56                          1204  CLOSED_PARAN  *Get register to get what Dn to go to
00001B56  4203                    1205      CLR.B  D3
00001B58  E79B                    1206      ROL.L  #3,D3
00001B5A                          1207      *Prints '('
00001B5A  43F9 00004160           1208      LEA open_paren, A1
00001B60  103C 000E               1209      MOVE.B #14, D0
00001B64  4E4F                    1210      TRAP #15
00001B66                          1211      
00001B66                          1212      *Print The appropriate value of An *Needed to use JSR & RTS
00001B66  4EB9 00001B7A           1213      JSR PRINT_INNER_An
00001B6C                          1214     
00001B6C                          1215      *Prints ')'
00001B6C  43F9 00004162           1216      LEA closed_paren, A1
00001B72  103C 000E               1217      MOVE.B #14, D0
00001B76  4E4F                    1218      TRAP #15
00001B78  4E75                    1219      RTS
00001B7A                          1220      
00001B7A                          1221  *Prints the An in (An) and returns to the original method   
00001B7A                          1222  PRINT_INNER_An
00001B7A  0C43 0000               1223      CMPI  #0, D3
00001B7E  6700 0196               1224          BEQ    PRINT_A0
00001B82  0C43 0001               1225      CMPI #1, D3
00001B86  6700 01A0               1226          BEQ PRINT_A1
00001B8A  0C43 0002               1227      CMPI #2, D3
00001B8E  6700 01AA               1228          BEQ PRINT_A2
00001B92  0C43 0003               1229      CMPI #3, D3
00001B96  6700 01B4               1230          BEQ PRINT_A3
00001B9A  0C43 0004               1231      CMPI #4, D3
00001B9E  6700 01BE               1232          BEQ PRINT_A4
00001BA2  0C43 0005               1233      CMPI #5, D3
00001BA6  6700 01C8               1234          BEQ PRINT_A5
00001BAA  0C43 0006               1235      CMPI #6, D3
00001BAE  6700 01D2               1236          BEQ PRINT_A6
00001BB2  0C43 0007               1237      CMPI #7, D3
00001BB6  6700 01DC               1238          BEQ PRINT_A7
00001BBA                          1239  
00001BBA                          1240  * (An)+
00001BBA                          1241  POSTFIX_PLUS
00001BBA  4203                    1242      CLR.B  D3
00001BBC  E79B                    1243      ROL.L  #3,D3
00001BBE                          1244      
00001BBE                          1245      *Prints '('
00001BBE  43F9 00004160           1246      LEA open_paren, A1
00001BC4  103C 000E               1247      MOVE.B #14, D0
00001BC8  4E4F                    1248      TRAP #15
00001BCA                          1249  
00001BCA                          1250      
00001BCA                          1251      *Print The appropriate value of An
00001BCA  4EB8 1B7A               1252      JSR PRINT_INNER_An
00001BCE                          1253      
00001BCE                          1254      *Prints ')'
00001BCE  43F9 00004162           1255      LEA closed_paren, A1
00001BD4  103C 000E               1256      MOVE.B #14, D0
00001BD8  4E4F                    1257      TRAP #15
00001BDA                          1258      
00001BDA                          1259       *Prints '+'
00001BDA  43F9 00004164           1260      LEA plus_sign, A1
00001BE0  103C 000E               1261      MOVE.B #14, D0
00001BE4  4E4F                    1262      TRAP #15
00001BE6  4E75                    1263      RTS
00001BE8                          1264      
00001BE8                          1265  *-(An)
00001BE8  4203                    1266  PREFIX_MINUS   CLR.B  D3
00001BEA  E79B                    1267      ROL.L  #3,D3
00001BEC                          1268      
00001BEC                          1269       *Prints '-'
00001BEC  43F9 00004166           1270      LEA neg_sign, A1
00001BF2  103C 000E               1271      MOVE.B #14, D0
00001BF6  4E4F                    1272      TRAP #15
00001BF8                          1273      
00001BF8                          1274      *Prints '('
00001BF8  43F9 00004160           1275      LEA open_paren, A1
00001BFE  103C 000E               1276      MOVE.B #14, D0
00001C02  4E4F                    1277      TRAP #15
00001C04                          1278      
00001C04                          1279      *Print The appropriate value of An *Needed to use JSR & RTS
00001C04  4EB8 1B7A               1280      JSR PRINT_INNER_An
00001C08                          1281      
00001C08                          1282      
00001C08                          1283      *Prints ')'
00001C08  43F9 00004162           1284      LEA closed_paren, A1
00001C0E  103C 000E               1285      MOVE.B #14, D0
00001C12  4E4F                    1286      TRAP #15
00001C14                          1287   
00001C14  4E75                    1288      RTS
00001C16                          1289      
00001C16                          1290  *(xxx).W 
00001C16  48E7 4000               1291  WORD_MODE  MOVEM.L  D1,-(SP)      *save calling state of D1
00001C1A  4281                    1292             CLR.L    D1
00001C1C                          1293             *ADDA     #word_len,A5  *increment the pointer to the next address by the length of the next WORD fetched from memory
00001C1C  4EB9 00001E62           1294             JSR      print_addr_sgn
00001C22  305D                    1295             MOVE.W   (A5)+,A0      *move that word value to A0 for display
00001C24  4EB9 00001DFA           1296             JSR      hex_2_ascii   *convert/display the word
00001C2A  4CDF 0002               1297             MOVEM.L  (SP)+,D1      *restore D1
00001C2E  4E75                    1298             RTS
00001C30                          1299      
00001C30                          1300  *(xxx).L 
00001C30  48E7 4000               1301  LONG_MODE  MOVEM.L  D1,-(SP)      *save calling state of D1
00001C34  4281                    1302             CLR.L    D1
00001C36                          1303             *ADDA     #long_len,A5 *increment the pointer to the next address by the length of the next LONG fetched from memory
00001C36  4EB9 00001E62           1304             JSR      print_addr_sgn
00001C3C  205D                    1305             MOVE.L   (A5)+,A0      *move that long value to A0 for display
00001C3E  4EB9 00001DFA           1306             JSR      hex_2_ascii   *convert/display the long in A0
00001C44  4CDF 0002               1307             MOVEM.L  (SP)+,D1      *restore D1
00001C48  4E75                    1308             RTS
00001C4A                          1309             
00001C4A                          1310  
00001C4A                          1311  *#<data>
00001C4A  48E7 4000               1312  DATA_MODE  MOVEM.L  D1,-(SP)        *save calling state of D1
00001C4E  4281                    1313             CLR.L    D1 
00001C50  0C12 0001               1314             CMP.B    #1,(A2)         *is immediate data flagged as a word?
00001C54  6700 000A               1315             BEQ      word_data_handler
00001C58  0C12 0002               1316             CMP.B    #2,(A2)         *is immediate data flagged as a long?
00001C5C  6700 0008               1317             BEQ      long_data_handler         
00001C60                          1318  
00001C60                          1319                                      *then its a byte held as a word 
00001C60                          1320  
00001C60                          1321  *byte_data_handler *ADDA     #byte_len,A5
00001C60                          1322   *                 MOVE.B   (A5)+,D1     *get immediate byte data and increment address by a byte
00001C60                          1323    *                BRA      data_mode_print
00001C60                          1324                    
00001C60                          1325  word_data_handler *ADDA     #word_len,A5
00001C60  321D                    1326                    MOVE.W   (A5)+,D1     *get immediate word data and increment address by a word
00001C62  6000 0008               1327                    BRA      data_mode_print
00001C66                          1328  
00001C66                          1329  long_data_handler *ADDA     #long_len,A5
00001C66  221D                    1330                    MOVE.L   (A5)+,D1     *get immediate long data and increment address by a long
00001C68  6000 0002               1331                    BRA      data_mode_print
00001C6C                          1332  
00001C6C  43F9 0000415E           1333  data_mode_print   LEA      imm_sign, A1    *load and print '#' character
00001C72  103C 000E               1334                    MOVE.B   #14, D0
00001C76  4E4F                    1335                    TRAP     #15  
00001C78  2041                    1336                    MOVE.L   D1,A0
00001C7A  4EB9 00001DFA           1337                    JSR      hex_2_ascii  *print the hex data
00001C80  4CDF 0002               1338                    MOVEM.L  (SP)+,D1     *restore D1
00001C84  4E75                    1339                    RTS
00001C86                          1340  
00001C86  43F9 00001C94           1341  PRINT_D0 LEA D0_MESS, A1
00001C8C  103C 000E               1342      MOVE.B #14, D0
00001C90  4E4F                    1343      TRAP #15
00001C92  4E75                    1344      RTS
00001C94= 4430 0000               1345  D0_MESS  DC.W 'D0',0
00001C98                          1346  
00001C98                          1347  
00001C98  43F9 00001CA6           1348  PRINT_D1 LEA D1_MESS, A1
00001C9E  103C 000E               1349      MOVE.B #14, D0
00001CA2  4E4F                    1350      TRAP #15
00001CA4  4E75                    1351      RTS
00001CA6= 4431 0000               1352  D1_MESS  DC.W 'D1',0
00001CAA                          1353  
00001CAA                          1354  
00001CAA  43F9 00001CB8           1355  PRINT_D2 LEA D2_MESS, A1
00001CB0  103C 000E               1356      MOVE.B #14, D0
00001CB4  4E4F                    1357      TRAP #15
00001CB6  4E75                    1358      RTS
00001CB8= 4432 0000               1359  D2_MESS  DC.W 'D2',0
00001CBC                          1360  
00001CBC                          1361  
00001CBC  43F9 00001CCA           1362  PRINT_D3 LEA D3_MESS, A1
00001CC2  103C 000E               1363      MOVE.B #14, D0
00001CC6  4E4F                    1364      TRAP #15
00001CC8  4E75                    1365      RTS
00001CCA= 4433 0000               1366  D3_MESS  DC.W 'D3',0
00001CCE                          1367  
00001CCE                          1368  
00001CCE  43F9 00001CDC           1369  PRINT_D4 LEA D4_MESS, A1
00001CD4  103C 000E               1370      MOVE.B #14, D0
00001CD8  4E4F                    1371      TRAP #15
00001CDA  4E75                    1372      RTS
00001CDC= 4434 0000               1373  D4_MESS  DC.W 'D4',0
00001CE0                          1374  
00001CE0                          1375  
00001CE0  43F9 00001CEE           1376  PRINT_D5 LEA D5_MESS, A1
00001CE6  103C 000E               1377      MOVE.B #14, D0
00001CEA  4E4F                    1378      TRAP #15
00001CEC  4E75                    1379      RTS
00001CEE= 4435 0000               1380  D5_MESS  DC.W 'D5',0
00001CF2                          1381  
00001CF2                          1382  
00001CF2  43F9 00001D00           1383  PRINT_D6 LEA D6_MESS, A1
00001CF8  103C 000E               1384      MOVE.B #14, D0
00001CFC  4E4F                    1385      TRAP #15
00001CFE  4E75                    1386      RTS
00001D00= 4436 0000               1387  D6_MESS  DC.W 'D6',0
00001D04                          1388  
00001D04  43F9 00001D12           1389  PRINT_D7 LEA D7_MESS, A1
00001D0A  103C 000E               1390      MOVE.B #14, D0
00001D0E  4E4F                    1391      TRAP #15
00001D10  4E75                    1392      RTS
00001D12= 4437 0000               1393  D7_MESS  DC.W 'D7',0
00001D16                          1394      
00001D16                          1395  
00001D16  43F9 00001D24           1396  PRINT_A0 LEA A0_MESS, A1
00001D1C  103C 000E               1397      MOVE.B #14, D0
00001D20  4E4F                    1398      TRAP #15
00001D22  4E75                    1399      RTS
00001D24= 4130 0000               1400  A0_MESS DC.W 'A0',0
00001D28                          1401  
00001D28  43F9 00001D36           1402  PRINT_A1 LEA A1_MESS, A1
00001D2E  103C 000E               1403      MOVE.B #14, D0
00001D32  4E4F                    1404      TRAP #15
00001D34  4E75                    1405      RTS
00001D36= 4131 0000               1406  A1_MESS DC.W 'A1',0
00001D3A                          1407  
00001D3A  43F9 00001D48           1408  PRINT_A2 LEA A2_MESS, A1
00001D40  103C 000E               1409      MOVE.B #14, D0
00001D44  4E4F                    1410      TRAP #15
00001D46  4E75                    1411      RTS
00001D48= 4132 0000               1412  A2_MESS DC.W 'A2',0
00001D4C                          1413  
00001D4C  43F9 00001D5A           1414  PRINT_A3 LEA A3_MESS, A1
00001D52  103C 000E               1415      MOVE.B #14, D0
00001D56  4E4F                    1416      TRAP #15
00001D58  4E75                    1417      RTS
00001D5A= 4133 0000               1418  A3_MESS DC.W 'A3',0
00001D5E                          1419  
00001D5E  43F9 00001D6C           1420  PRINT_A4 LEA A4_MESS, A1
00001D64  103C 000E               1421      MOVE.B #14, D0
00001D68  4E4F                    1422      TRAP #15
00001D6A  4E75                    1423      RTS
00001D6C= 4134 0000               1424  A4_MESS DC.W 'A4',0
00001D70                          1425  
00001D70  43F9 00001D7E           1426  PRINT_A5 LEA A5_MESS, A1
00001D76  103C 000E               1427      MOVE.B #14, D0
00001D7A  4E4F                    1428      TRAP #15
00001D7C  4E75                    1429      RTS
00001D7E= 4135 0000               1430  A5_MESS DC.W 'A5',0
00001D82                          1431  
00001D82  43F9 00001D90           1432  PRINT_A6 LEA A6_MESS, A1
00001D88  103C 000E               1433      MOVE.B #14, D0
00001D8C  4E4F                    1434      TRAP #15
00001D8E  4E75                    1435      RTS
00001D90= 4136 0000               1436  A6_MESS DC.W 'A6',0
00001D94                          1437  
00001D94  43F9 00001DA2           1438  PRINT_A7 LEA A7_MESS, A1
00001D9A  103C 000E               1439      MOVE.B #14, D0
00001D9E  4E4F                    1440      TRAP #15
00001DA0  4E75                    1441      RTS
00001DA2= 4137 0000               1442  A7_MESS DC.W 'A7',0
00001DA6                          1443                
00001DA6                          1444  *-----------------------------------------------------------------------------------------
00001DA6                          1445  *disp_instr
00001DA6                          1446  * displays the instruction name in assembly and the address of the instruction
00001DA6                          1447  
00001DA6  48E7 4000               1448  disp_instr    MOVEM.L D1, -(SP)     *save state of D1 before using it below
00001DAA                          1449  
00001DAA  4EB9 00001E62           1450                JSR     print_addr_sgn *print '$'
00001DB0  204D                    1451                MOVEA.L A5,A0          *load A0 with the current address for the next function
00001DB2  4EB9 00001DFA           1452                JSR     hex_2_ascii    *convert the hex addr to ascii to print
00001DB8                          1453                
00001DB8  43F9 0000416F           1454                LEA     space,A1
00001DBE  103C 000E               1455                MOVE.B  #14,D0
00001DC2  4E4F                    1456                TRAP    #15
00001DC4                          1457                
00001DC4  43F9 00004150           1458                LEA.L   INST_NAME,A1  *move the (assembly) name of this instruction into A1
00001DCA  103C 000E               1459                MOVE.B  #14,D0
00001DCE  4E4F                    1460                TRAP    #15
00001DD0                          1461                
00001DD0  43F9 00004158           1462                LEA     INST_NAME_EXT,A1  *if the instruction name was longer than 32 bits
00001DD6  103C 000E               1463                MOVE.B  #14,D0
00001DDA  4E4F                    1464                TRAP    #15
00001DDC                          1465                
00001DDC  43F9 0000413E           1466                LEA.L   SIZECODE,A1       *print size of operation
00001DE2  103C 000E               1467                MOVE.B  #14,D0
00001DE6  4E4F                    1468                TRAP    #15
00001DE8                          1469                
00001DE8  43F9 0000416F           1470                LEA     space,A1
00001DEE  103C 000E               1471                MOVE.B  #14,D0
00001DF2  4E4F                    1472                TRAP    #15
00001DF4                          1473                
00001DF4                          1474                
00001DF4  4CDF 0002               1475                MOVEM.L  (SP)+,D1         *restore D1
00001DF8  4E75                    1476                RTS
00001DFA                          1477                
00001DFA                          1478  * /disp_instr
00001DFA                          1479  *-----------------------------------------------------------------------------------------  
00001DFA                          1480  
00001DFA                          1481  
00001DFA                          1482  *----------------------------------------------------------------------------------------- 
00001DFA                          1483  *hex_2_ascii
00001DFA                          1484  * converts a hex number to its ascii string equivalent (0s in MSB positions).
00001DFA                          1485  
00001DFA                          1486  * move A0 into D3 and split first part of address and second part of address 
00001DFA                          1487  *   to D3 and D4 respectively
00001DFA                          1488  
00001DFA                          1489  *D3:less significant word of address
00001DFA                          1490  *D4:more significant word of address 
00001DFA                          1491  *D5:holds iteration number
00001DFA                          1492  *D6:index into table
00001DFA                          1493  
00001DFA                          1494  h2a_regs        REG     D1/D3-D6/A0/A4
00001DFA                          1495  
00001DFA  48E7 5E88               1496  hex_2_ascii     MOVEM.L h2a_regs,-(SP)  *save state of registers before call                                
00001DFE  4285                    1497                  CLR.L   D5              *clear iteration counter
00001E00  4281                    1498                  CLR.L   D1
00001E02  4286                    1499                  CLR.L   D6
00001E04  2808                    1500                  MOVE.L  A0,D4           *save address in D4
00001E06  2604                    1501                  MOVE.L  D4,D3           *and move it toD3
00001E08  4244                    1502                  CLR.W   D4              *partition the first and second long of the address
00001E0A  4843                    1503                  SWAP    D3
00001E0C  49F9 00004000           1504                  LEA     string_tbl,A4
00001E12  E99C                    1505  h2a_prep        ROL.L   #4,D4           *roll first byte over for analysis
00001E14  B834 6001               1506  h2a_loop        CMP.B   1(A4,D6.W),D4   *find hex/ascii match in table
00001E18  6700 0006               1507                  BEQ     h2a_match   
00001E1C  5446                    1508                  ADDI    #2,D6
00001E1E  60F4                    1509                  BRA     h2a_loop        
00001E20  1234 6000               1510  h2a_match       MOVE.B  (A4,D6.W),D1    *move the match to D1
00001E24  103C 0006               1511                  MOVE.B  #6,D0           *display the value in D1
00001E28  4E4F                    1512                  TRAP    #15
00001E2A  4204                    1513                  CLR.B   D4
00001E2C  4206                    1514                  CLR.B   D6
00001E2E  5245                    1515                  ADDI    #1,D5           *increment loop counter
00001E30  BA3C 0008               1516                  CMP.B   #h2a_its,D5     *have we done every nibble
00001E34  6C00 0010               1517                  BGE     h2a_ret
00001E38  BA3C 0004               1518                  CMP.B   #h2a_its-4,D5   *are we halfway done (time to get second part of addr?)
00001E3C  6700 0004               1519                  BEQ     h2a_swap
00001E40  60D0                    1520                  BRA     h2a_prep
00001E42  2803                    1521  h2a_swap        MOVE.L  D3,D4           *move second part of word to D4                
00001E44  60CC                    1522                  BRA     h2a_prep
00001E46                          1523  
00001E46  4CDF 117A               1524  h2a_ret         MOVEM.L  (SP)+,h2a_regs   *restore state of registers 
00001E4A  4E75                    1525                  RTS
00001E4C                          1526                  
00001E4C  =00000008               1527  h2a_its         EQU     8
00001E4C                          1528  
00001E4C                          1529  * /hex_2_ascii
00001E4C                          1530  *----------------------------------------------------------------------------------------- 
00001E4C                          1531  
00001E4C  48E7 0040               1532  print_comma   MOVEM.L A1,-(SP)
00001E50  43F9 00004168           1533                LEA     comma,A1
00001E56  103C 000E               1534                MOVE.B  #14,D0
00001E5A  4E4F                    1535                TRAP    #15    
00001E5C  4CDF 0200               1536                MOVEM.L (SP)+,A1
00001E60  4E75                    1537                RTS    
00001E62                          1538                
00001E62  48E7 0040               1539  print_addr_sgn MOVEM.L A1,-(SP)
00001E66  43F9 0000415C           1540                 LEA     addr_sign,A1
00001E6C  103C 000E               1541                 MOVE.B  #14,D0
00001E70  4E4F                    1542                 TRAP    #15    
00001E72  4CDF 0200               1543                 MOVEM.L (SP)+,A1
00001E76  4E75                    1544                 RTS    
00001E78                          1545                 
00001E78  43F9 0000416C           1546  done          LEA     nl,A1
00001E7E  103C 000E               1547                MOVE.B  #14,D0
00001E82  4E4F                    1548                TRAP    #15
00001E84  43F9 00004234           1549                LEA     done_msg,A1
00001E8A  103C 000E               1550                MOVE.B  #14,D0
00001E8E  4E4F                    1551                TRAP    #15
00001E90  103C 0009               1552                MOVE.B  #9,D0         *indicate end of simulation
00001E94  4E4F                    1553                TRAP    #15
00001E96                          1554                
00001E96  43F9 0000420A           1555  addr_err      LEA     bad_addr,A1   *load the error msg into A1
00001E9C  103C 000E               1556                MOVE.B  #14,D0       *indicate output
00001EA0  4E4F                    1557                TRAP    #15
00001EA2  43F9 0000416C           1558                LEA     nl,A1        *load new line into A1
00001EA8  103C 000E               1559                MOVE.B  #14,D0        *indicate output
00001EAC  4E4F                    1560                TRAP    #15
00001EAE  4282                    1561                CLR.L   D2            *reset msb index for further iterations
00001EB0                          1562               * BRA     disp_msg      *go back to welcome msg
00001EB0                          1563                           
00001EB0  43F9 0000415E           1564  fatal_err     LEA     imm_sign,A1   *load the error msg into A1
00001EB6  103C 000E               1565                MOVE.B  #14,D0       *indicate output
00001EBA  4E4F                    1566                TRAP    #15
00001EBC  43F9 0000416C           1567                LEA     nl,A1        *load new line into A1
00001EC2  103C 000E               1568                MOVE.B  #14,D0        *indicate output
00001EC6  4E4F                    1569                TRAP    #15
00001EC8  4282                    1570                CLR.L   D2            *reset msb index for further iterations
00001ECA  60AC                    1571                BRA     done         *go back to welcome msg
00001ECC                          1572                
00001ECC                          1573  *-------------------------------------------------------------------------------------------------------------------------------------------              
00004000                          1574  data          ORG     $4000
00004000                          1575                
00004000                          1576  *string table for converting user input addresses from ascii to hex      
00004000= 30 00                   1577  string_tbl    DC.B    $30,$0      *{ascii,hex}
00004002= 31 01                   1578                DC.B    $31,$1          
00004004= 32 02                   1579                DC.B    $32,$2 
00004006= 33 03                   1580                DC.B    $33,$3
00004008= 34 04                   1581                DC.B    $34,$4
0000400A= 35 05                   1582                DC.B    $35,$5
0000400C= 36 06                   1583                DC.B    $36,$6
0000400E= 37 07                   1584                DC.B    $37,$7
00004010= 38 08                   1585                DC.B    $38,$8
00004012= 39 09                   1586                DC.B    $39,$9            
00004014= 41 0A                   1587                DC.B    $41,$A
00004016= 42 0B                   1588                DC.B    $42,$B
00004018= 43 0C                   1589                DC.B    $43,$C
0000401A= 44 0D                   1590                DC.B    $44,$D
0000401C= 45 0E                   1591                DC.B    $45,$E
0000401E= 46 0F                   1592                DC.B    $46,$F
00004020                          1593                
00004020                          1594               *hex_1
00004020                          1595               *contains first hex digit of the instruction with corresponding mappings
00004020                          1596               *also contains all supported instructions in the comment field
00004020                          1597                * 1 means the mapping is ambiguous (and we have to read more bits in instruction) 0 means its not.
00004020                          1598                * -1 means the instruction isnt one that can be disassembled in this program             
00004020= 01 01                   1599  hex_1         DC.B    $01,$01  * 'MOVE.B','MOVEA.B'
00004022= 03 01                   1600                DC.B    $03,$01  * 'MOVE.W','MOVEA.W'
00004024= 02 01                   1601                DC.B    $02,$01  * 'MOVEA.L','MOVEA.L'
00004026= 04 01                   1602                DC.B    $04,$01  * 'MOVEM','LEA','NEG','JSR','RTS','NOP'
00004028= 0D 01                   1603                DC.B    $0D,$01  * 'ADD','ADDA'
0000402A= 00 01                   1604                DC.B    $00,$01  * 'ORI','BCLR','CMPI','ADDI','EORI','SUBI'
0000402C= 0B 01                   1605                DC.B    $0B,$01  * 'EOR','CMP'
0000402E= 0E 00                   1606                DC.B    $0E,$00  * 'LSR','LSL','ASR','ASL','ROL','ROR'   
00004030= 06 00                   1607                DC.B    $06,$00  * Bcc('BCS','BGE','BLT','BVC','BRA') 
00004032= 09 00                   1608                DC.B    $09,$00  * 'SUB','SUBA' (determined in SUB)
00004034= 05 01                   1609                DC.B    $05,$01  * 'SUBQ','ADDQ'
00004036= 0C 00                   1610                DC.B    $0C,$00  * 'MULS'
00004038= 08 01                   1611                DC.B    $08,$01  * 'OR','DIVS(word)'
0000403A= FF FF                   1612                DC.B    -1,-1    * unsupported instruction-first hex val is not one in the table above
0000403C                          1613  
0000403C                          1614  *below table holds ascii codes for instruction printing
0000403C                          1615  *MOVEA         DC.L    'MOVEA',0
0000403C                          1616  *MOVEM         DC.L    'MOVEM',0              
0000403C= 4D4F5600 00000000       1617  MOV           DC.L    'MOV',0
00004044= 4C454100 00000000       1618  LEA           DC.L    'LEA',0
0000404C= 4E454700 00000000       1619  NEG           DC.L    'NEG',0 
00004054= 4A535200 00000000       1620  JSR           DC.L    'JSR',0
0000405C= 52545300 00000000       1621  RTS           DC.L    'RTS',0
00004064= 4E4F5000 00000000       1622  NOP           DC.L    'NOP',0
0000406C= 41444400 00000000       1623  ADD           DC.L    'ADD',0
00004074= 42434C00 00000000       1624  BCL           DC.L    'BCL',0
0000407C                          1625  *ADDA          DC.L    'ADDA',0
0000407C= 4F524900 00000000       1626  ORI           DC.L    'ORI',0
00004084                          1627  *BCLR          DC.L    'BCLR',0
00004084                          1628  *CMPI          DC.L    'CMPI',0
00004084= 454F5200 00000000       1629  EOR           DC.L    'EOR',0
0000408C= 434D5000 00000000       1630  CMP           DC.L    'CMP',0
00004094= 4C535200 00000000       1631  LSR           DC.L    'LSR',0
0000409C= 4C534C00 00000000       1632  LSL           DC.L    'LSL',0
000040A4= 41535200 00000000       1633  ASR           DC.L    'ASR',0
000040AC= 41534C00 00000000       1634  ASL           DC.L    'ASL',0
000040B4= 524F4C00 00000000       1635  ROL           DC.L    'ROL',0
000040BC= 524F5200 00000000       1636  ROR           DC.L    'ROR',0
000040C4= 42435300 00000000       1637  BCS           DC.L    'BCS',0
000040CC= 42474500 00000000       1638  BGE           DC.L    'BGE',0
000040D4= 424C5400 00000000       1639  BLT           DC.L    'BLT',0
000040DC= 42564300 00000000       1640  BVC           DC.L    'BVC',0
000040E4= 42524100 00000000       1641  BRA           DC.L    'BRA',0
000040EC= 53554200 00000000       1642  SUB           DC.L    'SUB',0
000040F4= 4D554C00 00000000       1643  MUL           DC.L    'MUL',0
000040FC= 44495600 00000000       1644  DIV           DC.L    'DIV',0
00004104= 4F520000 00000000       1645  OR            DC.L    'OR',0
0000410C= 44415400 00000000       1646  DAT           DC.L    'DAT',0   *DATA
00004114= 494E5600 00000000       1647  INV           DC.L    'INV',0   *used for displaying unsupported addressing modes e.g --  MOVE.L 8(A4,D0),5(A4)
0000411C                          1648  
0000411C                          1649  *below holds extended codes to append to the instruction
0000411C= 41 00                   1650  A             DC.B    'A',0
0000411E= 49 00                   1651  I             DC.B    'I',0
00004120= 52 00                   1652  R             DC.B    'R',0
00004122= 4D 00                   1653  M             DC.B    'M',0
00004124= 51 00                   1654  Q             DC.B    'Q',0
00004126= 53 00                   1655  S             DC.B    'S',0
00004128= 45 00                   1656  E             DC.B    'E',0
0000412A= 454D 0000               1657  EM            DC.W    'EM',0
0000412E= 4541 0000               1658  EA            DC.W    'EA',0
00004132                          1659  
00004132                          1660  *below holds ascii size strings to load to variable SIZECODE            
00004132= 2E42 0000               1661  SIZEB         DC.W    '.B',00
00004136= 2E57 0000               1662  SIZEW         DC.W    '.W',0
0000413A= 2E4C 0000               1663  SIZEL         DC.W    '.L',00
0000413E                          1664  SIZECODE      DS.L    1
00004142                          1665  
00004142                          1666  *below establishes lengths of data units
00004142  =00000001               1667  byte_len      EQU     1
00004142  =00000002               1668  word_len      EQU     2
00004142  =00000004               1669  long_len      EQU     4            
00004142                          1670                
00004142                          1671  * holds the condition of each branch                
00004142= 05                      1672  bcc_tbl       DC.B    %0101 *BCS
00004143= 0C                      1673                DC.B    %1100 *BGE
00004144= 0D                      1674                DC.B    %1101 *BLT
00004145= 08                      1675                DC.B    %1000 *BVC
00004146= 00                      1676                DC.B    %0000 *BRA     
00004147= FF                      1677                DC.B    -1    *invalid branch type
00004148                          1678                
00004148                          1679  *below holds shift counts for arithmetic/logical shifts
00004148= 00                      1680  shift_tbl     DC.B    %000
00004149= 01                      1681                DC.B    %001
0000414A= 02                      1682                DC.B    %010
0000414B= 03                      1683                DC.B    %011
0000414C= 04                      1684                DC.B    %100
0000414D= 05                      1685                DC.B    %101
0000414E= 06                      1686                DC.B    %110
0000414F= 07                      1687                DC.B    %111                              
00004150                          1688  
00004150                          1689  *below variables hold the name of the instruction
00004150                          1690  INST_NAME     DS.L    2         *holds the instruction to be printed (e.g. ADD.L; MOVE.B)
00004158                          1691  INST_NAME_EXT DS.L    1         *holds any part of instruction over 32 bits (eg last M in MOVEM)
0000415C                          1692  
0000415C                          1693  *below characters are used for printing
0000415C= 24 00                   1694  addr_sign     DC.B    '$',0
0000415E= 23 00                   1695  imm_sign      DC.B    '#',0
00004160= 28 00                   1696  open_paren    DC.B    '(',0
00004162= 29 00                   1697  closed_paren  DC.B    ')',0
00004164= 2B 00                   1698  plus_sign     DC.B    '+',0
00004166= 2D 00                   1699  neg_sign      DC.B    '-',0
00004168= 2C 00                   1700  comma         DC.B    ',',0
0000416A= 2F 00                   1701  dash_sign     DC.B    '/',0
0000416C= 0D 0A 00                1702  nl            DC.B    '',CR,LF,0
0000416F= 20 20 20 20 00          1703  space         DC.B    '    ',0
00004174                          1704  
00004174                          1705  *below holds intro messages to user                       
00004174= 50 6C 65 61 73 65 ...   1706  display_start DC.B    'Please enter a maximum 32-bit starting memory address in hex (-1 to quit): ',0
000041C0= 50 6C 65 61 73 65 ...   1707  display_end   DC.B    'Please enter a maximum 32-bit ending memory address in hex (-1 to quit): ',0
0000420A= 50 6C 65 61 73 65 ...   1708  bad_addr      DC.B    'Please enter a valid address',CR,LF,0
00004229                          1709  
00004229                          1710  
00004229                          1711  *below variables store the starting and ending addresses the user provides
0000422A                          1712  user_start    DS.L    1
0000422E                          1713  user_end      DS.L    1
00004232                          1714  
00004232= 2D31                    1715  exit_val      DC.W    $2D31  *sentinel exit value
00004234                          1716               
00004234= 64 6F 6E 65 00          1717  done_msg      DC.B    'done',0
00004239                          1718  
00004239                          1719  
00004239                          1720                END     start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A                   411C
A0_MESS             1D24
A1_MESS             1D36
A2_MESS             1D48
A3_MESS             1D5A
A4_MESS             1D6C
A5_MESS             1D7E
A6_MESS             1D90
A7_MESS             1DA2
ADD                 406C
ADDA_BEG            12F6
ADDA_HANDLER        12EC
ADDA_LONG_HANDLER   131C
ADDA_SAVE_DATA      132A
ADDA_WORD_HANDLER   130A
ADDI_HANDLER        16A2
ADDQ_HANDLER        158A
ADDRESS_MODE        1B0A
ADDR_ERR            1E96
ADDR_SIGN           415C
ADD_HANDLER         1430
ASL                 40AC
ASL_HANDLER         193E
ASR                 40A4
ASR_HANDLER         189E
BAD_ADDR            420A
BCC_CALC            183A
BCC_COMPLETE        184E
BCC_COND            17A2
BCC_DETERMINER      17B2
BCC_DISPM           1820
BCC_HANDLER         1796
BCC_LONG_HANDLER    184A
BCC_TBL             4142
BCC_WORD_HANDLER    1846
BCL                 4074
BCLR_DYNAMIC        1648
BCLR_STATIC         161E
BCS                 40C4
BCS_HANDLER         17DE
BGE                 40CC
BGE_HANDLER         17EC
BLT                 40D4
BLT_HANDLER         17FA
BRA                 40E4
BRA_HANDLER         1816
BVC                 40DC
BVC_HANDLER         1808
BYTE_LEN            1
CASE_QUICK8         1584
CHECK_FIRST         1060
CLOSED_PARAN        1B56
CLOSED_PAREN        4162
CMP                 408C
CMPA_HANDLER        135E
CMPI_BYTE           15CA
CMPI_HANDLER        1598
CMPI_LONG           15EE
CMPI_RET            15FC
CMPI_WORD           15DC
CMP_HANDLER         147C
COMMA               4168
CR                  D
D0_MESS             1C94
D1_MESS             1CA6
D2_MESS             1CB8
D3_MESS             1CCA
D4_MESS             1CDC
D5_MESS             1CEE
D6_MESS             1D00
D7_MESS             1D12
DASH_SIGN           416A
DAT                 410C
DATA                4000
DATA_MODE           1C4A
DATA_MODE_PRINT     1C6C
DATA_REGISTER       1B12
DISPLAY_END         41C0
DISPLAY_START       4174
DISP_INSTR          1DA6
DIV                 40FC
DIVSW_BEG           14A2
DIVSW_HANDLER       148E
DONE                1E78
DONE_MSG            4234
DR_CMP              1B16
E                   4128
EA                  412E
EA_SRC              1AA4
EA_SRC_BEG          1AA0
EM                  412A
EOR                 4084
EORI_HANDLER        16D4
EOR_HANDLER         146A
EXIT_VAL            4232
FATAL_ERR           1EB0
FILTER_EA_MODE      1AD8
FLAG_SOURCE         18B2
GET_DATA            12AE
H2A_ITS             8
H2A_LOOP            1E14
H2A_MATCH           1E20
H2A_PREP            1E12
H2A_REGS            117A
H2A_RET             1E46
H2A_SWAP            1E42
HEX_1               4020
HEX_2_ASCII         1DFA
I                   411E
IMM_ASL             195C
IMM_ASR             18BC
IMM_LSL             1984
IMM_LSR             18E4
IMM_ROL             19AC
IMM_ROR             190C
IMM_SIGN            415E
INST_NAME           4150
INST_NAME_EXT       4158
INST_PARSE          10A8
INV                 4114
INVALID_MODE        1AFA
INV_HANDLER         1072
JSR                 4054
JSR_HANDLER         1A02
LEA                 4044
LEA_HANDLER         19CE
LF                  A
LONG_DATA_HANDLER   1C66
LONG_LEN            4
LONG_MODE           1C30
LSL                 409C
LSL_HANDLER         1966
LSR                 4094
LSR_HANDLER         18C6
M                   4122
MATCH_FOUND         109C
MOV                 403C
MOVEA_HANDLER       112A
MOVEM_AN            1A46
MOVEM_DN            1A6C
MOVEM_EA            1A74
MOVEM_HANDLER       1A2A
MOVEM_LONG          1A5E
MOVEM_WORD          1A50
MOVE_EA             1134
MOVE_HANDLER        111C
MUL                 40F4
MULS_HANDLER        14C8
NEG                 404C
NEG_BYTE            1760
NEG_HANDLER         1738
NEG_LONG            177C
NEG_RET             1786
NEG_SIGN            4166
NEG_WORD            176E
NL                  416C
NOP                 4064
NOP_HANDLER         12D6
OPEN_PAREN          4160
OR                  4104
ORI                 407C
ORI_HANDLER         167A
OR_BYTE             13B6
OR_DN_LEFT          1394
OR_DN_RIGHT         138A
OR_EA               13E8
OR_HANDLER          136A
OR_LEFT_PRINT       1418
OR_LONG             13DA
OR_SIZE             139E
OR_WORD             13C8
PLUS_SIGN           4164
POSTFIX_PLUS        1BBA
PREFIX_MINUS        1BE8
PREP                1010
PREP_SRH_DISP       19CA
PRINT_A0            1D16
PRINT_A1            1D28
PRINT_A2            1D3A
PRINT_A3            1D4C
PRINT_A4            1D5E
PRINT_A5            1D70
PRINT_A6            1D82
PRINT_A7            1D94
PRINT_ADDR_SGN      1E62
PRINT_COMMA         1E4C
PRINT_D0            1C86
PRINT_D1            1C98
PRINT_D2            1CAA
PRINT_D3            1CBC
PRINT_D4            1CCE
PRINT_D5            1CE0
PRINT_D6            1CF2
PRINT_D7            1D04
PRINT_INNER_AN      1B7A
Q                   4124
Q_PRINTS            1562
R                   4120
REG_ASL             1952
REG_ASR             18B2
REG_LSL             197A
REG_LSR             18DA
REG_ROL             19A2
REG_ROR             1902
ROL                 40B4
ROL_HANDLER         198E
ROR                 40BC
ROR_HANDLER         18EE
RTS                 405C
RTS_HANDLER         1A8A
S                   4126
SAVE_SRH_DATA       19B6
SHIFT_TBL           4148
SIZEB               4132
SIZECODE            413E
SIZEL               413A
SIZEW               4136
SPACE               416F
STACK               7000
START               1000
START_ADDR          1000
STRING_TBL          4000
SUB                 40EC
SUBA_HANDLER        1352
SUBI_HANDLER        1706
SUBQ_BYTE           1514
SUBQ_DET            14EA
SUBQ_EA             154C
SUBQ_HANDLER        14E0
SUBQ_LONG           1538
SUBQ_WORD           1526
SUB_HANDLER         1446
USER_END            422E
USER_START          422A
WORD_DATA_HANDLER   1C60
WORD_LEN            2
WORD_MODE           1C16
_0_HANDLER          11FC
_11_CHECK           1252
_11_HANDLER         1242
_13_HANDLER         11E6
_1_HANDLER          10F2
_2_HANDLER          1188
_3_HANDLER          115E
_4_HANDLER          11B6
_5_HANDLER          129E
_8_CHECK            128C
_8_HANDLER          1270
_LEFT_HANDLER       1916
_RIGHT_HANDLER      1876
_SHIFT_ROLL_HANDLER  1866
