00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/16/2018 5:47:26 PM

00000000                             1  *-----------------------------------------------------------------------------------------------
00000000                             2  *                                  Disassembler program
00000000                             3  *                                      Winter 2018
00000000                             4  
00000000                             5  *               Written by : Sean Coulter, Corin Ennis, Antony Mbugua
00000000                             6  *               Description: A program to disassemble Motorola 68K source files
00000000                             7  *-----------------------------------------------------------------------------------------------            
00000000                             8              
00000000  =0000000D                  9  CR         EQU   $0D
00000000  =0000000A                 10  LF         EQU   $0A
00000000  =00007000                 11  stack      EQU   $7000
00000000  =00001000                 12  start_addr EQU   $1000
00000000                            13                
00001000                            14  start         ORG     start_addr             
00001000                            15                
00001000  4FF8 7000                 16                lea     stack,sp
00001004  DBFC 00012000             17                adda.l  #$12000,a5
0000100A  DDFC 00040000             18                adda.l  #$40000,a6
00001010                            19                
00001010                            20                
00001010                            21   *D1: sentinel exit value
00001010                            22   *D2: index of MSB
00001010                            23   *D3: length of user input string
00001010                            24   *D4: index of pointer to string table
00001010                            25   *D6: ascii value holding MSB
00001010                            26   *D7: max valid input
00001010                            27                
00001010  4244                      28                CLR      D4                 *register used in address calculation
00001012  4247                      29                CLR      D7                 *register used for address calculation
00001014                            30  
00001014  BDCD                      31  prep          CMPA.L   A5,A6              *have we read from start-end?
00001016  6D00 1020                 32                BLT      done               * yes-end            
0000101A  103C 0005                 33                MOVE.B   #5,D0              *pause for user to hit enter
0000101E  4E4F                      34                TRAP     #15
00001020  43F9 00004146             35                LEA      nl,A1              *make an new line
00001026  103C 000E                 36                MOVE.B   #14,D0
0000102A  4E4F                      37                TRAP     #15
0000102C  49F9 00004020             38                LEA      hex_1,A4           *pointer to hex_1 table in A4
00001032  227C 00000000             39                MOVEA.L  #0,A1              *clearing variables
00001038  23FC 00000000 00004118    40                MOVE.L   #0,SIZECODE
00001042  23FC 00000000 00004132    41                MOVE.L   #0,INST_NAME_EXT
0000104C                            42                *EOR      (A0),(A0)
0000104C  4280                      43                CLR.L    D0
0000104E  4281                      44                CLR.L    D1
00001050  4282                      45                CLR.L    D2
00001052  4283                      46                CLR.L    D3
00001054  4284                      47                CLR.L    D4
00001056  4285                      48                CLR.L    D5
00001058  4286                      49                CLR.L    D6
0000105A  4287                      50                CLR.L    D7            
0000105C  3215                      51                MOVE.W   (A5),D1            *move the instruction thats pointed to by starting address
0000105E  2641                      52                MOVE.L   D1,A3              *and copy it to A3
00001060  4841                      53                SWAP     D1
00001062  E999                      54                ROL.L    #4,D1              *isolate the first hex digit
00001064                            55               
00001064  B21C                      56  check_first   CMP.B   (A4)+,D1            *compare with the next value in the hex table
00001066  6700 0038                 57                BEQ     match_found         *theres a match with the value in the table
0000106A  524C                      58                ADDA    #1,A4               *increment the pointer to the table
0000106C  0C14 00FF                 59                CMP.B   #$FF,(A4)           *have we reached the end of the hex table?
00001070  6700 0004                 60                BEQ     inv_handler         * yes-no matches (so output DATA)
00001074  60EE                      61                BRA     check_first         *keep searching through the table for a match           
00001076                            62       
00001076                            63  *-----------------------------------------------------------------------------
00001076                            64  * inv_handler
00001076                            65  * handles unsupported instruction names
00001076                            66  * prints DATA for instruction name 
00001076                            67                  
00001076  23F9 000040E4 0000412A    68  inv_handler   MOVE.L  DAT,INST_NAME
00001080  23F9 000040F4 00004132    69                MOVE.L  A,INST_NAME_EXT
0000108A                            70                *MOVE.B  #12,D5
0000108A                            71                *ROL.L   D5,D1             *line up rest of the instruction
0000108A  4EB9 00001F28             72                JSR     disp_instr
00001090                            73                *MOVE.L  D1,A0
00001090  204B                      74                MOVE.L  A3,A0
00001092  4EB9 00001F7C             75                JSR     hex_2_ascii       *convert/display the unsupported opcode
00001098  DAFC 0002                 76                ADDA    #word_len,A5
0000109C  6000 FF76                 77                BRA     prep
000010A0                            78                
000010A0                            79  * /inv_handler
000010A0                            80  *-----------------------------------------------------------------------------
000010A0                            81  
000010A0                            82  **below functions handle instructions that are supported in this program**
000010A0                            83  
000010A0  0C14 0001                 84  match_found   CMP.B   #1,(A4)             *check if the mapping is ambiguous
000010A4  6700 0006                 85                BEQ     inst_parse          * it is- get the next hex digit
000010A8  6000 0266                 86                BRA     get_data            * its not-- just branch straight to the corresponding function
000010AC                            87                            
000010AC  B23C 0001                 88  inst_parse    CMP.B   #1,D1            *based on the first digit, decide how to decode next value.
000010B0  6700 0044                 89                BEQ     _1_handler
000010B4  B23C 0003                 90                CMP.B   #3,D1
000010B8  6700 00A8                 91                BEQ     _3_handler
000010BC  B23C 0002                 92                CMP.B   #2,D1
000010C0  6700 00CA                 93                BEQ     _2_handler
000010C4  B23C 0004                 94                CMP.B   #4,D1
000010C8  6700 00F0                 95                BEQ     _4_handler
000010CC  B23C 000D                 96                CMP.B   #13,D1
000010D0  6700 0166                 97                BEQ     _13_handler
000010D4  B23C 0000                 98                CMP.B   #0,D1
000010D8  6700 0174                 99                BEQ     _0_handler
000010DC  B23C 000B                100                CMP.B   #11,D1
000010E0  6700 01B2                101                BEQ     _11_handler
000010E4  B23C 0008                102                CMP.B   #8,D1
000010E8  6700 01E8                103                BEQ     _8_handler
000010EC  B23C 0005                104                CMP.B   #5,D1
000010F0  6700 020E                105                BEQ     _5_handler
000010F4  6080                     106                BRA     inv_handler
000010F6                           107  
000010F6                           108  *The following functions determine where to go if the first hex value is shared between instructions             
000010F6                           109  *---------------           
000010F6  4201                     110  _1_handler    CLR.B   D1
000010F8  23F9 0000403C 0000412A   111                MOVE.L  MOV,INST_NAME
00001102  23F9 0000410C 00004118   112                MOVE.L  SIZEB,SIZECODE
0000110C  14BC 0000                113                MOVE.B  #0,(A2)        *flag data as byte
00001110  E799                     114                ROL.L   #3,D1          *isolate dest. An or Dn bits (t.b.d. if MOVE or MOVEA)
00001112  1401                     115                MOVE.B  D1,D2          *and move them to D2
00001114  4201                     116                CLR.B   D1
00001116  E799                     117                ROL.L   #3,D1          *isolate dest. mode bits in D1.B
00001118  B23C 0001                118                CMP.B   #1,D1          *is mode == 001?
0000111C  6700 0010                119                BEQ     movea_handler * yes- its movea
00001120                           120                
00001120  23F9 00004102 00004132   121  move_handler MOVE.L  E,INST_NAME_EXT
0000112A  6000 000C                122               BRA     move_ea
0000112E                           123  
0000112E  23F9 00004108 00004132   124  movea_handler MOVE.L EA,INST_NAME_EXT     
00001138                           125  
00001138  1801                     126  move_ea       MOVE.B D1,D4         *save dest mode bits to D4
0000113A  4201                     127                CLR.B  D1
0000113C  E799                     128                ROL.L  #3,D1
0000113E  2601                     129                MOVE.L D1,D3         *save source mode/reg bits in D3
00001140  4EB9 00001F28            130                JSR    disp_instr    *print MOVEA.(X) or MOVE.(X)
00001146  4EB9 00001C22            131                JSR    EA_SRC_beg    *print source information
0000114C                           132                
0000114C  E69A                     133                ROR.L  #3,D2         *roll dest register bits to left fringe
0000114E  1404                     134                MOVE.B D4,D2         *move dest mode bits to right fringe
00001150  2602                     135                MOVE.L D2,D3         *move these same bits to D3
00001152  4EB9 00001FE0            136                JSR    print_comma
00001158  4EB9 00001C26            137                JSR    EA_SRC        *prints destination mode/register
0000115E  6000 FEB4                138                BRA    prep
00001162                           139  
00001162                           140  *--------------- 
00001162                           141  *---------------
00001162  4201                     142  _3_handler    CLR.B   D1
00001164  23F9 0000403C 0000412A   143                MOVE.L  MOV,INST_NAME
0000116E  23F9 00004110 00004118   144                MOVE.L  SIZEW,SIZECODE
00001178  14BC 0001                145                MOVE.B  #1,(A2)        *flag data as word
0000117C  E799                     146                ROL.L   #3,D1          *isolate dest. An or Dn bits (t.b.d. if MOVE or MOVEA)
0000117E  1401                     147                MOVE.B  D1,D2          *and move them to D2
00001180  4201                     148                CLR.B   D1
00001182  E799                     149                ROL.L   #3,D1          *isolate dest. mode bits in D1.B
00001184  B23C 0001                150                CMP.B   #1,D1          *is mode == 001?
00001188  67A4                     151                BEQ     movea_handler * yes- its movea (function is subset of _1_handler)
0000118A  6094                     152                BRA     move_handler  * no- its move (function is subset of _1_handler)
0000118C                           153                
0000118C                           154  *--------------- 
0000118C                           155  *--------------- 
0000118C  4201                     156  _2_handler    CLR.B   D1
0000118E  23F9 0000403C 0000412A   157                MOVE.L  MOV,INST_NAME
00001198  23F9 00004114 00004118   158                MOVE.L  SIZEL,SIZECODE
000011A2  14BC 0002                159                MOVE.B  #2,(A2)        *flag data as long
000011A6  E799                     160                ROL.L   #3,D1          *isolate dest. An or Dn bits (t.b.d. if MOVE or MOVEA)
000011A8  1401                     161                MOVE.B  D1,D2          *and move them to D2
000011AA  4201                     162                CLR.B   D1
000011AC  E799                     163                ROL.L   #3,D1          *isolate dest. mode bits in D1.B
000011AE  B23C 0001                164                CMP.B   #1,D1          *is mode == 001?
000011B2  6700 FF7A                165                BEQ     movea_handler * yes- its movea (function is subset of _1_handler)
000011B6  6000 FF68                166                BRA     move_handler  * no- its move (function is subset of _1_handler)
000011BA                           167  
000011BA                           168  *--------------- 
000011BA                           169  *--------------- 
000011BA  B6FC 4E71                170  _4_handler    CMP.W   #$4E71,A3        *is it nop
000011BE  6700 0178                171                BEQ     nop_handler      * its nop
000011C2  B6FC 4E75                172                CMP.W   #$4E75,A3        *is it rts
000011C6  6700 0A44                173                BEQ     rts_handler      * its rts
000011CA  4201                     174                CLR.B   D1               *get byte space ready for next digit
000011CC  E999                     175                ROL.L   #4,D1            *get the next digit
000011CE  2401                     176                MOVE.L  D1,D2            *make a temp copy
000011D0  E59A                     177                ROL.L   #2,D2            *get another 3 bits
000011D2  B43C 003A                178                CMP.B   #$3A,D2          *is 3A in the byte position
000011D6  6700 08DE                179                BEQ     jsr_handler      * yes its jsr
000011DA  B23C 0004                180                CMP.B   #4,D1            *is the next digit 4
000011DE  6700 0006                181                BEQ     neg_resolve      * neg or MOVE to CCR
000011E2  6000 0012                182                BRA     _4_resolve       *now its either lea,movem,unsupported
000011E6  4202                     183  neg_resolve   CLR.B   D2
000011E8  E51A                     184                ROL.B   #2,D2
000011EA  B43C 0003                185                CMP.B   #3,D2
000011EE  6D00 05E2                186                BLT     neg_handler
000011F2  6000 FE82                187                BRA     inv_handler                                       
000011F6  2401                     188  _4_resolve    MOVE.L  D1,D2            *make a full copy to D2
000011F8  2801                     189                MOVE.L  D1,D4            *make another full copy
000011FA  E20A                     190                LSR.B   #1,D2            *lea and movem differentiated by current MSB        
000011FC  6500 0006                191                BCS     lea_resolve      * carry set- lea or unsupported
00001200  6000 0012                192                BRA     movem_resolve    * carry not set-movem or unsupported
00001204  E59A                     193  lea_resolve   ROL.L   #2,D2            *lea is unique in bits d8 to d6. use previous copy D2
00001206  EB0A                     194                LSL.B   #5,D2            *shift out 0 pad and remaining An bits
00001208  B43C 00E0                195                CMP.B   #$E0,D2          *is result 11100000?
0000120C  6700 0874                196                BEQ     lea_handler      * lea
00001210  6000 FE64                197                BRA     inv_handler      * unsupported
00001214  E39C                     198  movem_resolve ROL.L   #1,D4
00001216  B83C 0019                199                CMP.B   #25,D4
0000121A  6600 0012                200                BNE     movem_check      *last check on movem
0000121E  4204                     201  is_it_movem   CLR.B   D4               *this is either MOVEM register to memory or EXT
00001220  E79C                     202                ROL.L   #3,D4            *get ea mode into d2
00001222  B83C 0000                203                CMP.B   #0,D4            *is the ea mode 000?
00001226  6700 FE4E                204                BEQ     inv_handler      * yes-ea mode is data register-- cant be movem
0000122A  6000 08AA                205                BRA     movem_handler    * no-its movem
0000122E                           206                
0000122E  B83C 0011                207  movem_check   CMP.B   #17,D4          
00001232  6600 FE42                208                BNE     inv_handler      *we can be sure its not movem now
00001236  60E6                     209                BRA     is_it_movem      *EXT or MOVEM
00001238                           210                        
00001238                           211  *--------------- 
00001238                           212  *--------------- 
00001238  4201                     213  _13_handler     CLR.B   D1
0000123A  E999                     214                  ROL.L   #4,D1
0000123C  2401                     215                  MOVE.L  D1,D2          *make a copy
0000123E  4202                     216                  CLR.B   D2             *clear byte space for next roll
00001240  E59A                     217                  ROL.L   #2,D2          *get size bits
00001242  B43C 0003                218                  CMP.B   #3,D2          *are size bits 11?
00001246  6700 0106                219                  BEQ     adda_handler
0000124A  6000 0246                220                  BRA     add_handler
0000124E                           221  
0000124E                           222  *--------------- 
0000124E                           223  *--------------- 
0000124E  4201                     224  _0_handler      CLR.B D1
00001250  E999                     225                  ROL.L #4,D1         *the next 4 bits will determine the instruction exactly
00001252  B23C 0000                226                  CMP.B #0,D1
00001256  6700 04B0                227                  BEQ   ori_handler
0000125A  B23C 0004                228                  CMP.B #4,D1
0000125E  6700 0540                229                  BEQ   subi_handler
00001262  B23C 000A                230                  CMP.B #$A,D1
00001266  6700 0506                231                  BEQ   eori_handler
0000126A  B23C 0008                232                  CMP.B #8,D1
0000126E  6700 0410                233                  BEQ   bclr_static
00001272  B23C 000C                234                  CMP.B #$C,D1
00001276  6700 0382                235                  BEQ   cmpi_handler
0000127A  B23C 0006                236                  CMP.B #6,D1
0000127E  6700 04BC                237                  BEQ   addi_handler
00001282                           238                                      *at this point its BCLR or its unsupported
00001282  2401                     239                  MOVE.L D1,D2        *make a copy
00001284  4202                     240                  CLR.B  D2
00001286  E59A                     241                  ROL.L  #2,D2        *get next 2 hardcoded bits
00001288  B43C 0002                242                  CMP.B  #2,D2        *BCLR bits defined as 10
0000128C  6700 043E                243                  BEQ    bclr_dynamic  *BCLR with a Dn (dynamic)
00001290  6000 FDE4                244                  BRA    inv_handler   *unsupported instruction
00001294                           245  
00001294                           246  *--------------- 
00001294                           247  *--------------- 
00001294  4201                     248  _11_handler     CLR.B   D1          
00001296  E999                     249                  ROL.L   #4,D1      *get next hex digit
00001298  2401                     250                  MOVE.L  D1,D2      *make a temp copy
0000129A  E20A                     251                  LSR.B   #1,D2      * eor and cmp can be differentiated by lsb in 2nd digit. check carry
0000129C  6500 0006                252                  BCS     _11_resolve  *check if its eor,cpma(long), or cmpm(unsupported)
000012A0  6000 0020                253                  BRA     cmpa_or_cmp  *its cmp or cmpa
000012A4  2401                     254  _11_resolve     MOVE.L  D1,D2       *make a copy
000012A6  4202                     255                  CLR.B   D2
000012A8  E59A                     256                  ROL.L   #2,D2
000012AA  B43C 0003                257                  CMP.B   #3,D2
000012AE  6700 0110                258                  BEQ     cmpa_handler    *its cmpa (long)
000012B2  4202                     259                  CLR.B   D2              *down to eor or cmpm
000012B4  E79A                     260                  ROL.L   #3,D2           *get EA mode
000012B6  B43C 0001                261                  CMP.B   #1,D2
000012BA  6700 FDBA                262                  BEQ     inv_handler     *cmpm
000012BE  6000 020C                263                  BRA     eor_handler     *eor
000012C2  4202                     264  cmpa_or_cmp     CLR.B   D2
000012C4  E59A                     265                  ROL.L   #2,D2           *get the size code
000012C6  B43C 0003                266                  CMP.B   #3,D2           *whats the size code
000012CA  6700 00F4                267                  BEQ     cmpa_handler    * size code 11-cmpa
000012CE  6000 020E                268                  BRA     cmp_handler     * size code !11-cmp
000012D2                           269  
000012D2                           270  *---------------
000012D2                           271  *---------------
000012D2  4201                     272  _8_handler      CLR.B   D1
000012D4  E999                     273                  ROL.L   #4,D1
000012D6  2401                     274                  MOVE.L  D1,D2
000012D8  E20A                     275                  LSR.B   #1,D2
000012DA  6500 0012                276                  BCS     _8_check              
000012DE  4202                     277                  CLR.B   D2                  *carry not set- OR or DIVU
000012E0  E59A                     278                  ROL.L   #2,D2
000012E2  B43C 0003                279                  CMP.B   #3,D2
000012E6  6700 FD8E                280                  BEQ     inv_handler         *DIVU
000012EA  6000 00E0                281                  BRA     or_handler
000012EE                           282                  
000012EE  4202                     283  _8_check        CLR.B   D2                  *its OR, DIVS, or SBCD
000012F0  E59A                     284                  ROL.L   #2,D2
000012F2  B43C 0003                285                  CMP.B   #3,D2
000012F6  6700 01F8                286                  BEQ     divsw_handler       *between or and divs.w, only divs.w can have a size 11
000012FA  4202                     287                  CLR.B   D2
000012FC  6000 00CE                288                  BRA     or_handler
00001300                           289                      
00001300                           290  *---------------
00001300                           291  *--------------- 
00001300  4201                     292  _5_handler      CLR.B   D1
00001302  E999                     293                  ROL.L   #4,D1
00001304  1401                     294                  MOVE.B  D1,D2               *D2 now holds the immediate data
00001306  E20A                     295                  LSR.B   #1,D2               *check if carry is set-- this will determine branch
00001308  6500 0238                296                  BCS     subq_handler
0000130C  6000 02DE                297                  BRA     addq_handler
00001310                           298                  
00001310                           299  *---------------
00001310                           300  *--------------- 
00001310                           301  
00001310                           302  *we can go directly to the function since the first hex val maps directly to an instruction
00001310  B23C 0006                303  get_data      CMP.B   #6,D1
00001314  6700 051A                304                BEQ     bcc_handler
00001318  B23C 000E                305                CMP.B   #$E,D1
0000131C  6700 05E2                306                BEQ     _shift_roll_handler
00001320  B23C 0009                307                CMP.B   #9,D1
00001324  6700 0182                308                BEQ     sub_handler
00001328  B23C 0005                309                CMP.B   #5,D1
0000132C  6700 0214                310                BEQ     subq_handler
00001330  B23C 000C                311                CMP.B   #$C,D1
00001334  6700 01F4                312                BEQ     muls_handler
00001338                           313  *----------------------------------------------------------------------------
00001338                           314  *----------------------------------------------------------------------------              
00001338                           315  *----------------------------------------------------------------------------
00001338                           316  *nop_handler
00001338                           317  *handles 'NOP'
00001338                           318  
00001338  23F9 00004064 0000412A   319  nop_handler   MOVE.L  NOP,INST_NAME 
00001342  544D                     320                ADDA    #2,A5         *nop took up a word- set A5 to the next instruction
00001344  4EB9 00001F28            321                JSR     disp_instr
0000134A  6000 FCC8                322                BRA     prep
0000134E                           323  
0000134E                           324  * /nop_handler
0000134E                           325  *----------------------------------------------------------------------------
0000134E                           326  
0000134E                           327  
0000134E                           328  *----------------------------------------------------------------------------
0000134E                           329  *adda_handler
0000134E                           330  *handles 'ADDA'
0000134E                           331  
0000134E  23F9 0000406C 0000412A   332  adda_handler       MOVE.L ADD,INST_NAME  *we know its valid instr ADDA
00001358  33F9 000040F4 00004132   333  adda_beg           MOVE.W A,INST_NAME_EXT
00001362  E209                     334                     LSR.B  #1,D1                *send the size bit to carry
00001364  6500 0018                335                     BCS    adda_long_handler    *carry is set->ADDA.W
00001368  6000 0002                336                     BRA    adda_word_handler    *carry not set->ADDA.L
0000136C                           337                     
0000136C  23F9 00004110 00004118   338  adda_word_handler  MOVE.L SIZEW,SIZECODE
00001376  14BC 0001                339                     MOVE.B #1,(A2)
0000137A  6000 0010                340                     BRA    adda_save_data
0000137E                           341                     
0000137E  23F9 00004114 00004118   342  adda_long_handler  MOVE.L SIZEL,SIZECODE
00001388  14BC 0002                343                     MOVE.B #2,(A2)
0000138C                           344                              
0000138C  4EB9 00001F28            345  adda_save_data     JSR    disp_instr
00001392  1A01                     346                     MOVE.B D1,D5             *move the 3 An bits to D5 temporarily
00001394  E599                     347                     ROL.L  #2,D1             *get hardcoded size bits
00001396  4201                     348                     CLR.B  D1                *and clear the byte space
00001398  E799                     349                     ROL.L  #3,D1
0000139A  2601                     350                     MOVE.L D1,D3             *send EA bits to D3
0000139C  4EB9 00001C22            351                     JSR    EA_SRC_beg
000013A2  4EB9 00001FE0            352                     JSR    print_comma
000013A8  C745                     353                     EXG    D3,D5             *send An bits to D3 for function call
000013AA  4EB9 00001CFC            354                     JSR    PRINT_INNER_An
000013B0  6000 FC62                355                     BRA    prep                     
000013B4                           356  
000013B4                           357  * /adda_handler
000013B4                           358  *----------------------------------------------------------------------------
000013B4                           359  
000013B4                           360  
000013B4                           361  *-----------------------------------------------------------------------------
000013B4                           362  * suba_handler
000013B4                           363  * handles 'SUBA'
000013B4                           364  
000013B4                           365  *uses adda_handler due to similar bit layout
000013B4                           366  
000013B4  23F9 000040C8 0000412A   367  suba_handler       MOVE.L   SUB,INST_NAME
000013BE  6098                     368                     BRA      adda_beg
000013C0                           369  
000013C0                           370  * /suba_handler
000013C0                           371  *-----------------------------------------------------------------------------
000013C0                           372  
000013C0                           373  
000013C0                           374  *-----------------------------------------------------------------------------
000013C0                           375  * cmpa_handler
000013C0                           376  * handles 'CMPA'
000013C0                           377  
000013C0                           378  *uses adda_handler due to similar bit layout
000013C0                           379  
000013C0  23F9 0000408C 0000412A   380  cmpa_handler       MOVE.L   CMP,INST_NAME
000013CA  608C                     381                     BRA      adda_beg
000013CC                           382  
000013CC                           383  * /cmpa_handler
000013CC                           384  *-----------------------------------------------------------------------------
000013CC                           385  
000013CC                           386  
000013CC                           387  *-----------------------------------------------------------------------------
000013CC                           388  *or_handler
000013CC                           389  *handles 'OR'
000013CC                           390  
000013CC                           391  *D7 holds the direction flag
000013CC                           392  *D5 holds source/destination bits
000013CC                           393  *D4 holds the 2 size bits
000013CC                           394  *D3 holds the parameters used for jumps to EA handlers
000013CC                           395  
000013CC                           396  *Dn_left means the Dn is the dest
000013CC                           397  *Dn_right means the Dn is the source
000013CC                           398  
000013CC  E59A                     399  or_handler     ROL.L    #2,D2
000013CE  B43C 0000                400                 CMP.B    #0,D2
000013D2  6700 FCA2                401                 BEQ      inv_handler    *SBCD
000013D6  23F9 000040E0 0000412A   402                 MOVE.L   OR,INST_NAME
000013E0  E209                     403                 LSR.B    #1,D1          *shift the direction bit to carry-- D1 now also holds the data register of the operation
000013E2  1A01                     404                 MOVE.B   D1,D5          *move source/destination (undertermined) Dn bits to D5
000013E4  6500 0006                405                 BCS      or_Dn_right    * <ea> OR Dn
000013E8  6000 000C                406                 BRA      or_Dn_left     * Dn OR <ea>
000013EC                           407                 
000013EC  4201                     408  or_Dn_right    CLR.B    D1
000013EE  E599                     409                 ROL.L    #2,D1
000013F0  1801                     410                 MOVE.B   D1,D4          *D4 holds the size of the operation
000013F2  6000 000C                411                 BRA      or_size
000013F6                           412  
000013F6  1E3C 0001                413  or_Dn_left     MOVE.B   #1,D7          *flag operation as Dn_left
000013FA  4201                     414                 CLR.B    D1
000013FC  E599                     415                 ROL.L    #2,D1
000013FE  1801                     416                 MOVE.B   D1,D4          *D4 holds the size of the operation
00001400  B83C 0000                417  or_size        CMP.B    #0,D4
00001404  6700 0012                418                 BEQ      or_byte
00001408  B83C 0001                419                 CMP.B    #1,D4
0000140C  6700 001C                420                 BEQ      or_word
00001410  B83C 0002                421                 CMP.B    #2,D4
00001414  6700 0026                422                 BEQ      or_long
00001418                           423                 
00001418  23F9 0000410C 00004118   424  or_byte        MOVE.L   SIZEB,SIZECODE
00001422  14BC 0000                425                 MOVE.B   #0,(A2)        *flag data as byte sized
00001426  6000 0022                426                 BRA      or_ea
0000142A                           427  
0000142A  23F9 00004110 00004118   428  or_word        MOVE.L   SIZEW,SIZECODE
00001434  14BC 0001                429                 MOVE.B   #1,(A2)        *flag data as word sized
00001438  6000 0010                430                 BRA      or_ea
0000143C                           431  
0000143C  23F9 00004114 00004118   432  or_long        MOVE.L   SIZEL,SIZECODE
00001446  14BC 0002                433                 MOVE.B   #2,(A2)        *flag data as long sized
0000144A                           434  
0000144A  4EB9 00001F28            435  or_ea          JSR      disp_instr
00001450  4201                     436                 CLR.B    D1
00001452  E799                     437                 ROL.L    #3,D1          *D1 holds the EA bits         
00001454  2601                     438                 MOVE.L   D1,D3          *move EA source bits to D3
00001456  BE3C 0001                439                 CMP.B    #1,D7
0000145A  6700 001E                440                 BEQ      or_left_print
0000145E  2C03                     441                 MOVE.L   D3,D6          *temp store D3 bits in D6 for next function call
00001460  2605                     442                 MOVE.L   D5,D3
00001462  4EB9 00001C98            443                 JSR      DR_CMP         *print Dn bits
00001468  4EB9 00001FE0            444                 JSR      print_comma
0000146E  2606                     445                 MOVE.L   D6,D3
00001470  4EB9 00001C22            446                 JSR      EA_SRC_beg
00001476  6000 FB9C                447                 BRA      prep
0000147A                           448                 
0000147A  4EB9 00001C22            449  or_left_print  JSR      EA_SRC_beg     *print EA bits
00001480  2605                     450                 MOVE.L   D5,D3          *get D5 bits in D3 for function call
00001482  4EB9 00001FE0            451                 JSR      print_comma
00001488  4EB9 00001C98            452                 JSR      DR_CMP         *print Dn bits
0000148E  6000 FB84                453                 BRA      prep
00001492                           454  
00001492                           455  * /or_handler
00001492                           456  *-----------------------------------------------------------------------------
00001492                           457  
00001492                           458  
00001492                           459  *----------------------------------------------------------------------------
00001492                           460  *add_handler
00001492                           461  *handles 'ADD'
00001492                           462  * heavily uses the or_handler function as the instruction formats are equivalent after the first nibble
00001492                           463  
00001492  23F9 0000406C 0000412A   464  add_handler    MOVE.L  ADD,INST_NAME
0000149C  E209                     465                 LSR.B   #1,D1
0000149E  1A01                     466                 MOVE.B  D1,D5        *isolate direction bits
000014A0  6500 FF4A                467                 BCS     or_Dn_right  *<ea> + Dn -> <ea>
000014A4  6000 FF50                468                 BRA     or_Dn_left   *Dn + <ea> -> Dn
000014A8                           469         
000014A8                           470  * /add_handler
000014A8                           471  *----------------------------------------------------------------------------
000014A8                           472  
000014A8                           473  
000014A8                           474  *-----------------------------------------------------------------------------
000014A8                           475  *sub_handler
000014A8                           476  * handles 'SUB'
000014A8                           477  
000014A8  23F9 000040C8 0000412A   478  sub_handler         MOVE.L  SUB,INST_NAME
000014B2  4201                     479                      CLR.B   D1
000014B4  E999                     480                      ROL.L   #4,D1
000014B6  2401                     481                      MOVE.L  D1,D2         *make a copy
000014B8  4242                     482                      CLR     D2
000014BA  E59A                     483                      ROL.L   #2,D2
000014BC  6700 FEF6                484                      BEQ     suba_handler  *its suba (hardcoded size bits)
000014C0  E209                     485                      LSR.B   #1,D1         *determine direction of sub
000014C2  1A01                     486                      MOVE.B  D1,D5         *move Dn and direction bits to D5
000014C4  6500 FF26                487                      BCS     or_Dn_right   * <ea> SUB Dn -> <ea>
000014C8  6000 FF2C                488                      BRA     or_Dn_left    * Dn SUB <ea> -> Dn            
000014CC                           489  
000014CC                           490  * /sub_handler
000014CC                           491  *-----------------------------------------------------------------------------
000014CC                           492  
000014CC                           493  *-----------------------------------------------------------------------------
000014CC                           494   * eor_handler  
000014CC                           495   * handles 'EOR'
000014CC                           496  
000014CC  23F9 00004084 0000412A   497  eor_handler         MOVE.L   EOR,INST_NAME
000014D6  E209                     498                      LSR.B    #1,D1           *get rid of direction bit--we know its 1
000014D8  1A01                     499                      MOVE.B   D1,D5           *copy data register number in d1 to d5
000014DA  6000 FF10                500                      BRA      or_Dn_right
000014DE                           501                      
000014DE                           502  * /eor_handler
000014DE                           503  *-----------------------------------------------------------------------------
000014DE                           504  
000014DE                           505  
000014DE                           506  *-----------------------------------------------------------------------------
000014DE                           507  * cmp_handler
000014DE                           508  * handles 'CMP'
000014DE                           509  
000014DE  23F9 0000408C 0000412A   510  cmp_handler         MOVE.L   CMP,INST_NAME
000014E8  E209                     511                      LSR.B    #1,D1        *get rid of hardcoded 0
000014EA  1A01                     512                      MOVE.B   D1,D5        *save Dn bits to D5
000014EC  6000 FF08                513                      BRA      or_Dn_left
000014F0                           514  
000014F0                           515  * /cmp_handler
000014F0                           516  *-----------------------------------------------------------------------------
000014F0                           517  
000014F0                           518  
000014F0                           519  *-----------------------------------------------------------------------------
000014F0                           520  *divsw_handler
000014F0                           521  *handles 'DIVS'(.W)
000014F0                           522  * .W is implicit
000014F0                           523  
000014F0  23F9 000040D8 0000412A   524  divsw_handler   MOVE.L DIV,INST_NAME
000014FA  33F9 00004100 00004132   525                  MOVE.W S,INST_NAME_EXT
00001504  E209                     526  divsw_beg       LSR.B  #1,D1        *get rid of hardcoded bit
00001506  4282                     527                  CLR.L  D2           *clear space in D2
00001508  1401                     528                  MOVE.B D1,D2        *save Dn operation register to D2
0000150A  2602                     529                  MOVE.L D2,D3        *get them into D3 for next function
0000150C  4EB9 00001C98            530                  JSR    DR_CMP       *print the data register
00001512  4EB9 00001FE0            531                  JSR    print_comma
00001518  4201                     532                  CLR.B  D1
0000151A  E589                     533                  LSL.L  #2,D1        *Shift out size bits--we already know its a word
0000151C  E799                     534                  ROL.L  #3,D1        *D1 now holds the EA bits
0000151E  2601                     535                  MOVE.L D1,D3        *and move them to D3
00001520  4EB9 00001C22            536                  JSR    EA_SRC_beg
00001526  6000 FAEC                537                  BRA    prep
0000152A                           538  
0000152A                           539  * /divsw_handler
0000152A                           540  *-----------------------------------------------------------------------------
0000152A                           541  
0000152A                           542  
0000152A                           543  *-----------------------------------------------------------------------------
0000152A                           544  *muls_handler
0000152A                           545  * handles 'MULS'
0000152A                           546  
0000152A                           547  *uses divsw function as layout is similar after first 4 bits
0000152A                           548  
0000152A  23F9 000040D0 0000412A   549  muls_handler      MOVE.L  MUL,INST_NAME
00001534  23F9 00004100 00004132   550                    MOVE.L  S,INST_NAME_EXT
0000153E  4EB8 1504                551                    JSR     divsw_beg
00001542                           552  
00001542                           553  */muls_handler
00001542                           554  *-----------------------------------------------------------------------------
00001542                           555  
00001542                           556  
00001542                           557  *-----------------------------------------------------------------------------
00001542                           558  *subq_handler
00001542                           559  * handles 'SUBQ' (data [1,8])
00001542                           560  
00001542  23F9 000040C8 0000412A   561  subq_handler       MOVE.L  SUB,INST_NAME
0000154C  23F9 000040FE 00004132   562  subq_det           MOVE.L  Q,INST_NAME_EXT
00001556  4201                     563                     CLR.B   D1
00001558  E599                     564                     ROL.L   #2,D1            *isolate size bits
0000155A  B23C 0000                565                     CMP.B   #0,D1
0000155E  6700 0016                566                     BEQ     subq_byte
00001562  B23C 0001                567                     CMP.B   #1,D1
00001566  6700 0020                568                     BEQ     subq_word
0000156A  B23C 0002                569                     CMP.B   #2,D1
0000156E  6700 002A                570                     BEQ     subq_long
00001572  6000 FB02                571                     BRA     inv_handler     *size > 2 means it's an unsupported opcode
00001576  23F9 0000410C 00004118   572  subq_byte          MOVE.L  SIZEB,SIZECODE
00001580  14BC 0000                573                     MOVE.B  #0,(A2)
00001584  6000 0028                574                     BRA     subq_ea
00001588  23F9 00004110 00004118   575  subq_word          MOVE.L  SIZEW,SIZECODE
00001592  14BC 0001                576                     MOVE.B  #1,(A2)            *flag it as a word
00001596  6000 0016                577                     BRA     subq_ea
0000159A  23F9 00004114 00004118   578  subq_long          MOVE.L  SIZEL,SIZECODE
000015A4  24BC 00000002            579                     MOVE.L  #2,(A2)            *flag it as a long
000015AA  6000 0002                580                     BRA     subq_ea 
000015AE                           581  
000015AE  4201                     582  subq_ea            CLR.B   D1               *prep byte space
000015B0  E799                     583                     ROL.L   #3,D1            *get EA bits
000015B2  2601                     584                     MOVE.L  D1,D3            *put them in D3
000015B4  2202                     585                     MOVE.L  D2,D1            *move immediate data bits back to D1 for display
000015B6  4EB9 00001F28            586                     JSR     disp_instr
000015BC  B23C 0000                587                     CMP.B   #0,D1
000015C0  6700 0024                588                     BEQ     case_quick8     *8 (base 0) is represented as 000 in data field.
000015C4  43F9 00004138            589  q_prints           LEA     imm_sign, A1    *load and print '#' character
000015CA  103C 000E                590                     MOVE.B  #14,D0
000015CE  4E4F                     591                     TRAP    #15
000015D0  103C 0003                592                     MOVE.B  #3,D0
000015D4  4E4F                     593                     TRAP    #15              *display immediate [1-8] data 
000015D6  4EB9 00001FE0            594                     JSR     print_comma               
000015DC  4EB9 00001C22            595                     JSR     EA_SRC_beg
000015E2  6000 FA30                596                     BRA     prep
000015E6                           597             
000015E6  123C 0008                598  case_quick8        MOVE.B  #8,D1           *move the number 8 to D1, replacing 0  
000015EA  60D8                     599                     BRA     q_prints     
000015EC                           600  
000015EC                           601  * /subq_handler
000015EC                           602  *-----------------------------------------------------------------------------
000015EC                           603  
000015EC                           604  
000015EC                           605  *-----------------------------------------------------------------------------
000015EC                           606  *addq_handler
000015EC                           607  *handles 'ADDQ', or adds with data [1,8]
000015EC                           608  
000015EC                           609  *uses subq_handler due to similar bit layout
000015EC                           610  
000015EC  23F9 0000406C 0000412A   611  addq_handler      MOVE.L  ADD,INST_NAME
000015F6  6000 FF54                612                    BRA     subq_det          *SUBQ and ADDQ equivalent instruction layout hereafter   
000015FA                           613  
000015FA                           614  * /addq_handler
000015FA                           615  *-----------------------------------------------------------------------------
000015FA                           616  
000015FA                           617  
000015FA                           618  *-----------------------------------------------------------------------------
000015FA                           619  * cmpi_handler
000015FA                           620  * handles cmpi
000015FA                           621  
000015FA                           622  *D1 holds instruction info, then EA info (mode & reg)
000015FA                           623  *D2: holds the size of the operation (b,w,l)
000015FA                           624  
000015FA  23F9 0000408C 0000412A   625  cmpi_handler       MOVE.L   CMP,INST_NAME
00001604  13F9 000040F6 00004132   626                     MOVE.B   I,INST_NAME_EXT
0000160E  4201                     627                     CLR.B    D1
00001610  E599                     628                     ROL.L    #2,D1               *isolate the size bits
00001612  1801                     629                     MOVE.B   D1,D4               *move size bits to D4
00001614  B83C 0000                630                     CMP.B    #0,D4
00001618  6700 0012                631                     BEQ      cmpi_byte
0000161C  B83C 0001                632                     CMP.B    #1,D4
00001620  6700 001C                633                     BEQ      cmpi_word
00001624  B83C 0002                634                     CMP.B    #2,D4
00001628  6700 0026                635                     BEQ      cmpi_long
0000162C  23F9 0000410C 00004118   636  cmpi_byte          MOVE.L   SIZEB,SIZECODE
00001636  14BC 0000                637                     MOVE.B   #0,(A2)
0000163A  6000 0022                638                     BRA      cmpi_ret
0000163E  23F9 00004110 00004118   639  cmpi_word          MOVE.L   SIZEW,SIZECODE
00001648  14BC 0001                640                     MOVE.B   #1,(A2)
0000164C  6000 0010                641                     BRA      cmpi_ret
00001650  23F9 00004114 00004118   642  cmpi_long          MOVE.L   SIZEL,SIZECODE   
0000165A  14BC 0002                643                     MOVE.B   #2,(A2)            
0000165E  4EB9 00001F28            644  cmpi_ret           JSR      disp_instr
00001664  4201                     645                     CLR.B    D1
00001666  4EB9 00001DCC            646                     JSR      DATA_MODE           *determine and print the immediate data based on size
0000166C  E799                     647                     ROL.L    #3,D1               *isolate EA info in D1
0000166E  2601                     648                     MOVE.L   D1,D3
00001670  4EB9 00001FE0            649                     JSR      print_comma
00001676  4EB9 00001C22            650                     JSR      EA_SRC_beg
0000167C  6000 F996                651                     BRA      prep
00001680                           652                     
00001680                           653  * /cmpi_handler
00001680                           654  *-----------------------------------------------------------------------------
00001680                           655  
00001680                           656  
00001680                           657  *-----------------------------------------------------------------------------
00001680                           658  *bclr_static and bclr_dynamic
00001680                           659  *(bclr_handler)
00001680                           660  *handles 'BCLR' with a data register or its static counterpart (no register)
00001680                           661  
00001680  E599                     662  bclr_static       ROL.L     #2,D1          *get 2 more bits-- are we sure its BCLR?
00001682  B23C 0022                663                    CMP.B     #34,D1         *static BCLR bits 11 to 6
00001686  6600 F9EE                664                    BNE       inv_handler    *unsupported opcode
0000168A  23F9 00004074 0000412A   665                    MOVE.L    BCL,INST_NAME  *we now know its bclr
00001694  23F9 000040F8 00004132   666                    MOVE.L    R,INST_NAME_EXT
0000169E  4EB9 00001F28            667                    JSR       disp_instr
000016A4  4201                     668                    CLR.B     D1             
000016A6  E799                     669                    ROL.L     #3,D1          *isolate the EA mode and register
000016A8  2601                     670                    MOVE.L    D1,D3
000016AA  DAFC 0002                671                    ADDA      #word_len,A5   *get the trailing immediate data
000016AE  4281                     672                    CLR.L     D1
000016B0  3215                     673                    MOVE.W    (A5),D1        *move it to D1
000016B2  4EB9 00001DCC            674                    JSR       DATA_MODE       *and print it
000016B8  9AFC 0002                675                    SUBA      #word_len,A5   *return to instruction
000016BC  4EB9 00001FE0            676                    JSR       print_comma
000016C2  4EB9 00001C22            677                    JSR       EA_SRC_beg     *print EA dest information
000016C8  6000 F94A                678                    BRA       prep    
000016CC                           679  
000016CC  E209                     680  bclr_dynamic      LSR.B     #1,D1          *discard hardcoded bit 
000016CE  23F9 00004074 0000412A   681                    MOVE.L    BCL,INST_NAME
000016D8  23F9 000040F8 00004132   682                    MOVE.L    R,INST_NAME_EXT
000016E2  4EB9 00001F28            683                    JSR       disp_instr
000016E8  1601                     684                    MOVE.B    D1,D3          *store Dn bits in D3
000016EA  4EB9 00001C98            685                    JSR       DR_CMP         *print appropriate data register
000016F0  4EB9 00001FE0            686                    JSR       print_comma
000016F6  4201                     687                    CLR.B     D1
000016F8  E589                     688                    LSL.L     #2,D1          *clear hardcoded bits
000016FA  E799                     689                    ROL.L     #3,D1          *get ea bits
000016FC  2601                     690                    MOVE.L    D1,D3          *put them in D3
000016FE  4EB9 00001C22            691                    JSR       EA_SRC_beg     *print EA info
00001704  6000 F90E                692                    BRA       prep
00001708                           693                   
00001708                           694  
00001708                           695  * /bclr_handler
00001708                           696  *-----------------------------------------------------------------------------
00001708                           697  
00001708                           698  
00001708                           699  *-----------------------------------------------------------------------------
00001708                           700  *ori_handler
00001708                           701  *handles 'ORI'
00001708                           702      
00001708                           703  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
00001708                           704  
00001708  23F9 0000407C 0000412A   705  ori_handler       MOVE.L   ORI,INST_NAME
00001712  4201                     706                    CLR.B    D1
00001714  E599                     707                    ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
00001716  1801                     708                    MOVE.B   D1,D4           *move size bits to D2
00001718  4202                     709                    CLR.B    D2
0000171A  E79A                     710                    ROL.L    #3,D2           *get EA mode bits
0000171C  B43C 0007                711                    CMP.B    #7,d2           *are EA mode bits 111?
00001720  6700 F954                712                    BEQ      inv_handler     *invalid ORI type (SR,CCR)
00001724  B83C 0000                713                    CMP.B    #0,D4
00001728  6700 FF02                714                    BEQ      cmpi_byte
0000172C  B83C 0001                715                    CMP.B    #1,D4
00001730  6700 FF0C                716                    BEQ      cmpi_word
00001734  B83C 0002                717                    CMP.B    #2,D4
00001738  6700 FF16                718                    BEQ      cmpi_long
0000173C                           719  
0000173C                           720  * /ori_handler
0000173C                           721  *-----------------------------------------------------------------------------
0000173C                           722  
0000173C                           723  
0000173C                           724  *-----------------------------------------------------------------------------
0000173C                           725  * addi_handler
0000173C                           726  * handles 'ADDI'
0000173C                           727  
0000173C                           728  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
0000173C                           729  
0000173C  23F9 0000406C 0000412A   730  addi_handler      MOVE.L   ADD,INST_NAME
00001746  23F9 000040F6 00004132   731                    MOVE.L   I,INST_NAME_EXT
00001750  4201                     732                    CLR.B    D1
00001752  E599                     733                    ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
00001754  1801                     734                    MOVE.B   D1,D4           *move size bits to D2
00001756  B83C 0000                735                    CMP.B    #0,D4
0000175A  6700 FED0                736                    BEQ      cmpi_byte
0000175E  B83C 0001                737                    CMP.B    #1,D4
00001762  6700 FEDA                738                    BEQ      cmpi_word
00001766  B83C 0002                739                    CMP.B    #2,D4
0000176A  6700 FEE4                740                    BEQ      cmpi_long
0000176E                           741  
0000176E                           742  * /addi_handler
0000176E                           743  *-----------------------------------------------------------------------------
0000176E                           744  
0000176E                           745  *-----------------------------------------------------------------------------
0000176E                           746  * eori_handler
0000176E                           747  * handles 'EORI'
0000176E                           748  
0000176E                           749  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
0000176E                           750  
0000176E  23F9 00004084 0000412A   751  eori_handler      MOVE.L   EOR,INST_NAME
00001778  23F9 000040F6 00004132   752                    MOVE.L   I,INST_NAME_EXT
00001782  4201                     753                    CLR.B    D1
00001784  E599                     754                    ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
00001786  1801                     755                    MOVE.B   D1,D4           *move size bits to D2
00001788  B83C 0000                756                    CMP.B    #0,D4
0000178C  6700 FE9E                757                    BEQ      cmpi_byte
00001790  B83C 0001                758                    CMP.B    #1,D4
00001794  6700 FEA8                759                    BEQ      cmpi_word
00001798  B83C 0002                760                    CMP.B    #2,D4
0000179C  6700 FEB2                761                    BEQ      cmpi_long
000017A0                           762  
000017A0                           763  
000017A0                           764  
000017A0                           765  * /eori_handler
000017A0                           766  *-----------------------------------------------------------------------------
000017A0                           767  
000017A0                           768  *-----------------------------------------------------------------------------
000017A0                           769  * subi_handler
000017A0                           770  * handles 'SUBI'
000017A0                           771  
000017A0                           772  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
000017A0                           773  
000017A0  23F9 000040C8 0000412A   774  subi_handler     MOVE.L   SUB,INST_NAME
000017AA  23F9 000040F6 00004132   775                   MOVE.L   I,INST_NAME_EXT
000017B4  4201                     776                   CLR.B    D1
000017B6  E599                     777                   ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
000017B8  1801                     778                   MOVE.B   D1,D4           *move size bits to D2
000017BA  B83C 0000                779                   CMP.B    #0,D4
000017BE  6700 FE6C                780                   BEQ      cmpi_byte
000017C2  B83C 0001                781                   CMP.B    #1,D4
000017C6  6700 FE76                782                   BEQ      cmpi_word
000017CA  B83C 0002                783                   CMP.B    #2,D4
000017CE  6700 FE80                784                   BEQ      cmpi_long
000017D2                           785  
000017D2                           786  * /subi_handler
000017D2                           787  *-----------------------------------------------------------------------------
000017D2                           788  
000017D2                           789  
000017D2                           790  *-----------------------------------------------------------------------------
000017D2                           791  *neg_handler
000017D2                           792  *handles neg
000017D2                           793  
000017D2                           794  *D1: holds opcode
000017D2                           795  *D4: holds size of operation (b,w,l)
000017D2                           796  
000017D2  23F9 0000404C 0000412A   797  neg_handler      MOVE.L   NEG,INST_NAME
000017DC  4201                     798                   CLR.B    D1   
000017DE  E599                     799                   ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
000017E0  1801                     800                   MOVE.B   D1,D4           *move size bits to D4
000017E2  B83C 0000                801                   CMP.B    #0,D4           *determine size based on bits (00=byte) (01=word) (10=long)
000017E6  6700 0012                802                   BEQ      neg_byte
000017EA  B83C 0001                803                   CMP.B    #1,D4
000017EE  6700 0018                804                   BEQ      neg_word
000017F2  B83C 0002                805                   CMP.B    #2,D4
000017F6  6700 001E                806                   BEQ      neg_long
000017FA                           807    
000017FA  23F9 0000410C 00004118   808  neg_byte         MOVE.L   SIZEB,SIZECODE
00001804  6000 001A                809                   BRA      neg_ret
00001808  23F9 00004110 00004118   810  neg_word         MOVE.L   SIZEW,SIZECODE
00001812  6000 000C                811                   BRA      neg_ret
00001816  23F9 00004114 00004118   812  neg_long         MOVE.L   SIZEL,SIZECODE   
00001820  4EB9 00001F28            813  neg_ret          JSR      disp_instr
00001826  E799                     814                   ROL.L    #3,D1           *isolate EA bits
00001828  2601                     815                   MOVE.L   D1,D3           *move those EA bits to D3
0000182A  4EB9 00001C22            816                   JSR      EA_SRC_beg      *display EA info we're negating
00001830                           817  
00001830                           818  
00001830                           819  * /neg_handler
00001830                           820  *-----------------------------------------------------------------------------
00001830                           821  
00001830                           822  
00001830                           823  *-----------------------------------------------------------------------------
00001830                           824  *bcc_handler
00001830                           825  *handles 'BCS','BGE','BLT','BVC','BRA'
00001830                           826  
00001830                           827  *D1: holds the condition, displacement nibbles of instruction
00001830                           828  *D3: holds the condition of instruction
00001830                           829  *D4: holds the current address of this instruction
00001830                           830  *A4: holds the pointer to bcc_tbl
00001830                           831  *A5: holds the current address of this instruction
00001830                           832  
00001830  4201                     833  bcc_handler   CLR.B   D1
00001832  E999                     834                ROL.L   #4,D1
00001834  1601                     835                MOVE.B  D1,D3          *copy condition value to D3
00001836  49F9 0000411C            836                LEA     bcc_tbl,A4     *A4 now points to the bcc_tbl
0000183C  0C14 00FF                837  bcc_cond      CMP.B   #-1,(A4)       *have we reached the end of the table
00001840  6700 F834                838                BEQ     inv_handler    * yes-invalid branch
00001844  B61C                     839                CMP.B   (A4)+,D3       *compare the next table value
00001846  6700 0004                840                BEQ     bcc_determiner * there's a match
0000184A  60F0                     841                BRA     bcc_cond       *continue looping through the table
0000184C                           842  
0000184C  0C24 0005                843  bcc_determiner  CMP.B  #5,-(a4)      *determine path based on condition code from table (in data section)
00001850  6700 0026                844                  BEQ    bcs_handler
00001854  0C14 000C                845                  CMP.B  #12,(a4)
00001858  6700 002C                846                  BEQ    bge_handler
0000185C  0C14 000D                847                  CMP.B  #13,(a4)
00001860  6700 0032                848                  BEQ    blt_handler
00001864  0C14 0008                849                  CMP.B  #8,(a4)
00001868  6700 0038                850                  BEQ    bvc_handler
0000186C  0C14 0000                851                  CMP.B  #0,(a4)
00001870  6700 003E                852                  BEQ    bra_handler
00001874  6000 F800                853                  BRA    inv_handler
00001878                           854  
00001878  23F9 000040A0 0000412A   855  bcs_handler   MOVE.L  BCS,INST_NAME
00001882  6000 0036                856                BRA     bcc_dispm
00001886  23F9 000040A8 0000412A   857  bge_handler   MOVE.L  BGE,INST_NAME
00001890  6000 0028                858                BRA     bcc_dispm
00001894  23F9 000040B0 0000412A   859  blt_handler   MOVE.L  BLT,INST_NAME
0000189E  6000 001A                860                BRA     bcc_dispm
000018A2  23F9 000040B8 0000412A   861  bvc_handler   MOVE.L  BVC,INST_NAME
000018AC  6000 000C                862                BRA     bcc_dispm
000018B0  23F9 000040C0 0000412A   863  bra_handler   MOVE.L  BRA,INST_NAME
000018BA                           864  
000018BA  280D                     865  bcc_dispm     MOVE.L  A5,D4            *copy current address to D4
000018BC  DAFC 0002                866                ADDA    #word_len,A5     *all Bcc instructions took up a word         
000018C0  4201                     867                CLR.B   D1               *now find the displacement- (A5 +- last 2 nibbles)
000018C2  E199                     868                ROL.L   #8,D1            *get the last 2 displacement nibbles
000018C4  B23C 0000                869                CMP.B   #0,D1            *are the 8 displacement bits all 0?
000018C8  6700 0016                870                BEQ     bcc_word_handler * yes- get the following displacement word
000018CC  B23C 000F                871                CMP.B   #$F,D1           *are all displacement bits 1?
000018D0  6700 0012                872                BEQ     bcc_long_handler * yes-get the displacement long
000018D4  4681                     873  bcc_calc      NOT.L   D1               *ones complement **************** .L OR .w
000018D6  5281                     874                ADDI.L  #1,D1            *twos complement 
000018D8                           875  
000018D8  5404                     876                ADDI.B  #2,D4            *account for PC displacement 2 bytes ahead of current address
000018DA  9841                     877                SUB.W   D1,D4            *calculate displacement address  ****.L OR .W
000018DC  6000 000A                878                BRA     bcc_complete
000018E0                           879                
000018E0  321D                     880  bcc_word_handler  MOVE.W (A5)+,D1    *put 16 displacement bits in D1
000018E2  60F0                     881                    BRA     bcc_calc
000018E4                           882                    
000018E4  221D                     883  bcc_long_handler  MOVE.L (A5)+,D1    *put 32 displacement bits in D1
000018E6  60EC                     884                    BRA     bcc_calc
000018E8                           885  
000018E8  4EB9 00001F28            886  bcc_complete  JSR     disp_instr
000018EE  2044                     887                MOVE.L  D4,A0      *move displacement address to A0 for next function
000018F0  4EB9 00001FF6            888                JSR     print_addr_sgn
000018F6  4EB9 00001F7C            889                JSR     hex_2_ascii
000018FC  6000 F716                890                BRA     prep
00001900                           891                
00001900                           892   */bcc_handler            
00001900                           893  *-----------------------------------------------------------------------------
00001900                           894  
00001900                           895  *-----------------------------------------------------------------------------
00001900                           896   * shift_roll_handler   
00001900                           897   * handles 'LSR','LSL','ASR','ASL','ROL','ROR'
00001900                           898  
00001900                           899   
00001900                           900   *A5: holds the current address of this instruction
00001900                           901   *D2: used to check if its a shift or roll, immediate or register
00001900                           902   *D3: holds the size (b,w,l) of the operation
00001900                           903   *D4: holds the immediate data (1-7) or the register number of the source
00001900                           904   *D5: flags source as immediate or register 1=reg, 0=imm (only used in sr_reg)
00001900                           905   
00001900  4201                     906  _shift_roll_handler  CLR.B    D1
00001902  E999                     907                       ROL.L    #4,D1            *get next 4 bits in this shift/roll
00001904  2401                     908                       MOVE.L   D1,D2
00001906  E20A                     909                       LSR.B    #1,D2            *set the carry to be the direction of this shift/rotate
00001908  6500 0010                910                       BCS      sr_type_resolve  * carry is set- its leftwards
0000190C  23F9 000040F8 00004132   911                       MOVE.L   R,INST_NAME_EXT  *we know its a rightwards operation
00001916  6000 000C                912                       BRA      sr_type_resolve_beg  * carry is set- rightwards
0000191A                           913  
0000191A                           914  *now determine if its a memory or register shift                  
0000191A  23F9 000040FC 00004132   915  sr_type_resolve      MOVE.L   L,INST_NAME_EXT   *we know its a leftwards operation
00001924  1802                     916  sr_type_resolve_beg  MOVE.B   D2,D4          *D4 now holds the count/register bits
00001926  4202                     917                       CLR.B    D2
00001928  E59A                     918                       ROL.L    #2,D2          *get next 2 (size) bits
0000192A  1602                     919                       MOVE.B   D2,D3          *move size bits to D3 
0000192C  4202                     920                       CLR.B    D2             *clear size bits from D2
0000192E  B63C 0003                921                       CMP.B    #3,D3          *are size bits 11?
00001932  6700 0006                922                       BEQ      sr_mem         * yes-memory shift
00001936  6000 005C                923                       BRA      sr_reg         * no-register shift
0000193A                           924                       
0000193A                           925  *its a memory shift/roll,so exact instruction lies in D4. First get type, then get direction later        
0000193A  B83C 0000                926  sr_mem               CMP.B   #0,D4          *D4 holds instruction type. which one is it?
0000193E  6700 0016                927                       BEQ     as_handler
00001942  B83C 0001                928                       CMP.B   #1,D4
00001946  6700 001C                929                       BEQ     ls_handler
0000194A  B83C 0003                930                       CMP.B   #3,D4
0000194E  6700 0022                931                       BEQ     ro_handler
00001952  6000 F722                932                       BRA     inv_handler    *unsupported
00001956                           933                       
00001956  23F9 00004098 0000412A   934  as_handler           MOVE.L  AS,INST_NAME   *its AS(R/L)
00001960  6000 001E                935                       BRA     sr_mem_ret
00001964  23F9 00004094 0000412A   936  ls_handler           MOVE.L  LS,INST_NAME   *its LS(R/L)
0000196E  6000 0010                937                       BRA     sr_mem_ret
00001972  23F9 0000409C 0000412A   938  ro_handler           MOVE.L  RO,INST_NAME   *its RO(R/L)
0000197C  6000 0002                939                       BRA     sr_mem_ret
00001980                           940  
00001980  4EB9 00001F28            941  sr_mem_ret           JSR     disp_instr     *display the instruction (eg 'ASR','ROL')  
00001986  E79A                     942                       ROL.L   #3,D2          *partition EA bits            
00001988  1602                     943                       MOVE.B  D2,D3          *and send them to D3 for next function call
0000198A  4EB9 00001C22            944                       JSR     EA_SRC_beg     *display EA info
00001990  6000 F682                945                       BRA     prep
00001994                           946  
00001994                           947  *its a register shift/roll so D4 holds the register/immediate shift count
00001994  E38A                     948  sr_reg               LSL.L   #1,D2          *send i/r bit to carry
00001996  6500 000A                949                       BCS     sr_reg_type
0000199A  1A3C 0000                950                       MOVE.B  #0,D5              *flag operation as register shift on register
0000199E  6000 0006                951                       BRA     sr_reg_type_beg
000019A2                           952                       
000019A2  1A3C 0001                953  sr_reg_type          MOVE.B  #1,D5              *flag operation as register shift on register
000019A6  4202                     954  sr_reg_type_beg      CLR.B   D2 
000019A8  B63C 0000                955                       CMP.B   #0,D3              *compare size bits to determine operation size
000019AC  6700 0012                956                       BEQ     sr_byte    
000019B0  B63C 0001                957                       CMP.B   #1,D3
000019B4  6700 0018                958                       BEQ     sr_word    
000019B8  B63C 0002                959                       CMP.B   #2,D3
000019BC  6700 001E                960                       BEQ     sr_long
000019C0                           961  
000019C0  23F9 0000410C 00004118   962  sr_byte              MOVE.L  SIZEB,SIZECODE     *its a byte operation
000019CA  6000 001E                963                       BRA     sr_reg_ret
000019CE  23F9 00004110 00004118   964  sr_word              MOVE.L  SIZEW,SIZECODE     *itsva a word operation
000019D8  6000 0010                965                       BRA     sr_reg_ret
000019DC  23F9 00004114 00004118   966  sr_long              MOVE.L  SIZEL,SIZECODE     *its a long operation
000019E6  6000 0002                967                       BRA     sr_reg_ret  
000019EA                           968  
000019EA  4202                     969  sr_reg_ret           CLR.B   D2
000019EC  E59A                     970                       ROL.L   #2,D2              *get the 2 type identifying bits
000019EE  B43C 0000                971                       CMP.B   #0,D2
000019F2  6700 0016                972                       BEQ     as_reg
000019F6  B43C 0001                973                       CMP.B   #1,D2
000019FA  6700 001C                974                       BEQ     ls_reg
000019FE  B43C 0003                975                       CMP.B   #3,D2
00001A02  6700 0022                976                       BEQ     ro_reg
00001A06  6000 F66E                977                       BRA     inv_handler        *its unsupported
00001A0A                           978                       
00001A0A  23F9 00004098 0000412A   979  as_reg               MOVE.L  AS,INST_NAME       *its AS(L/R)
00001A14  6000 0048                980                       BRA     sr_reg_final
00001A18                           981  
00001A18  23F9 00004094 0000412A   982  ls_reg               MOVE.L  LS,INST_NAME       *its LS(L/R)
00001A22  6000 003A                983                       BRA     sr_reg_final
00001A26                           984                       
00001A26  23F9 0000409C 0000412A   985  ro_reg               MOVE.L  RO,INST_NAME       *its RO(L/R)
00001A30  6000 002C                986                       BRA     sr_reg_final
00001A34                           987  
00001A34  1604                     988  sr_reg_print_src     MOVE.B  D4,D3              *move source bits to D3
00001A36  2204                     989                       MOVE.L  D4,D1              *and to D1
00001A38  BA3C 0001                990                       CMP.B   #1,D5
00001A3C  6700 0012                991                       BEQ     sr_reg_print_Dn
00001A40  B23C 0000                992                       CMP.B   #0,D1              *we know source is immediate-- is it 000(= #8)?
00001A44  6700 0012                993                       BEQ     rs_0_shift_handler * yes-load D1 with appropriate dislay data 
00001A48                           994  sr_reg_print_imm     *JSR     data_mode_print        *identify and print immediate data
00001A48  4EB9 00001DCC            995                       JSR     DATA_MODE
00001A4E  4E75                     996                       RTS                      
00001A50  4EB9 00001C98            997  sr_reg_print_Dn      JSR     DR_CMP                 *identify and print dest register
00001A56  4E75                     998                       RTS
00001A58                           999  
00001A58  123C 0008               1000  rs_0_shift_handler   MOVE.B  #8,D1
00001A5C  60EA                    1001                       BRA     sr_reg_print_imm
00001A5E                          1002                
00001A5E  4EB9 00001F28           1003  sr_reg_final         JSR     disp_instr
00001A64  4202                    1004                       CLR.B   D2
00001A66  E79A                    1005                       ROL.L   #3,D2          *get dest Dn bits in D2
00001A68  4EB8 1A34               1006                       JSR     sr_reg_print_src   *determine if source is register/immediate based on D5 flag, print
00001A6C  4EB9 00001FE0           1007                       JSR     print_comma
00001A72  1602                    1008                       MOVE.B  D2,D3          *move dest bits to D3
00001A74  4EB9 00001C98           1009                       JSR     DR_CMP         *print destination register
00001A7A  DAFC 0002               1010                       ADDA    #word_len,A5   *reg shift/roll took up a word
00001A7E  6000 F594               1011                       BRA     prep           
00001A82                          1012                                      
00001A82                          1013   * /_shift_roll_handler  
00001A82                          1014  *-----------------------------------------------------------------------------
00001A82                          1015  
00001A82                          1016                          
00001A82                          1017  *-----------------------------------------------------------------------------
00001A82                          1018  * lea_handler
00001A82                          1019  * handles lea
00001A82                          1020  
00001A82                          1021  *D1: holds opcode instruction
00001A82                          1022  *D2: holds register bits
00001A82                          1023  
00001A82  E209                    1024  lea_handler       LSR.B     #1,D1          *hardcoded bit
00001A84  2401                    1025                    MOVE.L    D1,D2          *save dest An bits to D2
00001A86  4201                    1026                    CLR.B     D1
00001A88  E589                    1027                    LSL.L     #2,D1          *hardcoded bits
00001A8A  E799                    1028                    ROL.L     #3,D1
00001A8C  2601                    1029                    MOVE.L    D1,D3          *get EA bits into D3
00001A8E  23F9 00004044 0000412A  1030                    MOVE.L    LEA,INST_NAME
00001A98  4EB9 00001F28           1031                    JSR       disp_instr       
00001A9E  4EB9 00001C22           1032                    JSR       EA_SRC_beg
00001AA4  4EB9 00001FE0           1033                    JSR       print_comma
00001AAA  2602                    1034                    MOVE.L    D2,D3
00001AAC  4EB9 00001CFC           1035                    JSR       PRINT_INNER_An     
00001AB2  6000 F560               1036                    BRA       prep
00001AB6                          1037                    
00001AB6                          1038                    
00001AB6                          1039  * /lea_handler
00001AB6                          1040  *-----------------------------------------------------------------------------
00001AB6                          1041  
00001AB6                          1042  
00001AB6                          1043  *-----------------------------------------------------------------------------
00001AB6                          1044  *jsr_handler
00001AB6                          1045  *handles 'JSR'
00001AB6                          1046  
00001AB6  23F9 00004054 0000412A  1047  jsr_handler       MOVE.L  JSR,INST_NAME
00001AC0  4EB9 00001F28           1048                    JSR     disp_instr
00001AC6  4202                    1049                    CLR.B   D2            *clear byte space for next few bits
00001AC8  E79A                    1050                    ROL.L   #3,D2         *save EA bits into D2
00001ACA  2602                    1051                    MOVE.L  D2,D3
00001ACC  4EB9 00001C22           1052                    JSR     EA_SRC_beg
00001AD2  6000 F540               1053                    BRA     prep
00001AD6                          1054  
00001AD6                          1055  * /jsr_handler
00001AD6                          1056  *-----------------------------------------------------------------------------
00001AD6                          1057  
00001AD6                          1058  
00001AD6                          1059  *-----------------------------------------------------------------------------
00001AD6                          1060  *movem_handler
00001AD6                          1061  *handles 'MOVEM'
00001AD6                          1062  
00001AD6                          1063  *An list corresponds to higher byte
00001AD6                          1064  *Dn list corresponds to lower byte
00001AD6                          1065  
00001AD6                          1066  *D2:holds first register in sublist
00001AD6                          1067  *D3:holds the number of successive 1's shifted out of a list (register train)
00001AD6                          1068  *D4:holds number of iterations for shifting out the bits in the list bytes. also the register number.
00001AD6                          1069  *D5:holds the An list byte
00001AD6                          1070  *D6:holds the Dn list byte
00001AD6                          1071  
00001AD6  23F9 0000403C 0000412A  1072  movem_handler  MOVE.L  MOV,INST_NAME
00001AE0  23F9 00004104 00004132  1073                 MOVE.L  EM,INST_NAME_EXT
00001AEA  B23C 0008               1074                 CMP.B   #$8,D1
00001AEE  6700 0026               1075                 BEQ     movem_dn
00001AF2  4201                    1076  movem_an       CLR.B   D1
00001AF4  E589                    1077                 LSL.L   #2,D1
00001AF6  6500 0010               1078                 BCS     movem_long
00001AFA                          1079                 
00001AFA  23F9 00004110 00004118  1080  movem_word     MOVE.L  SIZEW,SIZECODE
00001B04  6000 0018               1081                 BRA     movem_list
00001B08  23F9 00004114 00004118  1082  movem_long     MOVE.L  SIZEL,SIZECODE
00001B12  6000 000A               1083                 BRA     movem_list
00001B16                          1084  
00001B16  4201                    1085  movem_dn       CLR.B   D1
00001B18  E589                    1086                 LSL.L   #2,D1
00001B1A  65EC                    1087                 BCS     movem_long
00001B1C  60DC                    1088                 BRA     movem_word
00001B1E                          1089  
00001B1E  4EB9 00001F28           1090  movem_list     JSR     disp_instr
00001B24  DAFC 0002               1091                 ADDA    #word_len,A5                 *get to register list word
00001B28  3A15                    1092                 MOVE.W  (A5),D5                      *move entire list to D5
00001B2A  1C05                    1093                 MOVE.B  D5,D6                        *move lower order byte (Dn list) to D6
00001B2C  E04D                    1094                 LSR.W   #word_len*4,D5               *shift the An list to the lower order of D5
00001B2E  7801                    1095                 MOVE.L  #1,D4                        *init loop counter/register number
00001B30  4282                    1096                 CLR.L   D2                           *clear D2, which is holding first regiester in train
00001B32  4283                    1097                 CLR.L   D3                           *set train counter to 1
00001B34  6000 0002               1098                 BRA     movem_dn_list_loop           *first take care or the Dn list
00001B38                          1099     
00001B38  B83C 0008               1100  movem_dn_list_loop     CMP.B  #word_len*4,D4        *have we done the whole register list - 1
00001B3C  6700 009E               1101                         BEQ    movem_dn_last         * yes get the last register bit
00001B40  E20E                    1102                         LSR.B  #1,D6                 *shift out a (Dn) bit. 1 if its in the list, 0 if not
00001B42  6500 001A               1103                         BCS    movem_dn_list_status_1  *a register was identified--check status of register train
00001B46                          1104                         *ADDI   #1,D4                *increment loop/register counter
00001B46  6000 0002               1105                         BRA    movem_dn_list_status_0  *check status
00001B4A                          1106  
00001B4A  B63C 0002               1107  movem_dn_list_status_0 CMP.B  #2,D3
00001B4E  6E00 0038               1108                         BGT    print_list_intermediate       
00001B52  B63C 0001               1109                         CMP.B  #1,D3
00001B56  6700 0052               1110                         BEQ    movem_print_single 
00001B5A  5244                    1111                         ADDI   #1,D4
00001B5C  60DA                    1112                         BRA    movem_dn_list_loop
00001B5E                          1113                      
00001B5E  5243                    1114  movem_dn_list_status_1 ADDI   #1,D3                                        
00001B60  B43C 0000               1115  movem_dn_list_status   CMP.B  #0,D2                 *is there currently a first entry in the reg train
00001B64  6700 000E               1116                         BEQ    movem_list_first_entry    * no- add the first reg
00001B68  5244                    1117                         ADDI   #1,D4                 *increment loop/register counter
00001B6A  B63C 0001               1118  movem_dn_cont          CMP.B  #1,D3                 *do we have more than one successive register?
00001B6E  6CC8                    1119                         BGE    movem_dn_list_loop    * yes- we have a train-- dont need to print intermediate register
00001B70  6D00 0016               1120                         BLT    print_list_intermediate   *train ended- print intermediate list's end
00001B74                          1121   
00001B74  1404                    1122  movem_list_first_entry  MOVE.B D4,D2                 *move first register in sublist to D2
00001B76  5342                    1123                          SUBI   #1,D2
00001B78  C543                    1124                          EXG    D2,D3                 *exchange D2 and D3 contents for next function
00001B7A  4EB9 00001C98           1125                          JSR    DR_CMP                *print the first register in the list
00001B80  C543                    1126                          EXG    D2,D3                 *restore
00001B82  5242                    1127                          ADDI   #1,D2
00001B84  5243                    1128                          ADDI   #1,D3
00001B86                          1129                          *ADDI   #1,D4                 *increment loop/reg counter
00001B86  60E2                    1130                          BRA    movem_dn_cont         *return to status check
00001B88                          1131                          
00001B88  C744                    1132  print_list_intermediate    EXG    D3,D4              *switch reg order for following function
00001B8A  4EB9 00002022           1133                             JSR    print_hyphen       *integrate start and end of train
00001B90  5343                    1134                             SUBI   #1,D3
00001B92  4EB9 00001C98           1135                             JSR    DR_CMP             *print the end of the sublist
00001B98  4EB9 0000200C           1136                             JSR    print_slash        *prep new sublist
00001B9E  5243                    1137                             ADDI   #1,D3
00001BA0  C744                    1138                             EXG    D3,D4              *restore regs
00001BA2  4203                    1139                             CLR.B  D3                 *clear train counter
00001BA4  4202                    1140                             CLR.B  D2                 *clear first register in train
00001BA6  5244                    1141                             ADDI   #1,D4
00001BA8  608E                    1142                             BRA    movem_dn_list_loop   *return to loop              
00001BAA                          1143  
00001BAA  C744                    1144  movem_print_single         EXG    D3,D4
00001BAC  5343                    1145                             SUBI   #1,D3
00001BAE  4EB9 00001C98           1146                             JSR    DR_CMP             *print the end of the sublist
00001BB4  4EB9 0000200C           1147                             JSR    print_slash        *prep new sublist
00001BBA  5243                    1148                             ADDI   #1,D3
00001BBC  C744                    1149                             EXG    D3,D4              *restore regs
00001BBE  4202                    1150                             CLR.B  D2
00001BC0  4203                    1151                             CLR.B  D3
00001BC2  5244                    1152                             ADDI   #1,D4
00001BC4  6000 FF72               1153                             BRA    movem_dn_list_loop
00001BC8                          1154  
00001BC8                          1155                                     
00001BC8  4EB9 00002022           1156  movem_dn_full              JSR    print_hyphen       *integrate start and end of train 
00001BCE  4EB9 00001E86           1157                             JSR    PRINT_D7
00001BD4  4284                    1158                             CLR.L  D4
00001BD6  4283                    1159                             CLR.L  D3
00001BD8  6000 0018               1160                             BRA    movem_an_list_loop                       
00001BDC                          1161                         
00001BDC                          1162                         
00001BDC  E20E                    1163  movem_dn_last          LSR.B  #1,D6
00001BDE                          1164  
00001BDE                          1165  
00001BDE                          1166  
00001BDE                          1167                         
00001BDE  C943                    1168  movem_an_list_prep     EXG    D4,D3
00001BE0  5543                    1169                         SUBI   #2,D3
00001BE2  B63C 0007               1170                         CMP.B  #7,D3
00001BE6  67E0                    1171                         BEQ    movem_dn_full
00001BE8  4EB9 00001C98           1172                         JSR    DR_CMP                *print last register in Dn register train
00001BEE  4284                    1173                         CLR.L  D4
00001BF0  4283                    1174                         CLR.L  D3
00001BF2  B83C 0008               1175  movem_an_list_loop     CMP.B  #word_len*4,D4
00001BF6                          1176                         *BEQ    movem_print_list
00001BF6                          1177                 
00001BF6                          1178    
00001BF6                          1179  
00001BF6                          1180               
00001BF6  4EB9 00001FE0           1181  movem_ea       JSR     print_comma
00001BFC  4201                    1182                 CLR.B   D1
00001BFE  E799                    1183                 ROL.L   #3,D1            *get EA bits
00001C00  2601                    1184                 MOVE.L  D1,D3            *and put them into D3
00001C02  4EB9 00001C22           1185                 JSR     EA_SRC_beg       *identify and print destination
00001C08  6000 F40A               1186                 BRA     prep
00001C0C                          1187  
00001C0C                          1188  * /movem_handler
00001C0C                          1189  *-----------------------------------------------------------------------------
00001C0C                          1190  
00001C0C                          1191  *-----------------------------------------------------------------------------
00001C0C                          1192  * rts_handler
00001C0C                          1193  * handles 'RTS'
00001C0C                          1194  
00001C0C  4281                    1195  rts_handler    CLR.L  D1                    *rts all hardcoded
00001C0E  23F9 0000405C 0000412A  1196                 MOVE.L RTS,INST_NAME
00001C18  4EB9 00001F28           1197                 JSR    disp_instr
00001C1E  6000 F3F4               1198                 BRA    prep
00001C22                          1199  
00001C22                          1200  * /rts_handler
00001C22                          1201  *-----------------------------------------------------------------------------
00001C22                          1202  
00001C22                          1203  
00001C22                          1204  
00001C22                          1205  *below functions also increment address pointer A5 depending on data fetch size for immediate,absolute addresses
00001C22                          1206  
00001C22  DAFC 0002               1207  EA_SRC_beg  ADDA   #word_len,A5
00001C26                          1208  
00001C26                          1209              *(xxx).W, (xxx).L, #<data>        
00001C26  0C03 0007               1210  EA_SRC      CMPI.B #$7, D3            *Compares if its 111
00001C2A  6700 002E               1211                 BEQ FILTER_EA_MODE
00001C2E                          1212  
00001C2E                          1213              *Dn
00001C2E  0C03 0000               1214              CMPI.B #$0, D3           *Compares if its 000
00001C32                          1215                  
00001C32  6700 0060               1216                  BEQ DATA_REGISTER
00001C36                          1217                  
00001C36  0C03 0001               1218              CMPI.B #1, D3               *001
00001C3A  6700 0050               1219                  BEQ ADDRESS_MODE
00001C3E                          1220                  
00001C3E                          1221              *(An)
00001C3E  0C03 0002               1222              CMPI.B #$2, D3            *Compares if its 010
00001C42  6700 0094               1223                  BEQ CLOSED_PARAN
00001C46                          1224                  
00001C46                          1225              *(An)+
00001C46  0C03 0003               1226              CMPI.B #$3, D3            *Compares if its 011
00001C4A  6700 00F0               1227                  BEQ POSTFIX_PLUS
00001C4E                          1228              
00001C4E                          1229              *-(An)                  *Compares if its 100
00001C4E  0C03 0004               1230              CMPI.B #$4, D3
00001C52  6700 0116               1231                  BEQ PREFIX_MINUS
00001C56                          1232                  
00001C56  6600 0024               1233                  BNE INVALID_MODE      *e.g. ARI,PCI
00001C5A                          1234  
00001C5A                          1235  FILTER_EA_MODE
00001C5A                          1236          *Rotate to get register as byte
00001C5A  4203                    1237          CLR.B  D3
00001C5C  E79B                    1238          ROL.L  #3,D3
00001C5E                          1239           
00001C5E                          1240          *(xxx).W
00001C5E  0C03 0000               1241          CMPI.B #$0, D3
00001C62  6700 0134               1242              BEQ WORD_MODE
00001C66                          1243              
00001C66                          1244          *(xxx).L
00001C66  0C03 0001               1245          CMPI.B #$1, D3
00001C6A  6700 0146               1246              BEQ LONG_MODE
00001C6E                          1247              
00001C6E                          1248          *# <data>
00001C6E  0C03 0004               1249          CMPI.B #$4, D3
00001C72  6700 0158               1250              BEQ DATA_MODE
00001C76  6600 0004               1251              BNE INVALID_MODE
00001C7A  4E75                    1252      RTS
00001C7C                          1253  
00001C7C                          1254  
00001C7C                          1255  INVALID_MODE    *unsupported mode eg PCD,PCI
00001C7C  227C 000040EC           1256      MOVE.L  #INV,A1
00001C82  103C 000E               1257      MOVE.B  #14,D0
00001C86  4E4F                    1258      TRAP    #15
00001C88                          1259      
00001C88  544D                    1260      ADDA    #2,A5   ******* inv opcodes take up a word
00001C8A                          1261      
00001C8A  4E75                    1262      RTS
00001C8C                          1263      
00001C8C                          1264  *An
00001C8C                          1265  ADDRESS_MODE  *Get register to get what Dn to go to
00001C8C  4203                    1266      CLR.B  D3
00001C8E  E79B                    1267      ROL.L  #3,D3
00001C90  6000 006A               1268      BRA    PRINT_INNER_An
00001C94                          1269  
00001C94                          1270  * Dn
00001C94                          1271  DATA_REGISTER    *Get register to get what Dn to go to
00001C94  4203                    1272      CLR.B  D3
00001C96  E79B                    1273      ROL.L  #3,D3
00001C98                          1274      
00001C98  0C03 0000               1275  DR_CMP  CMPI.B #0, D3
00001C9C  6700 016A               1276          BEQ PRINT_D0
00001CA0  0C03 0001               1277      CMPI.B #1, D3
00001CA4  6700 0174               1278          BEQ PRINT_D1
00001CA8  0C03 0002               1279      CMPI.B #2, D3
00001CAC  6700 017E               1280          BEQ PRINT_D2
00001CB0  0C03 0003               1281      CMPI.B #3, D3
00001CB4  6700 0188               1282          BEQ PRINT_D3
00001CB8  0C03 0004               1283      CMPI.B #4, D3
00001CBC  6700 0192               1284          BEQ PRINT_D4
00001CC0  0C03 0005               1285      CMPI.B #5, D3
00001CC4  6700 019C               1286          BEQ PRINT_D5
00001CC8  0C03 0006               1287      CMPI.B #6, D3
00001CCC  6700 01A6               1288          BEQ PRINT_D6
00001CD0  0C03 0007               1289      CMPI.B #7, D3
00001CD4  6700 01B0               1290          BEQ PRINT_D7
00001CD8                          1291      
00001CD8                          1292  * (An)
00001CD8                          1293  CLOSED_PARAN  *Get register to get what Dn to go to
00001CD8  4203                    1294      CLR.B  D3
00001CDA  E79B                    1295      ROL.L  #3,D3
00001CDC                          1296      *Prints '('
00001CDC  43F9 0000413A           1297      LEA open_paren, A1
00001CE2  103C 000E               1298      MOVE.B #14, D0
00001CE6  4E4F                    1299      TRAP #15
00001CE8                          1300      
00001CE8                          1301      *Print The appropriate value of An *Needed to use JSR & RTS
00001CE8  4EB9 00001CFC           1302      JSR PRINT_INNER_An
00001CEE                          1303     
00001CEE                          1304      *Prints ')'
00001CEE  43F9 0000413C           1305      LEA closed_paren, A1
00001CF4  103C 000E               1306      MOVE.B #14, D0
00001CF8  4E4F                    1307      TRAP #15
00001CFA  4E75                    1308      RTS
00001CFC                          1309      
00001CFC                          1310  *Prints the An in (An) and returns to the original method   
00001CFC                          1311  PRINT_INNER_An
00001CFC  0C43 0000               1312      CMPI  #0, D3
00001D00  6700 0196               1313          BEQ    PRINT_A0
00001D04  0C43 0001               1314      CMPI #1, D3
00001D08  6700 01A0               1315          BEQ PRINT_A1
00001D0C  0C43 0002               1316      CMPI #2, D3
00001D10  6700 01AA               1317          BEQ PRINT_A2
00001D14  0C43 0003               1318      CMPI #3, D3
00001D18  6700 01B4               1319          BEQ PRINT_A3
00001D1C  0C43 0004               1320      CMPI #4, D3
00001D20  6700 01BE               1321          BEQ PRINT_A4
00001D24  0C43 0005               1322      CMPI #5, D3
00001D28  6700 01C8               1323          BEQ PRINT_A5
00001D2C  0C43 0006               1324      CMPI #6, D3
00001D30  6700 01D2               1325          BEQ PRINT_A6
00001D34  0C43 0007               1326      CMPI #7, D3
00001D38  6700 01DC               1327          BEQ PRINT_A7
00001D3C                          1328  
00001D3C                          1329  * (An)+
00001D3C                          1330  POSTFIX_PLUS
00001D3C  4203                    1331      CLR.B  D3
00001D3E  E79B                    1332      ROL.L  #3,D3
00001D40                          1333      
00001D40                          1334      *Prints '('
00001D40  43F9 0000413A           1335      LEA open_paren, A1
00001D46  103C 000E               1336      MOVE.B #14, D0
00001D4A  4E4F                    1337      TRAP #15
00001D4C                          1338  
00001D4C                          1339      
00001D4C                          1340      *Print The appropriate value of An
00001D4C  4EB8 1CFC               1341      JSR PRINT_INNER_An
00001D50                          1342      
00001D50                          1343      *Prints ')'
00001D50  43F9 0000413C           1344      LEA closed_paren, A1
00001D56  103C 000E               1345      MOVE.B #14, D0
00001D5A  4E4F                    1346      TRAP #15
00001D5C                          1347      
00001D5C                          1348       *Prints '+'
00001D5C  43F9 0000413E           1349      LEA plus_sign, A1
00001D62  103C 000E               1350      MOVE.B #14, D0
00001D66  4E4F                    1351      TRAP #15
00001D68  4E75                    1352      RTS
00001D6A                          1353      
00001D6A                          1354  *-(An)
00001D6A  4203                    1355  PREFIX_MINUS   CLR.B  D3
00001D6C  E79B                    1356      ROL.L  #3,D3
00001D6E                          1357      
00001D6E                          1358       *Prints '-'
00001D6E  43F9 00004140           1359      LEA neg_sign, A1
00001D74  103C 000E               1360      MOVE.B #14, D0
00001D78  4E4F                    1361      TRAP #15
00001D7A                          1362      
00001D7A                          1363      *Prints '('
00001D7A  43F9 0000413A           1364      LEA open_paren, A1
00001D80  103C 000E               1365      MOVE.B #14, D0
00001D84  4E4F                    1366      TRAP #15
00001D86                          1367      
00001D86                          1368      *Print The appropriate value of An *Needed to use JSR & RTS
00001D86  4EB8 1CFC               1369      JSR PRINT_INNER_An
00001D8A                          1370      
00001D8A                          1371      
00001D8A                          1372      *Prints ')'
00001D8A  43F9 0000413C           1373      LEA closed_paren, A1
00001D90  103C 000E               1374      MOVE.B #14, D0
00001D94  4E4F                    1375      TRAP #15
00001D96                          1376   
00001D96  4E75                    1377      RTS
00001D98                          1378      
00001D98                          1379  *(xxx).W 
00001D98  48E7 4000               1380  WORD_MODE  MOVEM.L  D1,-(SP)      *save calling state of D1
00001D9C  4281                    1381             CLR.L    D1
00001D9E                          1382             *ADDA     #word_len,A5  *increment the pointer to the next address by the length of the next WORD fetched from memory
00001D9E  4EB9 00001FF6           1383             JSR      print_addr_sgn
00001DA4  305D                    1384             MOVE.W   (A5)+,A0      *move that word value to A0 for display
00001DA6  4EB9 00001F7C           1385             JSR      hex_2_ascii   *convert/display the word
00001DAC  4CDF 0002               1386             MOVEM.L  (SP)+,D1      *restore D1
00001DB0  4E75                    1387             RTS
00001DB2                          1388      
00001DB2                          1389  *(xxx).L 
00001DB2  48E7 4000               1390  LONG_MODE  MOVEM.L  D1,-(SP)      *save calling state of D1
00001DB6  4281                    1391             CLR.L    D1
00001DB8                          1392             *ADDA     #long_len,A5 *increment the pointer to the next address by the length of the next LONG fetched from memory
00001DB8  4EB9 00001FF6           1393             JSR      print_addr_sgn
00001DBE  205D                    1394             MOVE.L   (A5)+,A0      *move that long value to A0 for display
00001DC0  4EB9 00001F7C           1395             JSR      hex_2_ascii   *convert/display the long in A0
00001DC6  4CDF 0002               1396             MOVEM.L  (SP)+,D1      *restore D1
00001DCA  4E75                    1397             RTS
00001DCC                          1398             
00001DCC                          1399  
00001DCC                          1400  *#<data>
00001DCC  48E7 4000               1401  DATA_MODE  MOVEM.L  D1,-(SP)        *save calling state of D1
00001DD0  4281                    1402             CLR.L    D1 
00001DD2  0C12 0001               1403             CMP.B    #1,(A2)         *is immediate data flagged as a word?
00001DD6  6700 000A               1404             BEQ      word_data_handler
00001DDA  0C12 0002               1405             CMP.B    #2,(A2)         *is immediate data flagged as a long?
00001DDE  6700 0008               1406             BEQ      long_data_handler         
00001DE2                          1407  
00001DE2                          1408                                      *then its a byte held as a word 
00001DE2                          1409  
00001DE2                          1410  *byte_data_handler *ADDA     #byte_len,A5
00001DE2                          1411   *                 MOVE.B   (A5)+,D1     *get immediate byte data and increment address by a byte
00001DE2                          1412    *                BRA      data_mode_print
00001DE2                          1413                    
00001DE2                          1414  word_data_handler *ADDA     #word_len,A5
00001DE2  321D                    1415                    MOVE.W   (A5)+,D1     *get immediate word data and increment address by a word
00001DE4  6000 0008               1416                    BRA      data_mode_print
00001DE8                          1417  
00001DE8                          1418  long_data_handler *ADDA     #long_len,A5
00001DE8  221D                    1419                    MOVE.L   (A5)+,D1     *get immediate long data and increment address by a long
00001DEA  6000 0002               1420                    BRA      data_mode_print
00001DEE                          1421  
00001DEE  43F9 00004138           1422  data_mode_print   LEA      imm_sign, A1    *load and print '#' character
00001DF4  103C 000E               1423                    MOVE.B   #14, D0
00001DF8  4E4F                    1424                    TRAP     #15  
00001DFA  2041                    1425                    MOVE.L   D1,A0
00001DFC  4EB9 00001F7C           1426                    JSR      hex_2_ascii  *print the hex data
00001E02  4CDF 0002               1427                    MOVEM.L  (SP)+,D1     *restore D1
00001E06  4E75                    1428                    RTS
00001E08                          1429  
00001E08  43F9 00001E16           1430  PRINT_D0 LEA D0_MESS, A1
00001E0E  103C 000E               1431      MOVE.B #14, D0
00001E12  4E4F                    1432      TRAP #15
00001E14  4E75                    1433      RTS
00001E16= 4430 0000               1434  D0_MESS  DC.W 'D0',0
00001E1A                          1435  
00001E1A                          1436  
00001E1A  43F9 00001E28           1437  PRINT_D1 LEA D1_MESS, A1
00001E20  103C 000E               1438      MOVE.B #14, D0
00001E24  4E4F                    1439      TRAP #15
00001E26  4E75                    1440      RTS
00001E28= 4431 0000               1441  D1_MESS  DC.W 'D1',0
00001E2C                          1442  
00001E2C                          1443  
00001E2C  43F9 00001E3A           1444  PRINT_D2 LEA D2_MESS, A1
00001E32  103C 000E               1445      MOVE.B #14, D0
00001E36  4E4F                    1446      TRAP #15
00001E38  4E75                    1447      RTS
00001E3A= 4432 0000               1448  D2_MESS  DC.W 'D2',0
00001E3E                          1449  
00001E3E                          1450  
00001E3E  43F9 00001E4C           1451  PRINT_D3 LEA D3_MESS, A1
00001E44  103C 000E               1452      MOVE.B #14, D0
00001E48  4E4F                    1453      TRAP #15
00001E4A  4E75                    1454      RTS
00001E4C= 4433 0000               1455  D3_MESS  DC.W 'D3',0
00001E50                          1456  
00001E50                          1457  
00001E50  43F9 00001E5E           1458  PRINT_D4 LEA D4_MESS, A1
00001E56  103C 000E               1459      MOVE.B #14, D0
00001E5A  4E4F                    1460      TRAP #15
00001E5C  4E75                    1461      RTS
00001E5E= 4434 0000               1462  D4_MESS  DC.W 'D4',0
00001E62                          1463  
00001E62                          1464  
00001E62  43F9 00001E70           1465  PRINT_D5 LEA D5_MESS, A1
00001E68  103C 000E               1466      MOVE.B #14, D0
00001E6C  4E4F                    1467      TRAP #15
00001E6E  4E75                    1468      RTS
00001E70= 4435 0000               1469  D5_MESS  DC.W 'D5',0
00001E74                          1470  
00001E74                          1471  
00001E74  43F9 00001E82           1472  PRINT_D6 LEA D6_MESS, A1
00001E7A  103C 000E               1473      MOVE.B #14, D0
00001E7E  4E4F                    1474      TRAP #15
00001E80  4E75                    1475      RTS
00001E82= 4436 0000               1476  D6_MESS  DC.W 'D6',0
00001E86                          1477  
00001E86  43F9 00001E94           1478  PRINT_D7 LEA D7_MESS, A1
00001E8C  103C 000E               1479      MOVE.B #14, D0
00001E90  4E4F                    1480      TRAP #15
00001E92  4E75                    1481      RTS
00001E94= 4437 0000               1482  D7_MESS  DC.W 'D7',0
00001E98                          1483      
00001E98                          1484  
00001E98  43F9 00001EA6           1485  PRINT_A0 LEA A0_MESS, A1
00001E9E  103C 000E               1486      MOVE.B #14, D0
00001EA2  4E4F                    1487      TRAP #15
00001EA4  4E75                    1488      RTS
00001EA6= 4130 0000               1489  A0_MESS DC.W 'A0',0
00001EAA                          1490  
00001EAA  43F9 00001EB8           1491  PRINT_A1 LEA A1_MESS, A1
00001EB0  103C 000E               1492      MOVE.B #14, D0
00001EB4  4E4F                    1493      TRAP #15
00001EB6  4E75                    1494      RTS
00001EB8= 4131 0000               1495  A1_MESS DC.W 'A1',0
00001EBC                          1496  
00001EBC  43F9 00001ECA           1497  PRINT_A2 LEA A2_MESS, A1
00001EC2  103C 000E               1498      MOVE.B #14, D0
00001EC6  4E4F                    1499      TRAP #15
00001EC8  4E75                    1500      RTS
00001ECA= 4132 0000               1501  A2_MESS DC.W 'A2',0
00001ECE                          1502  
00001ECE  43F9 00001EDC           1503  PRINT_A3 LEA A3_MESS, A1
00001ED4  103C 000E               1504      MOVE.B #14, D0
00001ED8  4E4F                    1505      TRAP #15
00001EDA  4E75                    1506      RTS
00001EDC= 4133 0000               1507  A3_MESS DC.W 'A3',0
00001EE0                          1508  
00001EE0  43F9 00001EEE           1509  PRINT_A4 LEA A4_MESS, A1
00001EE6  103C 000E               1510      MOVE.B #14, D0
00001EEA  4E4F                    1511      TRAP #15
00001EEC  4E75                    1512      RTS
00001EEE= 4134 0000               1513  A4_MESS DC.W 'A4',0
00001EF2                          1514  
00001EF2  43F9 00001F00           1515  PRINT_A5 LEA A5_MESS, A1
00001EF8  103C 000E               1516      MOVE.B #14, D0
00001EFC  4E4F                    1517      TRAP #15
00001EFE  4E75                    1518      RTS
00001F00= 4135 0000               1519  A5_MESS DC.W 'A5',0
00001F04                          1520  
00001F04  43F9 00001F12           1521  PRINT_A6 LEA A6_MESS, A1
00001F0A  103C 000E               1522      MOVE.B #14, D0
00001F0E  4E4F                    1523      TRAP #15
00001F10  4E75                    1524      RTS
00001F12= 4136 0000               1525  A6_MESS DC.W 'A6',0
00001F16                          1526  
00001F16  43F9 00001F24           1527  PRINT_A7 LEA A7_MESS, A1
00001F1C  103C 000E               1528      MOVE.B #14, D0
00001F20  4E4F                    1529      TRAP #15
00001F22  4E75                    1530      RTS
00001F24= 4137 0000               1531  A7_MESS DC.W 'A7',0
00001F28                          1532                
00001F28                          1533  *-----------------------------------------------------------------------------------------
00001F28                          1534  *disp_instr
00001F28                          1535  * displays the instruction name in assembly and the address of the instruction
00001F28                          1536  
00001F28  48E7 4000               1537  disp_instr    MOVEM.L D1, -(SP)     *save state of D1 before using it below
00001F2C                          1538  
00001F2C  4EB9 00001FF6           1539                JSR     print_addr_sgn *print '$'
00001F32  204D                    1540                MOVEA.L A5,A0          *load A0 with the current address for the next function
00001F34  4EB9 00001F7C           1541                JSR     hex_2_ascii    *convert the hex addr to ascii to print
00001F3A                          1542                
00001F3A  43F9 00004149           1543                LEA     space,A1
00001F40  103C 000E               1544                MOVE.B  #14,D0
00001F44  4E4F                    1545                TRAP    #15
00001F46                          1546                
00001F46  43F9 0000412A           1547                LEA.L   INST_NAME,A1  *move the (assembly) name of this instruction into A1
00001F4C  103C 000E               1548                MOVE.B  #14,D0
00001F50  4E4F                    1549                TRAP    #15
00001F52                          1550                
00001F52  43F9 00004132           1551                LEA     INST_NAME_EXT,A1  *if the instruction name was longer than 32 bits
00001F58  103C 000E               1552                MOVE.B  #14,D0
00001F5C  4E4F                    1553                TRAP    #15
00001F5E                          1554                
00001F5E  43F9 00004118           1555                LEA.L   SIZECODE,A1       *print size of operation
00001F64  103C 000E               1556                MOVE.B  #14,D0
00001F68  4E4F                    1557                TRAP    #15
00001F6A                          1558                
00001F6A  43F9 00004149           1559                LEA     space,A1
00001F70  103C 000E               1560                MOVE.B  #14,D0
00001F74  4E4F                    1561                TRAP    #15
00001F76                          1562                
00001F76                          1563                
00001F76  4CDF 0002               1564                MOVEM.L  (SP)+,D1         *restore D1
00001F7A  4E75                    1565                RTS
00001F7C                          1566                
00001F7C                          1567  * /disp_instr
00001F7C                          1568  *-----------------------------------------------------------------------------------------  
00001F7C                          1569  
00001F7C                          1570  
00001F7C                          1571  *----------------------------------------------------------------------------------------- 
00001F7C                          1572  *hex_2_ascii
00001F7C                          1573  * converts a hex number to its ascii string equivalent (0s in MSB positions).
00001F7C                          1574  
00001F7C                          1575  * move A0 into D3 and split first part of address and second part of address 
00001F7C                          1576  *   to D3 and D4 respectively
00001F7C                          1577  
00001F7C                          1578  *D3:less significant word of address
00001F7C                          1579  *D4:more significant word of address 
00001F7C                          1580  *D5:holds iteration number
00001F7C                          1581  *D6:index into table
00001F7C                          1582  
00001F7C                          1583  h2a_regs        REG     D1/D3-D6/A0/A4
00001F7C                          1584  
00001F7C  48E7 5E88               1585  hex_2_ascii     MOVEM.L h2a_regs,-(SP)  *save state of registers before call                                
00001F80  4285                    1586                  CLR.L   D5              *clear iteration counter
00001F82  4281                    1587                  CLR.L   D1
00001F84  4286                    1588                  CLR.L   D6
00001F86  2808                    1589                  MOVE.L  A0,D4           *save address in D4
00001F88  2604                    1590                  MOVE.L  D4,D3           *and move it toD3
00001F8A  4244                    1591                  CLR.W   D4              *partition the first and second long of the address
00001F8C  4843                    1592                  SWAP    D3
00001F8E  49F9 00004000           1593  h2a_prep        LEA.L   string_tbl,A4
00001F94  E99C                    1594                  ROL.L   #4,D4           *roll first byte over for analysis
00001F96                          1595  h2a_loop       * move.b  1(a4,d6.l),d0
00001F96  B834 6801               1596                  CMP.B   1(A4,D6.L),D4   *find hex/ascii match in table
00001F9A  6700 0016               1597                  BEQ     h2a_match
00001F9E  BC3C 0020               1598                  cmp.b   #32,d6
00001FA2  6C00 0006               1599                  BGE     h2a_f 
00001FA6  5486                    1600                  ADDI.L  #2,D6
00001FA8  60EC                    1601                  BRA     h2a_loop
00001FAA  123C 000F               1602  h2a_f           MOVE.B  #$F,D1
00001FAE  6000 0006               1603                  BRA     h2a_match_cont        
00001FB2  1234 6000               1604  h2a_match       MOVE.B  (A4,D6.W),D1    *move the match to D1
00001FB6  103C 0006               1605  h2a_match_cont  MOVE.B  #6,D0           *display the value in D1
00001FBA  4E4F                    1606                  TRAP    #15
00001FBC  4204                    1607                  CLR.B   D4
00001FBE  4206                    1608                  CLR.B   D6
00001FC0  5245                    1609                  ADDI    #1,D5           *increment loop counter
00001FC2  BA3C 0008               1610                  CMP.B   #h2a_its,D5     *have we done every nibble
00001FC6  6C00 0012               1611                  BGE     h2a_ret
00001FCA  BA3C 0004               1612                  CMP.B   #h2a_its-4,D5   *are we halfway done (time to get second part of addr?)
00001FCE  6700 0004               1613                  BEQ     h2a_swap
00001FD2  60BA                    1614                  BRA     h2a_prep
00001FD4  2803                    1615  h2a_swap        MOVE.L  D3,D4           *move second part of word to D4 
00001FD6  4286                    1616                  CLR.L   D6              *clear the index into the string table               
00001FD8  60B4                    1617                  BRA     h2a_prep
00001FDA                          1618  
00001FDA  4CDF 117A               1619  h2a_ret         MOVEM.L  (SP)+,h2a_regs   *restore state of registers 
00001FDE  4E75                    1620                  RTS
00001FE0                          1621                  
00001FE0  =00000008               1622  h2a_its         EQU     8
00001FE0                          1623  
00001FE0                          1624  * /hex_2_ascii
00001FE0                          1625  *----------------------------------------------------------------------------------------- 
00001FE0                          1626  
00001FE0  48E7 0040               1627  print_comma   MOVEM.L A1,-(SP)
00001FE4  43F9 00004142           1628                LEA     comma,A1
00001FEA  103C 000E               1629                MOVE.B  #14,D0
00001FEE  4E4F                    1630                TRAP    #15    
00001FF0  4CDF 0200               1631                MOVEM.L (SP)+,A1
00001FF4  4E75                    1632                RTS    
00001FF6                          1633                
00001FF6  48E7 0040               1634  print_addr_sgn MOVEM.L A1,-(SP)
00001FFA  43F9 00004136           1635                 LEA     addr_sign,A1
00002000  103C 000E               1636                 MOVE.B  #14,D0
00002004  4E4F                    1637                 TRAP    #15    
00002006  4CDF 0200               1638                 MOVEM.L (SP)+,A1
0000200A  4E75                    1639                 RTS    
0000200C                          1640                 
0000200C  48E7 0040               1641  print_slash    MOVEM.L A1,-(SP)
00002010  43F9 00004144           1642                 LEA     slash,A1
00002016  103C 000E               1643                 MOVE.B  #14,D0
0000201A  4E4F                    1644                 TRAP    #15    
0000201C  4CDF 0200               1645                 MOVEM.L (SP)+,A1
00002020  4E75                    1646                 RTS    
00002022                          1647                 
00002022  48E7 0040               1648  print_hyphen   MOVEM.L A1,-(SP)
00002026  43F9 00004140           1649                 LEA     neg_sign,A1
0000202C  103C 000E               1650                 MOVE.B  #14,D0
00002030  4E4F                    1651                 TRAP    #15    
00002032  4CDF 0200               1652                 MOVEM.L (SP)+,A1
00002036  4E75                    1653                 RTS                 
00002038                          1654                 
00002038  43F9 00004146           1655  done          LEA     nl,A1
0000203E  103C 000E               1656                MOVE.B  #14,D0
00002042  4E4F                    1657                TRAP    #15
00002044  43F9 0000420E           1658                LEA     done_msg,A1
0000204A  103C 000E               1659                MOVE.B  #14,D0
0000204E  4E4F                    1660                TRAP    #15
00002050  103C 0009               1661                MOVE.B  #9,D0         *indicate end of simulation
00002054  4E4F                    1662                TRAP    #15
00002056                          1663                
00002056  43F9 000041E4           1664  addr_err      LEA     bad_addr,A1   *load the error msg into A1
0000205C  103C 000E               1665                MOVE.B  #14,D0       *indicate output
00002060  4E4F                    1666                TRAP    #15
00002062  43F9 00004146           1667                LEA     nl,A1        *load new line into A1
00002068  103C 000E               1668                MOVE.B  #14,D0        *indicate output
0000206C  4E4F                    1669                TRAP    #15
0000206E  4282                    1670                CLR.L   D2            *reset msb index for further iterations
00002070                          1671               * BRA     disp_msg      *go back to welcome msg
00002070                          1672                           
00002070  43F9 00004138           1673  fatal_err     LEA     imm_sign,A1   *load the error msg into A1
00002076  103C 000E               1674                MOVE.B  #14,D0       *indicate output
0000207A  4E4F                    1675                TRAP    #15
0000207C  43F9 00004146           1676                LEA     nl,A1        *load new line into A1
00002082  103C 000E               1677                MOVE.B  #14,D0        *indicate output
00002086  4E4F                    1678                TRAP    #15
00002088  4282                    1679                CLR.L   D2            *reset msb index for further iterations
0000208A  60AC                    1680                BRA     done         *go back to welcome msg
0000208C                          1681                
0000208C                          1682  *-------------------------------------------------------------------------------------------------------------------------------------------              
00004000                          1683  data          ORG     $4000
00004000                          1684                
00004000                          1685  *string table for converting user input addresses from ascii to hex      
00004000= 30 00                   1686  string_tbl    DC.B    $30,$0      *{ascii,hex}
00004002= 31 01                   1687                DC.B    $31,$1          
00004004= 32 02                   1688                DC.B    $32,$2 
00004006= 33 03                   1689                DC.B    $33,$3
00004008= 34 04                   1690                DC.B    $34,$4
0000400A= 35 05                   1691                DC.B    $35,$5
0000400C= 36 06                   1692                DC.B    $36,$6
0000400E= 37 07                   1693                DC.B    $37,$7
00004010= 38 08                   1694                DC.B    $38,$8
00004012= 39 09                   1695                DC.B    $39,$9            
00004014= 41 0A                   1696                DC.B    $41,$A
00004016= 42 0B                   1697                DC.B    $42,$B
00004018= 43 0C                   1698                DC.B    $43,$C
0000401A= 44 0D                   1699                DC.B    $44,$D
0000401C= 45 0E                   1700                DC.B    $45,$E
0000401E= 46 0F                   1701                DC.B    $46,$F
00004020                          1702                
00004020                          1703               *hex_1
00004020                          1704               *contains first hex digit of the instruction with corresponding mappings
00004020                          1705               *also contains all supported instructions in the comment field
00004020                          1706                * 1 means the mapping is ambiguous (and we have to read more bits in instruction) 0 means its not.
00004020                          1707                * -1 means the instruction isnt one that can be disassembled in this program             
00004020= 01 01                   1708  hex_1         DC.B    $01,$01  * 'MOVE.B','MOVEA.B'
00004022= 03 01                   1709                DC.B    $03,$01  * 'MOVE.W','MOVEA.W'
00004024= 02 01                   1710                DC.B    $02,$01  * 'MOVEA.L','MOVEA.L'
00004026= 04 01                   1711                DC.B    $04,$01  * 'MOVEM','LEA','NEG','JSR','RTS','NOP'
00004028= 0D 01                   1712                DC.B    $0D,$01  * 'ADD','ADDA'
0000402A= 00 01                   1713                DC.B    $00,$01  * 'ORI','BCLR','CMPI','ADDI','EORI','SUBI'
0000402C= 0B 01                   1714                DC.B    $0B,$01  * 'EOR','CMP'
0000402E= 0E 00                   1715                DC.B    $0E,$00  * 'LSR','LSL','ASR','ASL','ROL','ROR' (determined in shift_roll_handler)
00004030= 06 00                   1716                DC.B    $06,$00  * Bcc('BCS','BGE','BLT','BVC','BRA')
00004032= 09 00                   1717                DC.B    $09,$00  * 'SUB','SUBA' (determined in sub_handler)
00004034= 05 01                   1718                DC.B    $05,$01  * 'SUBQ','ADDQ'
00004036= 0C 00                   1719                DC.B    $0C,$00  * 'MULS'
00004038= 08 01                   1720                DC.B    $08,$01  * 'OR','DIVS(word)'
0000403A= FF FF                   1721                DC.B    -1,-1    * unsupported instruction-first hex val is not one in the table above
0000403C                          1722  
0000403C                          1723  *below table holds ascii codes for instruction printing
0000403C                          1724  *MOVEA         DC.L    'MOVEA',0
0000403C                          1725  *MOVEM         DC.L    'MOVEM',0              
0000403C= 4D4F5600 00000000       1726  MOV           DC.L    'MOV',0
00004044= 4C454100 00000000       1727  LEA           DC.L    'LEA',0
0000404C= 4E454700 00000000       1728  NEG           DC.L    'NEG',0 
00004054= 4A535200 00000000       1729  JSR           DC.L    'JSR',0
0000405C= 52545300 00000000       1730  RTS           DC.L    'RTS',0
00004064= 4E4F5000 00000000       1731  NOP           DC.L    'NOP',0
0000406C= 41444400 00000000       1732  ADD           DC.L    'ADD',0
00004074= 42434C00 00000000       1733  BCL           DC.L    'BCL',0
0000407C                          1734  *ADDA          DC.L    'ADDA',0
0000407C= 4F524900 00000000       1735  ORI           DC.L    'ORI',0
00004084                          1736  *BCLR          DC.L    'BCLR',0
00004084                          1737  *CMPI          DC.L    'CMPI',0
00004084= 454F5200 00000000       1738  EOR           DC.L    'EOR',0
0000408C= 434D5000 00000000       1739  CMP           DC.L    'CMP',0
00004094= 4C53 0000               1740  LS            DC.W    'LS',0    *LSL,LSR
00004098= 4153 0000               1741  AS            DC.W    'AS',0    *ASL,ASR
0000409C= 524F 0000               1742  RO            DC.W    'RO',0    *ROL,ROR
000040A0= 42435300 00000000       1743  BCS           DC.L    'BCS',0
000040A8= 42474500 00000000       1744  BGE           DC.L    'BGE',0
000040B0= 424C5400 00000000       1745  BLT           DC.L    'BLT',0
000040B8= 42564300 00000000       1746  BVC           DC.L    'BVC',0
000040C0= 42524100 00000000       1747  BRA           DC.L    'BRA',0
000040C8= 53554200 00000000       1748  SUB           DC.L    'SUB',0
000040D0= 4D554C00 00000000       1749  MUL           DC.L    'MUL',0
000040D8= 44495600 00000000       1750  DIV           DC.L    'DIV',0
000040E0= 4F52 0000               1751  OR            DC.W    'OR',0
000040E4= 44415400 00000000       1752  DAT           DC.L    'DAT',0   *DATA
000040EC= 494E5600 00000000       1753  INV           DC.L    'INV',0   *used for displaying unsupported addressing modes e.g --  MOVE.L 8(A4,D0),5(A4)
000040F4                          1754  
000040F4                          1755  *below holds extended codes to append to the instruction
000040F4= 41 00                   1756  A             DC.B    'A',0
000040F6= 49 00                   1757  I             DC.B    'I',0
000040F8= 52 00                   1758  R             DC.B    'R',0
000040FA= 4D 00                   1759  M             DC.B    'M',0
000040FC= 4C 00                   1760  L             DC.B    'L',0
000040FE= 51 00                   1761  Q             DC.B    'Q',0
00004100= 53 00                   1762  S             DC.B    'S',0
00004102= 45 00                   1763  E             DC.B    'E',0
00004104= 454D 0000               1764  EM            DC.W    'EM',0
00004108= 4541 0000               1765  EA            DC.W    'EA',0
0000410C                          1766  
0000410C                          1767  *below holds ascii size strings to load to variable SIZECODE            
0000410C= 2E42 0000               1768  SIZEB         DC.W    '.B',00
00004110= 2E57 0000               1769  SIZEW         DC.W    '.W',0
00004114= 2E4C 0000               1770  SIZEL         DC.W    '.L',00
00004118                          1771  SIZECODE      DS.L    1
0000411C                          1772  
0000411C                          1773  *below establishes lengths of data units
0000411C  =00000001               1774  byte_len      EQU     1
0000411C  =00000002               1775  word_len      EQU     2
0000411C  =00000004               1776  long_len      EQU     4            
0000411C                          1777                
0000411C                          1778  * holds the condition of each branch                
0000411C= 05                      1779  bcc_tbl       DC.B    %0101 *BCS
0000411D= 0C                      1780                DC.B    %1100 *BGE
0000411E= 0D                      1781                DC.B    %1101 *BLT
0000411F= 08                      1782                DC.B    %1000 *BVC
00004120= 00                      1783                DC.B    %0000 *BRA     
00004121= FF                      1784                DC.B    -1    *invalid branch type
00004122                          1785                
00004122                          1786  *below holds shift counts for arithmetic/logical shifts
00004122= 00                      1787  shift_tbl     DC.B    %000
00004123= 01                      1788                DC.B    %001
00004124= 02                      1789                DC.B    %010
00004125= 03                      1790                DC.B    %011
00004126= 04                      1791                DC.B    %100
00004127= 05                      1792                DC.B    %101
00004128= 06                      1793                DC.B    %110
00004129= 07                      1794                DC.B    %111                              
0000412A                          1795  
0000412A                          1796  *below variables hold the name of the instruction
0000412A                          1797  INST_NAME     DS.L    2         *holds the instruction to be printed (e.g. ADD.L; MOVE.B)
00004132                          1798  INST_NAME_EXT DS.L    1         *holds any part of instruction over 32 bits (eg last M in MOVEM)
00004136                          1799  
00004136                          1800  *below characters are used for printing
00004136= 24 00                   1801  addr_sign     DC.B    '$',0
00004138= 23 00                   1802  imm_sign      DC.B    '#',0
0000413A= 28 00                   1803  open_paren    DC.B    '(',0
0000413C= 29 00                   1804  closed_paren  DC.B    ')',0
0000413E= 2B 00                   1805  plus_sign     DC.B    '+',0
00004140= 2D 00                   1806  neg_sign      DC.B    '-',0
00004142= 2C 00                   1807  comma         DC.B    ',',0
00004144= 2F 00                   1808  slash         DC.B    '/',0
00004146= 0D 0A 00                1809  nl            DC.B    '',CR,LF,0
00004149= 20 20 20 20 00          1810  space         DC.B    '    ',0
0000414E                          1811  
0000414E                          1812  *below holds intro messages to user                       
0000414E= 50 6C 65 61 73 65 ...   1813  display_start DC.B    'Please enter a maximum 32-bit starting memory address in hex (-1 to quit): ',0
0000419A= 50 6C 65 61 73 65 ...   1814  display_end   DC.B    'Please enter a maximum 32-bit ending memory address in hex (-1 to quit): ',0
000041E4= 50 6C 65 61 73 65 ...   1815  bad_addr      DC.B    'Please enter a valid address',CR,LF,0
00004203                          1816  
00004203                          1817  
00004203                          1818  *below variables store the starting and ending addresses the user provides
00004204                          1819  user_start    DS.L    1
00004208                          1820  user_end      DS.L    1
0000420C                          1821  
0000420C= 2D31                    1822  exit_val      DC.W    $2D31  *sentinel exit value
0000420E                          1823               
0000420E= 64 6F 6E 65 00          1824  done_msg      DC.B    'done',0
00004213                          1825  
00004213                          1826  
00004213                          1827                END     start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A                   40F4
A0_MESS             1EA6
A1_MESS             1EB8
A2_MESS             1ECA
A3_MESS             1EDC
A4_MESS             1EEE
A5_MESS             1F00
A6_MESS             1F12
A7_MESS             1F24
ADD                 406C
ADDA_BEG            1358
ADDA_HANDLER        134E
ADDA_LONG_HANDLER   137E
ADDA_SAVE_DATA      138C
ADDA_WORD_HANDLER   136C
ADDI_HANDLER        173C
ADDQ_HANDLER        15EC
ADDRESS_MODE        1C8C
ADDR_ERR            2056
ADDR_SIGN           4136
ADD_HANDLER         1492
AS                  4098
AS_HANDLER          1956
AS_REG              1A0A
BAD_ADDR            41E4
BCC_CALC            18D4
BCC_COMPLETE        18E8
BCC_COND            183C
BCC_DETERMINER      184C
BCC_DISPM           18BA
BCC_HANDLER         1830
BCC_LONG_HANDLER    18E4
BCC_TBL             411C
BCC_WORD_HANDLER    18E0
BCL                 4074
BCLR_DYNAMIC        16CC
BCLR_STATIC         1680
BCS                 40A0
BCS_HANDLER         1878
BGE                 40A8
BGE_HANDLER         1886
BLT                 40B0
BLT_HANDLER         1894
BRA                 40C0
BRA_HANDLER         18B0
BVC                 40B8
BVC_HANDLER         18A2
BYTE_LEN            1
CASE_QUICK8         15E6
CHECK_FIRST         1064
CLOSED_PARAN        1CD8
CLOSED_PAREN        413C
CMP                 408C
CMPA_HANDLER        13C0
CMPA_OR_CMP         12C2
CMPI_BYTE           162C
CMPI_HANDLER        15FA
CMPI_LONG           1650
CMPI_RET            165E
CMPI_WORD           163E
CMP_HANDLER         14DE
COMMA               4142
CR                  D
D0_MESS             1E16
D1_MESS             1E28
D2_MESS             1E3A
D3_MESS             1E4C
D4_MESS             1E5E
D5_MESS             1E70
D6_MESS             1E82
D7_MESS             1E94
DAT                 40E4
DATA                4000
DATA_MODE           1DCC
DATA_MODE_PRINT     1DEE
DATA_REGISTER       1C94
DISPLAY_END         419A
DISPLAY_START       414E
DISP_INSTR          1F28
DIV                 40D8
DIVSW_BEG           1504
DIVSW_HANDLER       14F0
DONE                2038
DONE_MSG            420E
DR_CMP              1C98
E                   4102
EA                  4108
EA_SRC              1C26
EA_SRC_BEG          1C22
EM                  4104
EOR                 4084
EORI_HANDLER        176E
EOR_HANDLER         14CC
EXIT_VAL            420C
FATAL_ERR           2070
FILTER_EA_MODE      1C5A
GET_DATA            1310
H2A_F               1FAA
H2A_ITS             8
H2A_LOOP            1F96
H2A_MATCH           1FB2
H2A_MATCH_CONT      1FB6
H2A_PREP            1F8E
H2A_REGS            117A
H2A_RET             1FDA
H2A_SWAP            1FD4
HEX_1               4020
HEX_2_ASCII         1F7C
I                   40F6
IMM_SIGN            4138
INST_NAME           412A
INST_NAME_EXT       4132
INST_PARSE          10AC
INV                 40EC
INVALID_MODE        1C7C
INV_HANDLER         1076
IS_IT_MOVEM         121E
JSR                 4054
JSR_HANDLER         1AB6
L                   40FC
LEA                 4044
LEA_HANDLER         1A82
LEA_RESOLVE         1204
LF                  A
LONG_DATA_HANDLER   1DE8
LONG_LEN            4
LONG_MODE           1DB2
LS                  4094
LS_HANDLER          1964
LS_REG              1A18
M                   40FA
MATCH_FOUND         10A0
MOV                 403C
MOVEA_HANDLER       112E
MOVEM_AN            1AF2
MOVEM_AN_LIST_LOOP  1BF2
MOVEM_AN_LIST_PREP  1BDE
MOVEM_CHECK         122E
MOVEM_DN            1B16
MOVEM_DN_CONT       1B6A
MOVEM_DN_FULL       1BC8
MOVEM_DN_LAST       1BDC
MOVEM_DN_LIST_LOOP  1B38
MOVEM_DN_LIST_STATUS  1B60
MOVEM_DN_LIST_STATUS_0  1B4A
MOVEM_DN_LIST_STATUS_1  1B5E
MOVEM_EA            1BF6
MOVEM_HANDLER       1AD6
MOVEM_LIST          1B1E
MOVEM_LIST_FIRST_ENTRY  1B74
MOVEM_LONG          1B08
MOVEM_PRINT_SINGLE  1BAA
MOVEM_RESOLVE       1214
MOVEM_WORD          1AFA
MOVE_EA             1138
MOVE_HANDLER        1120
MUL                 40D0
MULS_HANDLER        152A
NEG                 404C
NEG_BYTE            17FA
NEG_HANDLER         17D2
NEG_LONG            1816
NEG_RESOLVE         11E6
NEG_RET             1820
NEG_SIGN            4140
NEG_WORD            1808
NL                  4146
NOP                 4064
NOP_HANDLER         1338
OPEN_PAREN          413A
OR                  40E0
ORI                 407C
ORI_HANDLER         1708
OR_BYTE             1418
OR_DN_LEFT          13F6
OR_DN_RIGHT         13EC
OR_EA               144A
OR_HANDLER          13CC
OR_LEFT_PRINT       147A
OR_LONG             143C
OR_SIZE             1400
OR_WORD             142A
PLUS_SIGN           413E
POSTFIX_PLUS        1D3C
PREFIX_MINUS        1D6A
PREP                1014
PRINT_A0            1E98
PRINT_A1            1EAA
PRINT_A2            1EBC
PRINT_A3            1ECE
PRINT_A4            1EE0
PRINT_A5            1EF2
PRINT_A6            1F04
PRINT_A7            1F16
PRINT_ADDR_SGN      1FF6
PRINT_COMMA         1FE0
PRINT_D0            1E08
PRINT_D1            1E1A
PRINT_D2            1E2C
PRINT_D3            1E3E
PRINT_D4            1E50
PRINT_D5            1E62
PRINT_D6            1E74
PRINT_D7            1E86
PRINT_HYPHEN        2022
PRINT_INNER_AN      1CFC
PRINT_LIST_INTERMEDIATE  1B88
PRINT_SLASH         200C
Q                   40FE
Q_PRINTS            15C4
R                   40F8
RO                  409C
RO_HANDLER          1972
RO_REG              1A26
RS_0_SHIFT_HANDLER  1A58
RTS                 405C
RTS_HANDLER         1C0C
S                   4100
SHIFT_TBL           4122
SIZEB               410C
SIZECODE            4118
SIZEL               4114
SIZEW               4110
SLASH               4144
SPACE               4149
SR_BYTE             19C0
SR_LONG             19DC
SR_MEM              193A
SR_MEM_RET          1980
SR_REG              1994
SR_REG_FINAL        1A5E
SR_REG_PRINT_DN     1A50
SR_REG_PRINT_IMM    1A48
SR_REG_PRINT_SRC    1A34
SR_REG_RET          19EA
SR_REG_TYPE         19A2
SR_REG_TYPE_BEG     19A6
SR_TYPE_RESOLVE     191A
SR_TYPE_RESOLVE_BEG  1924
SR_WORD             19CE
STACK               7000
START               1000
START_ADDR          1000
STRING_TBL          4000
SUB                 40C8
SUBA_HANDLER        13B4
SUBI_HANDLER        17A0
SUBQ_BYTE           1576
SUBQ_DET            154C
SUBQ_EA             15AE
SUBQ_HANDLER        1542
SUBQ_LONG           159A
SUBQ_WORD           1588
SUB_HANDLER         14A8
USER_END            4208
USER_START          4204
WORD_DATA_HANDLER   1DE2
WORD_LEN            2
WORD_MODE           1D98
_0_HANDLER          124E
_11_HANDLER         1294
_11_RESOLVE         12A4
_13_HANDLER         1238
_1_HANDLER          10F6
_2_HANDLER          118C
_3_HANDLER          1162
_4_HANDLER          11BA
_4_RESOLVE          11F6
_5_HANDLER          1300
_8_CHECK            12EE
_8_HANDLER          12D2
_SHIFT_ROLL_HANDLER  1900
