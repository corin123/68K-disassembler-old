00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/16/2018 10:45:04 PM

00000000                             1  *-----------------------------------------------------------------------------------------------
00000000                             2  *                                  Disassembler program
00000000                             3  *                                      Winter 2018
00000000                             4  * Description: A program to disassemble selected instructions from the Motorola 68k IS opcodes
00000000                             5  *                         
00000000                             6  *                          Sean Coulter, Corin Ennis, Antony Mbugua
00000000                             7  *-----------------------------------------------------------------------------------------------            
00000000                             8              
00000000  =0000000D                  9  CR         EQU   $0D
00000000  =0000000A                 10  LF         EQU   $0A
00000000  =00007000                 11  stack      EQU   $7000
00000000  =00001000                 12  start_addr EQU   $1000
00000000                            13             
00001000                            14  start      ORG     start_addr             
00001000                            15                
00001000                            16   *----------------*display starting information for user, capture start and end addresses, error check on addresses------------------------------
00001000                            17  *----------------for each ascii character the user enters, if that character is outside [30,40) (40,46], its an invalid character---------------
00001000                            18      *A2: points to starting address
00001000                            19      *A3: points to ending address
00001000                            20      *A4: points to ascii/hex string table
00001000                            21      
00001000                            22      *D1: sentinel exit value
00001000                            23      *D2: index of MSB
00001000                            24      *D3: holds the next byte of the user starting address
00001000                            25      *D4: offset of string table value
00001000                            26      *D6: ascii value holding MSB
00001000                            27      *D7: max valid input
00001000                            28  
00001000  4FF8 7000                 29                LEA     stack, SP         *put the stack in the stack pointer
00001004                            30                
00001004  DBFC 00012000             31                adda.l #$12000,a5
0000100A  DDFC 00013000             32                adda.l #$13000,a6
00001010                            33                
00001010                            34                
00001010                            35  *------------------At this point, A5 holds starting address and A6 holds ending address. --------------------------------
00001010                            36  *A5: start
00001010                            37  *A6: end
00001010                            38  *A4: pointer to hex_1 table and bcc_tbl
00001010                            39  *D1: holds the next hex to be read in instruction
00001010                            40  *D2: holds the instruction
00001010                            41  
00001010                            42  
00001010                            43                
00001010  4244                      44                CLR      D4                 *register used in address calculation
00001012  4247                      45                CLR      D7                 *register used for address calculation
00001014                            46  
00001014  BDCD                      47  prep          CMPA.L   A5,A6              *have we read from start-end?
00001016  6D00 10DA                 48                BLT      done               * yes-end            
0000101A  103C 0005                 49                MOVE.B   #5,D0              *pause for user to hit enter
0000101E  4E4F                      50                TRAP     #15
00001020  43F9 0000417C             51                LEA      nl,A1              *make an new line
00001026  103C 000E                 52                MOVE.B   #14,D0
0000102A  4E4F                      53                TRAP     #15
0000102C  49F9 00004020             54                LEA      hex_1,A4           *pointer to hex_1 table in A4
00001032  227C 00000000             55                MOVEA.L  #0,A1              *clearing variables
00001038  23FC 00000000 00004148    56                MOVE.L   #0,SIZECODE
00001042  23FC 00000000 00004168    57                MOVE.L   #0,INST_NAME_EXT
0000104C                            58                *EOR      D0,D0
0000104C  4280                      59                CLR.L    D0
0000104E  4281                      60                CLR.L    D1
00001050  4282                      61                CLR.L    D2
00001052  4283                      62                CLR.L    D3
00001054  4284                      63                CLR.L    D4
00001056  4285                      64                CLR.L    D5
00001058  4286                      65                CLR.L    D6
0000105A  4287                      66                CLR.L    D7            
0000105C  3215                      67                MOVE.W   (A5),D1            *move the instruction thats pointed to by starting address
0000105E  2641                      68                MOVE.L   D1,A3              *and copy it to A3
00001060  4841                      69                SWAP     D1
00001062  E999                      70                ROL.L    #4,D1              *isolate the first hex digit
00001064                            71               
00001064  B21C                      72  check_first   CMP.B   (A4)+,D1            *compare with the next value in the hex table
00001066  6700 0038                 73                BEQ     match_found         *theres a match with the value in the table
0000106A  524C                      74                ADDA    #1,A4               *increment the pointer to the table
0000106C  0C14 00FF                 75                CMP.B   #$FF,(A4)           *have we reached the end of the hex table?
00001070  6700 0004                 76                BEQ     inv_handler         * yes-no matches (so output DATA)
00001074  60EE                      77                BRA     check_first         *keep searching through the table for a match           
00001076                            78       
00001076                            79  *-----------------------------------------------------------------------------
00001076                            80  * inv_handler
00001076                            81  * handles unsupported instruction names
00001076                            82  * prints DATA for instruction name 
00001076                            83                  
00001076  23F9 00004114 00004160    84  inv_handler   MOVE.L  DAT,INST_NAME
00001080  23F9 00004124 00004168    85                MOVE.L  A,INST_NAME_EXT
0000108A  4EB9 00001FE0             86                JSR     disp_instr
00001090  204B                      87                MOVE.L  A3,A0
00001092  4EB9 00002034             88                JSR     hex_2_ascii       *convert/display the unsupported opcode
00001098  DAFC 0002                 89                ADDA    #word_len,A5
0000109C  6000 FF76                 90                BRA     prep
000010A0                            91                
000010A0                            92  * /inv_handler
000010A0                            93  *-----------------------------------------------------------------------------
000010A0                            94  
000010A0                            95  **below functions handle instructions that are supported in this program**
000010A0                            96  
000010A0  0C14 0001                 97  match_found   CMP.B   #1,(A4)             *check if the mapping is ambiguous
000010A4  6700 0006                 98                BEQ     inst_parse          * it is- get the next hex digit
000010A8  6000 0268                 99                BRA     get_data            * its not-- just branch straight to the corresponding function
000010AC                           100                            
000010AC  B23C 0001                101  inst_parse    CMP.B   #1,D1            *based on the first digit, decide how to decode next value.
000010B0  6700 0044                102                BEQ     _1_handler
000010B4  B23C 0003                103                CMP.B   #3,D1
000010B8  6700 00A8                104                BEQ     _3_handler
000010BC  B23C 0002                105                CMP.B   #2,D1
000010C0  6700 00CA                106                BEQ     _2_handler
000010C4  B23C 0004                107                CMP.B   #4,D1
000010C8  6700 00F0                108                BEQ     _4_handler
000010CC  B23C 000D                109                CMP.B   #13,D1
000010D0  6700 0168                110                BEQ     _13_handler
000010D4  B23C 0000                111                CMP.B   #0,D1
000010D8  6700 0176                112                BEQ     _0_handler
000010DC  B23C 000B                113                CMP.B   #11,D1
000010E0  6700 01B4                114                BEQ     _11_handler
000010E4  B23C 0008                115                CMP.B   #8,D1
000010E8  6700 01EA                116                BEQ     _8_handler
000010EC  B23C 0005                117                CMP.B   #5,D1
000010F0  6700 0210                118                BEQ     _5_handler
000010F4  6080                     119                BRA     inv_handler
000010F6                           120  
000010F6                           121  *The following functions determine where to go if the first hex value is shared between instructions             
000010F6                           122  *---------------           
000010F6  4201                     123  _1_handler    CLR.B   D1
000010F8  23F9 0000403C 00004160   124                MOVE.L  MOV,INST_NAME
00001102  23F9 0000413C 00004148   125                MOVE.L  SIZEB,SIZECODE
0000110C  14BC 0000                126                MOVE.B  #0,(A2)        *flag data as byte
00001110  E799                     127                ROL.L   #3,D1          *isolate dest. An or Dn bits (t.b.d. if MOVE or MOVEA)
00001112  1401                     128                MOVE.B  D1,D2          *and move them to D2
00001114  4201                     129                CLR.B   D1
00001116  E799                     130                ROL.L   #3,D1          *isolate dest. mode bits in D1.B
00001118  B23C 0001                131                CMP.B   #1,D1          *is mode == 001?
0000111C  6700 0010                132                BEQ     movea_handler * yes- its movea
00001120                           133                
00001120  23F9 00004132 00004168   134  move_handler MOVE.L  E,INST_NAME_EXT
0000112A  6000 000C                135               BRA     move_ea
0000112E                           136  
0000112E  23F9 00004138 00004168   137  movea_handler MOVE.L EA,INST_NAME_EXT     
00001138                           138  
00001138  1801                     139  move_ea       MOVE.B D1,D4         *save dest mode bits to D4
0000113A  4201                     140                CLR.B  D1
0000113C  E799                     141                ROL.L  #3,D1
0000113E  2601                     142                MOVE.L D1,D3         *save source mode/reg bits in D3
00001140  4EB9 00001FE0            143                JSR    disp_instr    *print MOVEA.(X) or MOVE.(X)
00001146  4EB9 00001CDA            144                JSR    EA_SRC_beg    *print source information
0000114C                           145                
0000114C  E69A                     146                ROR.L  #3,D2         *roll dest register bits to left fringe
0000114E  1404                     147                MOVE.B D4,D2         *move dest mode bits to right fringe
00001150  2602                     148                MOVE.L D2,D3         *move these same bits to D3
00001152  4EB9 0000209A            149                JSR    print_comma
00001158  4EB9 00001CDE            150                JSR    EA_SRC        *prints destination mode/register
0000115E  6000 FEB4                151                BRA    prep
00001162                           152  
00001162                           153  *--------------- 
00001162                           154  *---------------
00001162  4201                     155  _3_handler    CLR.B   D1
00001164  23F9 0000403C 00004160   156                MOVE.L  MOV,INST_NAME
0000116E  23F9 00004140 00004148   157                MOVE.L  SIZEW,SIZECODE
00001178  14BC 0001                158                MOVE.B  #1,(A2)        *flag data as word
0000117C  E799                     159                ROL.L   #3,D1          *isolate dest. An or Dn bits (t.b.d. if MOVE or MOVEA)
0000117E  1401                     160                MOVE.B  D1,D2          *and move them to D2
00001180  4201                     161                CLR.B   D1
00001182  E799                     162                ROL.L   #3,D1          *isolate dest. mode bits in D1.B
00001184  B23C 0001                163                CMP.B   #1,D1          *is mode == 001?
00001188  67A4                     164                BEQ     movea_handler * yes- its movea (function is subset of _1_handler)
0000118A  6094                     165                BRA     move_handler  * no- its move (function is subset of _1_handler)
0000118C                           166                
0000118C                           167  *--------------- 
0000118C                           168  *--------------- 
0000118C  4201                     169  _2_handler    CLR.B   D1
0000118E  23F9 0000403C 00004160   170                MOVE.L  MOV,INST_NAME
00001198  23F9 00004144 00004148   171                MOVE.L  SIZEL,SIZECODE
000011A2  14BC 0002                172                MOVE.B  #2,(A2)        *flag data as long
000011A6  E799                     173                ROL.L   #3,D1          *isolate dest. An or Dn bits (t.b.d. if MOVE or MOVEA)
000011A8  1401                     174                MOVE.B  D1,D2          *and move them to D2
000011AA  4201                     175                CLR.B   D1
000011AC  E799                     176                ROL.L   #3,D1          *isolate dest. mode bits in D1.B
000011AE  B23C 0001                177                CMP.B   #1,D1          *is mode == 001?
000011B2  6700 FF7A                178                BEQ     movea_handler * yes- its movea (function is subset of _1_handler)
000011B6  6000 FF68                179                BRA     move_handler  * no- its move (function is subset of _1_handler)
000011BA                           180  
000011BA                           181  *--------------- 
000011BA                           182  *--------------- 
000011BA  B6FC 4E71                183  _4_handler    CMP.W   #$4E71,A3        *is it nop
000011BE  6700 017A                184                BEQ     nop_handler      * its nop
000011C2  B6FC 4E75                185                CMP.W   #$4E75,A3        *is it rts
000011C6  6700 0AF8                186                BEQ     rts_handler      * its rts
000011CA  4201                     187                CLR.B   D1               *get byte space ready for next digit
000011CC  E999                     188                ROL.L   #4,D1            *get the next digit
000011CE  2401                     189                MOVE.L  D1,D2            *make a temp copy
000011D0  E59A                     190                ROL.L   #2,D2            *get another 3 bits
000011D2  B43C 003A                191                CMP.B   #$3A,D2          *is 3A in the byte position
000011D6  6700 09C4                192                BEQ     jsr_handler      * yes its jsr
000011DA  B23C 0004                193                CMP.B   #4,D1            *is the next digit 4
000011DE  6700 0006                194                BEQ     neg_resolve      * neg or MOVE to CCR
000011E2  6000 0012                195                BRA     _4_resolve       *now its either lea,movem,unsupported
000011E6  4202                     196  neg_resolve   CLR.B   D2
000011E8  E51A                     197                ROL.B   #2,D2
000011EA  B43C 0003                198                CMP.B   #3,D2
000011EE  6D00 060C                199                BLT     neg_handler
000011F2  6000 FE82                200                BRA     inv_handler                                       
000011F6  2401                     201  _4_resolve    MOVE.L  D1,D2            *make a full copy to D2
000011F8  2801                     202                MOVE.L  D1,D4            *make another full copy
000011FA  E20A                     203                LSR.B   #1,D2            *lea and movem differentiated by current MSB        
000011FC  6500 0006                204                BCS     lea_resolve      * carry set- lea or unsupported
00001200  6000 0014                205                BRA     movem_resolve    * carry not set-movem or unsupported
00001204  4202                     206  lea_resolve   CLR.B   D2
00001206  E59A                     207                ROL.L   #2,D2            *lea is unique in bits d8 to d6. use previous copy D2
00001208  ED0A                     208                LSL.B   #6,D2            *shift out 0 pad and remaining An bits
0000120A  B43C 00C0                209                CMP.B   #$C0,D2          *is result 11000000?
0000120E  6700 0958                210                BEQ     lea_handler      * lea
00001212  6000 FE62                211                BRA     inv_handler      * unsupported
00001216  E39C                     212  movem_resolve ROL.L   #1,D4
00001218  B83C 0019                213                CMP.B   #25,D4
0000121C  6600 0012                214                BNE     movem_check      *last check on movem
00001220  4204                     215  is_it_movem   CLR.B   D4               *this is either MOVEM register to memory or EXT
00001222  E79C                     216                ROL.L   #3,D4            *get ea mode into d2
00001224  B83C 0000                217                CMP.B   #0,D4            *is the ea mode 000?
00001228  6700 FE4C                218                BEQ     inv_handler      * yes-ea mode is data register-- cant be movem
0000122C  6000 098E                219                BRA     movem_handler    * no-its movem
00001230                           220                
00001230  B83C 0011                221  movem_check   CMP.B   #17,D4          
00001234  6600 FE40                222                BNE     inv_handler      *we can be sure its not movem now
00001238  60E6                     223                BRA     is_it_movem      *EXT or MOVEM
0000123A                           224                        
0000123A                           225  *--------------- 
0000123A                           226  *--------------- 
0000123A  4201                     227  _13_handler     CLR.B   D1
0000123C  E999                     228                  ROL.L   #4,D1
0000123E  2401                     229                  MOVE.L  D1,D2          *make a copy
00001240  4202                     230                  CLR.B   D2             *clear byte space for next roll
00001242  E59A                     231                  ROL.L   #2,D2          *get size bits
00001244  B43C 0003                232                  CMP.B   #3,D2          *are size bits 11?
00001248  6700 0108                233                  BEQ     adda_handler
0000124C  6000 0248                234                  BRA     add_handler
00001250                           235  
00001250                           236  *--------------- 
00001250                           237  *--------------- 
00001250  4201                     238  _0_handler      CLR.B D1
00001252  E999                     239                  ROL.L #4,D1         *the next 4 bits will determine the instruction exactly
00001254  B23C 0000                240                  CMP.B #0,D1
00001258  6700 04D8                241                  BEQ   ori_handler
0000125C  B23C 0004                242                  CMP.B #4,D1
00001260  6700 0568                243                  BEQ   subi_handler
00001264  B23C 000A                244                  CMP.B #$A,D1
00001268  6700 052E                245                  BEQ   eori_handler
0000126C  B23C 0008                246                  CMP.B #8,D1
00001270  6700 043A                247                  BEQ   bclr_static
00001274  B23C 000C                248                  CMP.B #$C,D1
00001278  6700 03A4                249                  BEQ   cmpi_handler
0000127C  B23C 0006                250                  CMP.B #6,D1
00001280  6700 04E4                251                  BEQ   addi_handler
00001284                           252                                      *at this point its BCLR or its unsupported
00001284  2401                     253                  MOVE.L D1,D2        *make a copy
00001286  4202                     254                  CLR.B  D2
00001288  E59A                     255                  ROL.L  #2,D2        *get next 2 hardcoded bits
0000128A  B43C 0002                256                  CMP.B  #2,D2        *BCLR bits defined as 10
0000128E  6700 0466                257                  BEQ    bclr_dynamic  *BCLR with a Dn (dynamic)
00001292  6000 FDE2                258                  BRA    inv_handler   *unsupported instruction
00001296                           259  
00001296                           260  *--------------- 
00001296                           261  *--------------- 
00001296  4201                     262  _11_handler     CLR.B   D1          
00001298  E999                     263                  ROL.L   #4,D1      *get next hex digit
0000129A  2401                     264                  MOVE.L  D1,D2      *make a temp copy
0000129C  E20A                     265                  LSR.B   #1,D2      * eor and cmp can be differentiated by lsb in 2nd digit. check carry
0000129E  6500 0006                266                  BCS     _11_resolve  *check if its eor,cpma(long), or cmpm(unsupported)
000012A2  6000 0020                267                  BRA     cmpa_or_cmp  *its cmp or cmpa
000012A6  2401                     268  _11_resolve     MOVE.L  D1,D2       *make a copy
000012A8  4202                     269                  CLR.B   D2
000012AA  E59A                     270                  ROL.L   #2,D2
000012AC  B43C 0003                271                  CMP.B   #3,D2
000012B0  6700 0112                272                  BEQ     cmpa_handler    *its cmpa (long)
000012B4  4202                     273                  CLR.B   D2              *down to eor or cmpm
000012B6  E79A                     274                  ROL.L   #3,D2           *get EA mode
000012B8  B43C 0001                275                  CMP.B   #1,D2
000012BC  6700 FDB8                276                  BEQ     inv_handler     *cmpm
000012C0  6000 020E                277                  BRA     eor_handler     *eor
000012C4  4202                     278  cmpa_or_cmp     CLR.B   D2
000012C6  E59A                     279                  ROL.L   #2,D2           *get the size code
000012C8  B43C 0003                280                  CMP.B   #3,D2           *whats the size code
000012CC  6700 00F6                281                  BEQ     cmpa_handler    * size code 11-cmpa
000012D0  6000 0210                282                  BRA     cmp_handler     * size code !11-cmp
000012D4                           283  
000012D4                           284  *---------------
000012D4                           285  *---------------
000012D4  4201                     286  _8_handler      CLR.B   D1
000012D6  E999                     287                  ROL.L   #4,D1
000012D8  2401                     288                  MOVE.L  D1,D2
000012DA  E20A                     289                  LSR.B   #1,D2
000012DC  6500 0012                290                  BCS     _8_check              
000012E0  4202                     291                  CLR.B   D2                  *carry not set- OR or DIVU
000012E2  E59A                     292                  ROL.L   #2,D2
000012E4  B43C 0003                293                  CMP.B   #3,D2
000012E8  6700 FD8C                294                  BEQ     inv_handler         *DIVU
000012EC  6000 00E2                295                  BRA     or_handler
000012F0                           296                  
000012F0  4202                     297  _8_check        CLR.B   D2                  *its OR, DIVS, or SBCD
000012F2  E59A                     298                  ROL.L   #2,D2
000012F4  B43C 0003                299                  CMP.B   #3,D2
000012F8  6700 01FA                300                  BEQ     divsw_handler       *between or and divs.w, only divs.w can have a size 11
000012FC  4202                     301                  CLR.B   D2
000012FE  6000 00D0                302                  BRA     or_handler          *figure out if its OR or SBCD in here
00001302                           303                      
00001302                           304  *---------------
00001302                           305  *--------------- 
00001302  4201                     306  _5_handler      CLR.B   D1
00001304  E999                     307                  ROL.L   #4,D1
00001306  1401                     308                  MOVE.B  D1,D2               *D2 now holds the immediate data
00001308  E20A                     309                  LSR.B   #1,D2               *check if carry is set-- this will determine branch
0000130A  6500 025A                310                  BCS     subq_handler
0000130E  6000 0300                311                  BRA     addq_handler
00001312                           312                  
00001312                           313  *---------------
00001312                           314  *--------------- 
00001312                           315  
00001312                           316  *we can go directly to the function since the first hex val maps directly to an instruction
00001312  B23C 0006                317  get_data      CMP.B   #6,D1
00001316  6700 0542                318                BEQ     bcc_handler
0000131A  B23C 000E                319                CMP.B   #$E,D1
0000131E  6700 06BA                320                BEQ     _shift_roll_handler
00001322  B23C 0009                321                CMP.B   #9,D1
00001326  6700 0184                322                BEQ     sub_handler
0000132A  B23C 0005                323                CMP.B   #5,D1
0000132E  6700 0236                324                BEQ     subq_handler
00001332  B23C 000C                325                CMP.B   #$C,D1
00001336  6700 01FE                326                BEQ     muls_handler
0000133A                           327  *----------------------------------------------------------------------------
0000133A                           328  *----------------------------------------------------------------------------              
0000133A                           329  *----------------------------------------------------------------------------
0000133A                           330  *nop_handler
0000133A                           331  *handles 'NOP'
0000133A                           332  
0000133A  23F9 00004064 00004160   333  nop_handler   MOVE.L  NOP,INST_NAME 
00001344  DAFC 0002                334                ADDA    #word_len,A5         *nop took up a word- set A5 to the next instruction
00001348  4EB9 00001FE0            335                JSR     disp_instr
0000134E  6000 FCC4                336                BRA     prep
00001352                           337  
00001352                           338  * /nop_handler
00001352                           339  *----------------------------------------------------------------------------
00001352                           340  
00001352                           341  
00001352                           342  *----------------------------------------------------------------------------
00001352                           343  *adda_handler
00001352                           344  *handles 'ADDA'
00001352                           345  
00001352  23F9 0000406C 00004160   346  adda_handler       MOVE.L ADD,INST_NAME  *we know its valid instr ADDA
0000135C  33F9 00004124 00004168   347  adda_beg           MOVE.W A,INST_NAME_EXT
00001366  E209                     348                     LSR.B  #1,D1                *send the size bit to carry
00001368  6500 0018                349                     BCS    adda_long_handler    *carry is set->ADDA.W
0000136C  6000 0002                350                     BRA    adda_word_handler    *carry not set->ADDA.L
00001370                           351                     
00001370  23F9 00004140 00004148   352  adda_word_handler  MOVE.L SIZEW,SIZECODE
0000137A  14BC 0001                353                     MOVE.B #1,(A2)
0000137E  6000 0010                354                     BRA    adda_save_data
00001382                           355                     
00001382  23F9 00004144 00004148   356  adda_long_handler  MOVE.L SIZEL,SIZECODE
0000138C  14BC 0002                357                     MOVE.B #2,(A2)
00001390                           358                              
00001390  4EB9 00001FE0            359  adda_save_data     JSR    disp_instr
00001396  1A01                     360                     MOVE.B D1,D5             *move the 3 An bits to D5 temporarily
00001398  E599                     361                     ROL.L  #2,D1             *get hardcoded size bits
0000139A  4201                     362                     CLR.B  D1                *and clear the byte space
0000139C  E799                     363                     ROL.L  #3,D1
0000139E  2601                     364                     MOVE.L D1,D3             *send EA bits to D3
000013A0  4EB9 00001CDA            365                     JSR    EA_SRC_beg
000013A6  4EB9 0000209A            366                     JSR    print_comma
000013AC  C745                     367                     EXG    D3,D5             *send An bits to D3 for function call
000013AE  4EB9 00001DB4            368                     JSR    PRINT_INNER_An
000013B4  6000 FC5E                369                     BRA    prep                     
000013B8                           370  
000013B8                           371  * /adda_handler
000013B8                           372  *----------------------------------------------------------------------------
000013B8                           373  
000013B8                           374  
000013B8                           375  *-----------------------------------------------------------------------------
000013B8                           376  * suba_handler
000013B8                           377  * handles 'SUBA'
000013B8                           378  
000013B8                           379  *uses adda_handler due to similar bit layout
000013B8                           380  
000013B8  23F9 000040F8 00004160   381  suba_handler       MOVE.L   SUB,INST_NAME
000013C2  6098                     382                     BRA      adda_beg
000013C4                           383  
000013C4                           384  * /suba_handler
000013C4                           385  *-----------------------------------------------------------------------------
000013C4                           386  
000013C4                           387  
000013C4                           388  *-----------------------------------------------------------------------------
000013C4                           389  * cmpa_handler
000013C4                           390  * handles 'CMPA'
000013C4                           391  
000013C4                           392  *uses adda_handler due to similar bit layout
000013C4                           393  
000013C4  23F9 0000408C 00004160   394  cmpa_handler       MOVE.L   CMP,INST_NAME
000013CE  608C                     395                     BRA      adda_beg
000013D0                           396  
000013D0                           397  * /cmpa_handler
000013D0                           398  *-----------------------------------------------------------------------------
000013D0                           399  
000013D0                           400  
000013D0                           401  *-----------------------------------------------------------------------------
000013D0                           402  *or_handler
000013D0                           403  *handles 'OR'
000013D0                           404  
000013D0                           405  *D7 holds the direction flag
000013D0                           406  *D5 holds source/destination bits
000013D0                           407  *D4 holds the 2 size bits
000013D0                           408  *D3 holds the parameters used for jumps to EA handlers
000013D0                           409  
000013D0                           410  *Dn_left means the Dn is the dest
000013D0                           411  *Dn_right means the Dn is the source
000013D0                           412  
000013D0  E59A                     413  or_handler     ROL.L    #2,D2
000013D2  B43C 0000                414                 CMP.B    #0,D2
000013D6  6700 FC9E                415                 BEQ      inv_handler    *SBCD
000013DA  23F9 00004110 00004160   416                 MOVE.L   OR,INST_NAME
000013E4  E209                     417                 LSR.B    #1,D1          *shift the direction bit to carry-- D1 now also holds the data register of the operation
000013E6  1A01                     418                 MOVE.B   D1,D5          *move source/destination (undertermined) Dn bits to D5
000013E8  6500 0006                419                 BCS      or_Dn_right    * <ea> OR Dn
000013EC  6000 000C                420                 BRA      or_Dn_left     * Dn OR <ea>
000013F0                           421                 
000013F0  4201                     422  or_Dn_right    CLR.B    D1
000013F2  E599                     423                 ROL.L    #2,D1
000013F4  1801                     424                 MOVE.B   D1,D4          *D4 holds the size of the operation
000013F6  6000 000C                425                 BRA      or_size
000013FA                           426  
000013FA  1E3C 0001                427  or_Dn_left     MOVE.B   #1,D7          *flag operation as Dn_left
000013FE  4201                     428                 CLR.B    D1
00001400  E599                     429                 ROL.L    #2,D1
00001402  1801                     430                 MOVE.B   D1,D4          *D4 holds the size of the operation
00001404  B83C 0000                431  or_size        CMP.B    #0,D4
00001408  6700 0012                432                 BEQ      or_byte
0000140C  B83C 0001                433                 CMP.B    #1,D4
00001410  6700 001C                434                 BEQ      or_word
00001414  B83C 0002                435                 CMP.B    #2,D4
00001418  6700 0026                436                 BEQ      or_long
0000141C                           437                 
0000141C  23F9 0000413C 00004148   438  or_byte        MOVE.L   SIZEB,SIZECODE
00001426  14BC 0000                439                 MOVE.B   #0,(A2)        *flag data as byte sized
0000142A  6000 0022                440                 BRA      or_ea
0000142E                           441  
0000142E  23F9 00004140 00004148   442  or_word        MOVE.L   SIZEW,SIZECODE
00001438  14BC 0001                443                 MOVE.B   #1,(A2)        *flag data as word sized
0000143C  6000 0010                444                 BRA      or_ea
00001440                           445  
00001440  23F9 00004144 00004148   446  or_long        MOVE.L   SIZEL,SIZECODE
0000144A  14BC 0002                447                 MOVE.B   #2,(A2)        *flag data as long sized
0000144E                           448  
0000144E  4EB9 00001FE0            449  or_ea          JSR      disp_instr
00001454  4201                     450                 CLR.B    D1
00001456  E799                     451                 ROL.L    #3,D1          *D1 holds the EA bits         
00001458  2601                     452                 MOVE.L   D1,D3          *move EA source bits to D3
0000145A  BE3C 0001                453                 CMP.B    #1,D7
0000145E  6700 001E                454                 BEQ      or_left_print
00001462  2C03                     455                 MOVE.L   D3,D6          *temp store D3 bits in D6 for next function call
00001464  2605                     456                 MOVE.L   D5,D3
00001466  4EB9 00001D50            457                 JSR      DR_CMP         *print Dn bits
0000146C  4EB9 0000209A            458                 JSR      print_comma
00001472  2606                     459                 MOVE.L   D6,D3
00001474  4EB9 00001CDA            460                 JSR      EA_SRC_beg
0000147A  6000 FB98                461                 BRA      prep
0000147E                           462                 
0000147E  4EB9 00001CDA            463  or_left_print  JSR      EA_SRC_beg     *print EA bits
00001484  2605                     464                 MOVE.L   D5,D3          *get D5 bits in D3 for function call
00001486  4EB9 0000209A            465                 JSR      print_comma
0000148C  4EB9 00001D50            466                 JSR      DR_CMP         *print Dn bits
00001492  6000 FB80                467                 BRA      prep
00001496                           468  
00001496                           469  * /or_handler
00001496                           470  *-----------------------------------------------------------------------------
00001496                           471  
00001496                           472  
00001496                           473  *----------------------------------------------------------------------------
00001496                           474  *add_handler
00001496                           475  *handles 'ADD'
00001496                           476  * heavily uses the or_handler function as the instruction formats are equivalent after the first nibble
00001496                           477  
00001496  23F9 0000406C 00004160   478  add_handler    MOVE.L  ADD,INST_NAME
000014A0  E209                     479                 LSR.B   #1,D1
000014A2  1A01                     480                 MOVE.B  D1,D5        *isolate direction bits
000014A4  6500 FF4A                481                 BCS     or_Dn_right  *<ea> + Dn -> <ea>
000014A8  6000 FF50                482                 BRA     or_Dn_left   *Dn + <ea> -> Dn
000014AC                           483         
000014AC                           484  * /add_handler
000014AC                           485  *----------------------------------------------------------------------------
000014AC                           486  
000014AC                           487  
000014AC                           488  *-----------------------------------------------------------------------------
000014AC                           489  *sub_handler
000014AC                           490  * handles 'SUB'
000014AC                           491  
000014AC  23F9 000040F8 00004160   492  sub_handler         MOVE.L  SUB,INST_NAME
000014B6  4201                     493                      CLR.B   D1
000014B8  E999                     494                      ROL.L   #4,D1
000014BA  2401                     495                      MOVE.L  D1,D2         *make a copy
000014BC  4242                     496                      CLR     D2
000014BE  E59A                     497                      ROL.L   #2,D2
000014C0  6700 FEF6                498                      BEQ     suba_handler  *its suba (hardcoded size bits)
000014C4  E209                     499                      LSR.B   #1,D1         *determine direction of sub
000014C6  1A01                     500                      MOVE.B  D1,D5         *move Dn and direction bits to D5
000014C8  6500 FF26                501                      BCS     or_Dn_right   * <ea> SUB Dn -> <ea>
000014CC  6000 FF2C                502                      BRA     or_Dn_left    * Dn SUB <ea> -> Dn            
000014D0                           503  
000014D0                           504  * /sub_handler
000014D0                           505  *-----------------------------------------------------------------------------
000014D0                           506  
000014D0                           507  *-----------------------------------------------------------------------------
000014D0                           508   * eor_handler  
000014D0                           509   * handles 'EOR'
000014D0                           510  
000014D0  23F9 00004084 00004160   511  eor_handler         MOVE.L   EOR,INST_NAME
000014DA  E209                     512                      LSR.B    #1,D1           *get rid of direction bit--we know its 1
000014DC  1A01                     513                      MOVE.B   D1,D5           *copy data register number in d1 to d5
000014DE  6000 FF10                514                      BRA      or_Dn_right
000014E2                           515                      
000014E2                           516  * /eor_handler
000014E2                           517  *-----------------------------------------------------------------------------
000014E2                           518  
000014E2                           519  
000014E2                           520  *-----------------------------------------------------------------------------
000014E2                           521  * cmp_handler
000014E2                           522  * handles 'CMP'
000014E2                           523  
000014E2  23F9 0000408C 00004160   524  cmp_handler         MOVE.L   CMP,INST_NAME
000014EC  E209                     525                      LSR.B    #1,D1        *get rid of hardcoded 0
000014EE  1A01                     526                      MOVE.B   D1,D5        *save Dn bits to D5
000014F0  6000 FF08                527                      BRA      or_Dn_left
000014F4                           528  
000014F4                           529  * /cmp_handler
000014F4                           530  *-----------------------------------------------------------------------------
000014F4                           531  
000014F4                           532  
000014F4                           533  *-----------------------------------------------------------------------------
000014F4                           534  *divsw_handler
000014F4                           535  *handles 'DIVS'(.W)
000014F4                           536  * .W is implicit
000014F4                           537  
000014F4  23F9 00004108 00004160   538  divsw_handler   MOVE.L DIV,INST_NAME
000014FE  33F9 00004130 00004168   539                  MOVE.W S,INST_NAME_EXT
00001508  4EB9 00001FE0            540  divsw_beg       JSR    disp_instr
0000150E  E209                     541                  LSR.B  #1,D1        *get rid of hardcoded bit
00001510  4282                     542                  CLR.L  D2           *clear space in D2
00001512  1401                     543                  MOVE.B D1,D2        *save Dn destination register to D2
00001514  2802                     544                  MOVE.L D2,D4        *get them into D4 for use after next function call
00001516  4201                     545                  CLR.B  D1
00001518  E589                     546                  LSL.L  #2,D1        *Shift out size bits--we already know its a word
0000151A  E799                     547                  ROL.L  #3,D1        *D1 now holds the EA bits
0000151C  2601                     548                  MOVE.L D1,D3        *and move them to D3
0000151E  4EB9 00001CDA            549                  JSR    EA_SRC_beg   *print source EA info
00001524  4EB9 0000209A            550                  JSR    print_comma
0000152A  2604                     551                  MOVE.L D4,D3        *move the destination register bits to D3 for next call
0000152C  4EB9 00001D50            552                  JSR    DR_CMP       *print the data register
00001532  6000 FAE0                553                  BRA    prep
00001536                           554  
00001536                           555  * /divsw_handler
00001536                           556  *-----------------------------------------------------------------------------
00001536                           557  
00001536                           558                    
00001536                           559  *-----------------------------------------------------------------------------
00001536                           560  *muls_handler
00001536                           561  * handles 'MULS'
00001536                           562  
00001536                           563  *uses divsw function as layout is similar after first 4 bits
00001536                           564  
00001536  4201                     565  muls_handler      CLR.B   D1
00001538  E999                     566                    ROL.L   #4,D1             *get the next hex digit after 0xC
0000153A  2401                     567                    MOVE.L  D1,D2
0000153C  E20A                     568                    LSR.B   #1,D2
0000153E  6400 FB36                569                    BCC     inv_handler       *unsupported opcode
00001542  4202                     570                    CLR.B   D2
00001544  E59A                     571                    ROL.L   #2,D2             *get the size bits of the operation
00001546  B43C 0003                572                    CMP.B   #3,D2
0000154A  6600 FB2A                573                    BNE     inv_handler       *unsupported if size code != 11 at this point
0000154E  23F9 00004100 00004160   574                    MOVE.L  MUL,INST_NAME     *now were sure its muls
00001558  23F9 00004130 00004168   575                    MOVE.L  S,INST_NAME_EXT
00001562  4EB8 1508                576                    JSR     divsw_beg
00001566                           577  
00001566                           578  */muls_handler
00001566                           579  *-----------------------------------------------------------------------------
00001566                           580  
00001566                           581  
00001566                           582  *-----------------------------------------------------------------------------
00001566                           583  *subq_handler
00001566                           584  * handles 'SUBQ' (data [1,8])
00001566                           585  
00001566  23F9 000040F8 00004160   586  subq_handler       MOVE.L  SUB,INST_NAME
00001570  23F9 0000412E 00004168   587  subq_det           MOVE.L  Q,INST_NAME_EXT
0000157A  4201                     588                     CLR.B   D1
0000157C  E599                     589                     ROL.L   #2,D1            *isolate size bits
0000157E  B23C 0000                590                     CMP.B   #0,D1
00001582  6700 0016                591                     BEQ     subq_byte
00001586  B23C 0001                592                     CMP.B   #1,D1
0000158A  6700 0020                593                     BEQ     subq_word
0000158E  B23C 0002                594                     CMP.B   #2,D1
00001592  6700 002A                595                     BEQ     subq_long
00001596  6000 FADE                596                     BRA     inv_handler     *size > 2 means it's an unsupported opcode
0000159A  23F9 0000413C 00004148   597  subq_byte          MOVE.L  SIZEB,SIZECODE
000015A4  14BC 0000                598                     MOVE.B  #0,(A2)
000015A8  6000 0028                599                     BRA     subq_ea
000015AC  23F9 00004140 00004148   600  subq_word          MOVE.L  SIZEW,SIZECODE
000015B6  14BC 0001                601                     MOVE.B  #1,(A2)            *flag it as a word
000015BA  6000 0016                602                     BRA     subq_ea
000015BE  23F9 00004144 00004148   603  subq_long          MOVE.L  SIZEL,SIZECODE
000015C8  24BC 00000002            604                     MOVE.L  #2,(A2)            *flag it as a long
000015CE  6000 0002                605                     BRA     subq_ea 
000015D2                           606  
000015D2  4201                     607  subq_ea            CLR.B   D1               *prep byte space
000015D4  E799                     608                     ROL.L   #3,D1            *get EA bits
000015D6  2601                     609                     MOVE.L  D1,D3            *put them in D3
000015D8  2202                     610                     MOVE.L  D2,D1            *move immediate data bits back to D1 for display
000015DA  4EB9 00001FE0            611                     JSR     disp_instr
000015E0  B23C 0000                612                     CMP.B   #0,D1
000015E4  6700 0024                613                     BEQ     case_quick8     *8 (base 0) is represented as 000 in data field.
000015E8  43F9 0000416E            614  q_prints           LEA     imm_sign, A1    *load and print '#' character
000015EE  103C 000E                615                     MOVE.B  #14,D0
000015F2  4E4F                     616                     TRAP    #15
000015F4  103C 0003                617                     MOVE.B  #3,D0
000015F8  4E4F                     618                     TRAP    #15              *display immediate [1-8] data 
000015FA  4EB9 0000209A            619                     JSR     print_comma               
00001600  4EB9 00001CDA            620                     JSR     EA_SRC_beg
00001606  6000 FA0C                621                     BRA     prep
0000160A                           622             
0000160A  123C 0008                623  case_quick8        MOVE.B  #8,D1           *move the number 8 to D1, replacing 0  
0000160E  60D8                     624                     BRA     q_prints     
00001610                           625  
00001610                           626  * /subq_handler
00001610                           627  *-----------------------------------------------------------------------------
00001610                           628  
00001610                           629  
00001610                           630  *-----------------------------------------------------------------------------
00001610                           631  *addq_handler
00001610                           632  *handles 'ADDQ', or adds with data [1,8]
00001610                           633  
00001610                           634  *uses subq_handler due to similar bit layout
00001610                           635  
00001610  23F9 0000406C 00004160   636  addq_handler      MOVE.L  ADD,INST_NAME
0000161A  6000 FF54                637                    BRA     subq_det          *SUBQ and ADDQ equivalent instruction layout hereafter   
0000161E                           638  
0000161E                           639  * /addq_handler
0000161E                           640  *-----------------------------------------------------------------------------
0000161E                           641  
0000161E                           642  
0000161E                           643  *-----------------------------------------------------------------------------
0000161E                           644  * cmpi_handler
0000161E                           645  * handles cmpi
0000161E                           646  
0000161E                           647  *D1 holds instruction info, then EA info (mode & reg)
0000161E                           648  *D2: holds the size of the operation (b,w,l)
0000161E                           649  
0000161E                           650  *size bits also indicate the size of immediate data after the instruction
0000161E                           651  
0000161E  23F9 0000408C 00004160   652  cmpi_handler       MOVE.L   CMP,INST_NAME
00001628  13F9 00004126 00004168   653                     MOVE.B   I,INST_NAME_EXT
00001632  4201                     654                     CLR.B    D1
00001634  E599                     655                     ROL.L    #2,D1               *isolate the size bits
00001636  1801                     656                     MOVE.B   D1,D4               *move size bits to D4
00001638  B83C 0000                657                     CMP.B    #0,D4
0000163C  6700 0012                658                     BEQ      cmpi_byte
00001640  B83C 0001                659                     CMP.B    #1,D4
00001644  6700 001C                660                     BEQ      cmpi_word
00001648  B83C 0002                661                     CMP.B    #2,D4
0000164C  6700 0026                662                     BEQ      cmpi_long
00001650  23F9 0000413C 00004148   663  cmpi_byte          MOVE.L   SIZEB,SIZECODE      *indicate the operation is a byte
0000165A  14BC 0000                664                     MOVE.B   #0,(A2)
0000165E  6000 0022                665                     BRA      cmpi_ret
00001662  23F9 00004140 00004148   666  cmpi_word          MOVE.L   SIZEW,SIZECODE      *indicate the operation is a word
0000166C  14BC 0001                667                     MOVE.B   #1,(A2)      
00001670  6000 0010                668                     BRA      cmpi_ret
00001674  23F9 00004144 00004148   669  cmpi_long          MOVE.L   SIZEL,SIZECODE      *indicate the operation is a long
0000167E  14BC 0002                670                     MOVE.B   #2,(A2)  
00001682  DAFC 0002                671  cmpi_ret           ADDA     #word_len,A5        *set pointer to next word- all data in cmpi is either next word or next 2 words(long)
00001686  4EB9 00001FE0            672                     JSR      disp_instr
0000168C  4201                     673                     CLR.B    D1
0000168E  4EB9 00001E84            674                     JSR      DATA_MODE           *determine and print the immediate data based on size
00001694  0C12 0002                675                     CMP.B    #2,(A2)
00001698  E799                     676                     ROL.L    #3,D1               *isolate EA info in D1
0000169A  2601                     677                     MOVE.L   D1,D3
0000169C  4EB9 0000209A            678                     JSR      print_comma
000016A2  4EB9 00001CDE            679                     JSR      EA_SRC              *obtain and print the destination information
000016A8  6000 F96A                680                     BRA      prep
000016AC                           681                     
000016AC                           682  * /cmpi_handler
000016AC                           683  *-----------------------------------------------------------------------------
000016AC                           684  
000016AC                           685  
000016AC                           686  *-----------------------------------------------------------------------------
000016AC                           687  *bclr_static and bclr_dynamic
000016AC                           688  *(bclr_handler)
000016AC                           689  *handles 'BCLR' with a data register or its static counterpart (no register)
000016AC                           690  
000016AC  E599                     691  bclr_static       ROL.L     #2,D1          *get 2 more bits-- are we sure its BCLR?
000016AE  B23C 0022                692                    CMP.B     #34,D1         *static BCLR bits 11 to 6
000016B2  6600 F9C2                693                    BNE       inv_handler    *unsupported opcode
000016B6  23F9 00004074 00004160   694                    MOVE.L    BCL,INST_NAME  *we now know its bclr
000016C0  23F9 00004128 00004168   695                    MOVE.L    R,INST_NAME_EXT
000016CA  4EB9 00001FE0            696                    JSR       disp_instr
000016D0  4201                     697                    CLR.B     D1             
000016D2  E799                     698                    ROL.L     #3,D1          *isolate the EA mode and register
000016D4  2601                     699                    MOVE.L    D1,D3
000016D6  DAFC 0002                700                    ADDA      #word_len,A5   *get the trailing immediate data
000016DA  4281                     701                    CLR.L     D1
000016DC                           702                    *MOVE.W    (A5),D1        *move it to D1
000016DC  4EB9 00001E84            703                    JSR       DATA_MODE      *and print it
000016E2  9AFC 0002                704                    SUBA      #word_len,A5   *return to instruction
000016E6  4EB9 0000209A            705                    JSR       print_comma
000016EC  4EB9 00001CDA            706                    JSR       EA_SRC_beg     *print EA dest information
000016F2  6000 F920                707                    BRA       prep    
000016F6                           708  
000016F6  E209                     709  bclr_dynamic      LSR.B     #1,D1          *discard hardcoded bit 
000016F8  23F9 00004074 00004160   710                    MOVE.L    BCL,INST_NAME
00001702  23F9 00004128 00004168   711                    MOVE.L    R,INST_NAME_EXT
0000170C  4EB9 00001FE0            712                    JSR       disp_instr
00001712  1601                     713                    MOVE.B    D1,D3          *store Dn bits in D3
00001714  4EB9 00001D50            714                    JSR       DR_CMP         *print appropriate data register
0000171A  4EB9 0000209A            715                    JSR       print_comma
00001720  4201                     716                    CLR.B     D1
00001722  E589                     717                    LSL.L     #2,D1          *clear hardcoded bits
00001724  E799                     718                    ROL.L     #3,D1          *get ea bits
00001726  2601                     719                    MOVE.L    D1,D3          *put them in D3
00001728  4EB9 00001CDA            720                    JSR       EA_SRC_beg     *print EA info
0000172E  6000 F8E4                721                    BRA       prep
00001732                           722                   
00001732                           723  
00001732                           724  * /bclr_handler
00001732                           725  *-----------------------------------------------------------------------------
00001732                           726  
00001732                           727  
00001732                           728  *-----------------------------------------------------------------------------
00001732                           729  *ori_handler
00001732                           730  *handles 'ORI'
00001732                           731      
00001732                           732  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
00001732                           733  
00001732  23F9 0000407C 00004160   734  ori_handler       MOVE.L   ORI,INST_NAME
0000173C  4201                     735                    CLR.B    D1
0000173E  E599                     736                    ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
00001740  1801                     737                    MOVE.B   D1,D4           *move size bits to D2
00001742  4202                     738                    CLR.B    D2
00001744  E79A                     739                    ROL.L    #3,D2           *get EA mode bits
00001746  B43C 0007                740                    CMP.B    #7,d2           *are EA mode bits 111?
0000174A  6700 F92A                741                    BEQ      inv_handler     *invalid ORI type (SR,CCR)
0000174E  B83C 0000                742                    CMP.B    #0,D4
00001752  6700 FEFC                743                    BEQ      cmpi_byte
00001756  B83C 0001                744                    CMP.B    #1,D4
0000175A  6700 FF06                745                    BEQ      cmpi_word
0000175E  B83C 0002                746                    CMP.B    #2,D4
00001762  6700 FF10                747                    BEQ      cmpi_long
00001766                           748  
00001766                           749  * /ori_handler
00001766                           750  *-----------------------------------------------------------------------------
00001766                           751  
00001766                           752  
00001766                           753  *-----------------------------------------------------------------------------
00001766                           754  * addi_handler
00001766                           755  * handles 'ADDI'
00001766                           756  
00001766                           757  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
00001766                           758  
00001766  23F9 0000406C 00004160   759  addi_handler      MOVE.L   ADD,INST_NAME
00001770  23F9 00004126 00004168   760                    MOVE.L   I,INST_NAME_EXT
0000177A  4201                     761                    CLR.B    D1
0000177C  E599                     762                    ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
0000177E  1801                     763                    MOVE.B   D1,D4           *move size bits to D2
00001780  B83C 0000                764                    CMP.B    #0,D4
00001784  6700 FECA                765                    BEQ      cmpi_byte
00001788  B83C 0001                766                    CMP.B    #1,D4
0000178C  6700 FED4                767                    BEQ      cmpi_word
00001790  B83C 0002                768                    CMP.B    #2,D4
00001794  6700 FEDE                769                    BEQ      cmpi_long
00001798                           770  
00001798                           771  * /addi_handler
00001798                           772  *-----------------------------------------------------------------------------
00001798                           773  
00001798                           774  *-----------------------------------------------------------------------------
00001798                           775  * eori_handler
00001798                           776  * handles 'EORI'
00001798                           777  
00001798                           778  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
00001798                           779  
00001798  23F9 00004084 00004160   780  eori_handler      MOVE.L   EOR,INST_NAME
000017A2  23F9 00004126 00004168   781                    MOVE.L   I,INST_NAME_EXT
000017AC  4201                     782                    CLR.B    D1
000017AE  E599                     783                    ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
000017B0  1801                     784                    MOVE.B   D1,D4           *move size bits to D2
000017B2  B83C 0000                785                    CMP.B    #0,D4
000017B6  6700 FE98                786                    BEQ      cmpi_byte
000017BA  B83C 0001                787                    CMP.B    #1,D4
000017BE  6700 FEA2                788                    BEQ      cmpi_word
000017C2  B83C 0002                789                    CMP.B    #2,D4
000017C6  6700 FEAC                790                    BEQ      cmpi_long
000017CA                           791  
000017CA                           792  
000017CA                           793  
000017CA                           794  * /eori_handler
000017CA                           795  *-----------------------------------------------------------------------------
000017CA                           796  
000017CA                           797  *-----------------------------------------------------------------------------
000017CA                           798  * subi_handler
000017CA                           799  * handles 'SUBI'
000017CA                           800  
000017CA                           801  *heavily uses cmpi_handler due to similar layout in bits d7 to d0
000017CA                           802  
000017CA  23F9 000040F8 00004160   803  subi_handler     MOVE.L   SUB,INST_NAME
000017D4  23F9 00004126 00004168   804                   MOVE.L   I,INST_NAME_EXT
000017DE  4201                     805                   CLR.B    D1
000017E0  E599                     806                   ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
000017E2  1801                     807                   MOVE.B   D1,D4           *move size bits to D2
000017E4  B83C 0000                808                   CMP.B    #0,D4
000017E8  6700 FE66                809                   BEQ      cmpi_byte
000017EC  B83C 0001                810                   CMP.B    #1,D4
000017F0  6700 FE70                811                   BEQ      cmpi_word
000017F4  B83C 0002                812                   CMP.B    #2,D4
000017F8  6700 FE7A                813                   BEQ      cmpi_long
000017FC                           814  
000017FC                           815  * /subi_handler
000017FC                           816  *-----------------------------------------------------------------------------
000017FC                           817  
000017FC                           818  
000017FC                           819  *-----------------------------------------------------------------------------
000017FC                           820  *neg_handler
000017FC                           821  *handles neg
000017FC                           822  
000017FC                           823  *D1: holds opcode
000017FC                           824  *D4: holds size of operation (b,w,l)
000017FC                           825  
000017FC  23F9 0000404C 00004160   826  neg_handler      MOVE.L   NEG,INST_NAME
00001806  4201                     827                   CLR.B    D1   
00001808  E599                     828                   ROL.L    #2,D1           *0 currently occupies the byte, so can immediately roll
0000180A  1801                     829                   MOVE.B   D1,D4           *move size bits to D4
0000180C  B83C 0000                830                   CMP.B    #0,D4           *determine size based on bits (00=byte) (01=word) (10=long)
00001810  6700 0012                831                   BEQ      neg_byte
00001814  B83C 0001                832                   CMP.B    #1,D4
00001818  6700 0018                833                   BEQ      neg_word
0000181C  B83C 0002                834                   CMP.B    #2,D4
00001820  6700 001E                835                   BEQ      neg_long
00001824                           836    
00001824  23F9 0000413C 00004148   837  neg_byte         MOVE.L   SIZEB,SIZECODE
0000182E  6000 001A                838                   BRA      neg_ret
00001832  23F9 00004140 00004148   839  neg_word         MOVE.L   SIZEW,SIZECODE
0000183C  6000 000C                840                   BRA      neg_ret
00001840  23F9 00004144 00004148   841  neg_long         MOVE.L   SIZEL,SIZECODE   
0000184A  4EB9 00001FE0            842  neg_ret          JSR      disp_instr
00001850  E799                     843                   ROL.L    #3,D1           *isolate EA bits
00001852  2601                     844                   MOVE.L   D1,D3           *move those EA bits to D3
00001854  4EB9 00001CDA            845                   JSR      EA_SRC_beg      *display EA info we're negating
0000185A                           846  
0000185A                           847  
0000185A                           848  * /neg_handler
0000185A                           849  *-----------------------------------------------------------------------------
0000185A                           850  
0000185A                           851  
0000185A                           852  *-----------------------------------------------------------------------------
0000185A                           853  *bcc_handler
0000185A                           854  *handles 'BCS','BGE','BLT','BVC','BRA'
0000185A                           855  
0000185A                           856  *D1: holds the condition, displacement nibbles of instruction
0000185A                           857  *D3: holds the condition of instruction
0000185A                           858  *D4: holds the current address of this instruction
0000185A                           859  *A4: holds the pointer to bcc_tbl
0000185A                           860  *A5: holds the current address of this instruction
0000185A                           861  
0000185A  4201                     862  bcc_handler   CLR.B   D1
0000185C  E999                     863                ROL.L   #4,D1
0000185E  1601                     864                MOVE.B  D1,D3          *copy condition value to D3
00001860  49F9 0000414C            865                LEA     bcc_tbl,A4     *A4 now points to the bcc_tbl
00001866  0C14 00FF                866  bcc_cond      CMP.B   #-1,(A4)       *have we reached the end of the table
0000186A  6700 0146                867                BEQ     inv_bcc_handler  * yes-invalid branch
0000186E  B61C                     868                CMP.B   (A4)+,D3       *compare the next table value
00001870  6700 0004                869                BEQ     bcc_determiner * there's a match
00001874  60F0                     870                BRA     bcc_cond       *continue looping through the table
00001876                           871  
00001876  0C24 0005                872  bcc_determiner  CMP.B  #5,-(a4)      *determine path based on condition code from table (in data section)
0000187A  6700 0056                873                  BEQ    bcs_handler
0000187E  0C14 000C                874                  CMP.B  #12,(a4)
00001882  6700 005C                875                  BEQ    bge_handler
00001886  0C14 000D                876                  CMP.B  #13,(a4)
0000188A  6700 0062                877                  BEQ    blt_handler
0000188E  0C14 0008                878                  CMP.B  #8,(a4)
00001892  6700 0068                879                  BEQ    bvc_handler
00001896  0C14 0000                880                  CMP.B  #0,(a4)
0000189A  6700 006E                881                  BEQ    bra_handler
0000189E  0C14 0004                882                  CMP.B  #4,(a4)
000018A2  6700 0074                883                  BEQ    bccd_handler
000018A6  0C14 0006                884                  CMP.B  #6,(a4)
000018AA  6700 007A                885                  BEQ    bne_handler
000018AE  0C14 0007                886                  CMP.B  #7,(a4)
000018B2  6700 0080                887                  BEQ    beq_handler
000018B6  0C14 0009                888                  CMP.B  #9,(a4)
000018BA  6700 0086                889                  BEQ    bvs_handler
000018BE  0C14 000E                890                  CMP.B  #$E,(a4)
000018C2  6700 008C                891                  BEQ    bgt_handler
000018C6  0C14 000F                892                  CMP.B  #$F,(a4)
000018CA  6700 0092                893                  BEQ    ble_handler
000018CE  6000 00E2                894                  BRA    inv_bcc_handler      *before displaying unsupported opcode message,advance address pointer
000018D2                           895                                              *to account for known displacement after this unsupported branch
000018D2  23F9 000040A0 00004160   896  bcs_handler   MOVE.L  BCS,INST_NAME
000018DC  6000 008E                897                BRA     bcc_dispm
000018E0  23F9 000040A8 00004160   898  bge_handler   MOVE.L  BGE,INST_NAME
000018EA  6000 0080                899                BRA     bcc_dispm
000018EE  23F9 000040B0 00004160   900  blt_handler   MOVE.L  BLT,INST_NAME
000018F8  6000 0072                901                BRA     bcc_dispm
000018FC  23F9 000040B8 00004160   902  bvc_handler   MOVE.L  BVC,INST_NAME
00001906  6000 0064                903                BRA     bcc_dispm
0000190A  23F9 000040C0 00004160   904  bra_handler   MOVE.L  BRA,INST_NAME
00001914  6000 0056                905                BRA     bcc_dispm
00001918  23F9 000040C8 00004160   906  bccd_handler  MOVE.L  BCC,INST_NAME
00001922  6000 0048                907                BRA     bcc_dispm
00001926  23F9 000040D0 00004160   908  bne_handler   MOVE.L  BNE,INST_NAME
00001930  6000 003A                909                BRA     bcc_dispm
00001934  23F9 000040D8 00004160   910  beq_handler   MOVE.L  BEQ,INST_NAME
0000193E  6000 002C                911                BRA     bcc_dispm
00001942  23F9 000040E0 00004160   912  bvs_handler   MOVE.L  BVS,INST_NAME
0000194C  6000 001E                913                BRA     bcc_dispm
00001950  23F9 000040E8 00004160   914  bgt_handler   MOVE.L  BGT,INST_NAME
0000195A  6000 0010                915                BRA     bcc_dispm
0000195E  23F9 000040F0 00004160   916  ble_handler   MOVE.L  BLE,INST_NAME
00001968  6000 0002                917                BRA     bcc_dispm
0000196C                           918  
0000196C  280D                     919  bcc_dispm     MOVE.L  A5,D4            *copy current address to D4
0000196E  DAFC 0002                920                ADDA    #word_len,A5     *all Bcc instructions took up a word         
00001972  4201                     921                CLR.B   D1               *now find the displacement- (A5 +- last 2 nibbles)
00001974  E199                     922                ROL.L   #8,D1            *get the last 2 displacement nibbles
00001976  B23C 0000                923                CMP.B   #0,D1            *are the 8 displacement bits all 0?
0000197A  6700 0016                924                BEQ     bcc_word_handler * yes- get the following displacement word
0000197E  B23C 000F                925                CMP.B   #$F,D1           *are all displacement bits 1?
00001982  6700 0012                926                BEQ     bcc_long_handler * yes-get the displacement long
00001986  4681                     927  bcc_calc      NOT.L   D1               *ones complement
00001988  5281                     928                ADDI.L  #1,D1            *twos complement 
0000198A  5404                     929                ADDI.B  #2,D4            *account for PC displacement 2 bytes ahead of current address
0000198C  9841                     930                SUB.W   D1,D4            *calculate displacement address  ****.L OR .W
0000198E  6000 000A                931                BRA     bcc_complete
00001992                           932                
00001992  321D                     933  bcc_word_handler  MOVE.W (A5)+,D1    *put 16 displacement bits in D1
00001994  60F0                     934                    BRA     bcc_calc
00001996                           935                    
00001996  221D                     936  bcc_long_handler  MOVE.L (A5)+,D1    *put 32 displacement bits in D1
00001998  60EC                     937                    BRA     bcc_calc
0000199A                           938  
0000199A  4EB9 00001FE0            939  bcc_complete  JSR     disp_instr
000019A0  2044                     940                MOVE.L  D4,A0      *move displacement address to A0 for next function
000019A2  4EB9 000020B0            941                JSR     print_addr_sgn
000019A8  4EB9 00002034            942                JSR     hex_2_ascii
000019AE  6000 F664                943                BRA     prep
000019B2                           944                     
000019B2  4201                     945  inv_bcc_handler    CLR.B D1         
000019B4  E199                     946                     ROL.L #8,D1          *get the 8 bit displacement of this unsupported branch
000019B6  B23C 0000                947                     CMP.B #0,D1          *did the branch need a word displacement
000019BA  6700 000E                948                     BEQ   inv_bcc_word   * branch included a trailing word displacement
000019BE  B03C 00FF                949                     CMP.B #$FF,D0        *did the branch need a long displacement
000019C2  6700 000E                950                     BEQ   inv_bcc_long   * branch included a trailing long displacement
000019C6  6000 F6AE                951                     BRA   inv_handler    *branch instruction was self-contained
000019CA  DAFC 0002                952  inv_bcc_word       ADDA #word_len,A5    *skip over the word displacement
000019CE  6000 F6A6                953                     BRA  inv_handler
000019D2  DAFC 0004                954  inv_bcc_long       ADDA #long_len,A5    *skip over the long displacement
000019D6  6000 F69E                955                     BRA  inv_handler
000019DA                           956  
000019DA                           957   */bcc_handler            
000019DA                           958  *-----------------------------------------------------------------------------
000019DA                           959  
000019DA                           960  *-----------------------------------------------------------------------------
000019DA                           961   * shift_roll_handler   
000019DA                           962   * handles 'LSR','LSL','ASR','ASL','ROL','ROR'
000019DA                           963  
000019DA                           964   
000019DA                           965   *A5: holds the current address of this instruction
000019DA                           966   *D2: used to check if its a shift or roll, immediate or register
000019DA                           967   *D3: holds the size (b,w,l) of the operation
000019DA                           968   *D4: holds the immediate data (1-7) or the register number of the source
000019DA                           969   *D5: flags source as immediate or register 1=reg, 0=imm (only used in sr_reg)
000019DA                           970   
000019DA  4201                     971  _shift_roll_handler  CLR.B    D1
000019DC  E999                     972                       ROL.L    #4,D1            *get next 4 bits in this shift/roll
000019DE  2401                     973                       MOVE.L   D1,D2
000019E0  E20A                     974                       LSR.B    #1,D2            *set the carry to be the direction of this shift/rotate
000019E2  6500 0010                975                       BCS      sr_type_resolve  * carry is set- its leftwards
000019E6  23F9 00004128 00004168   976                       MOVE.L   R,INST_NAME_EXT  *we know its a rightwards operation
000019F0  6000 000C                977                       BRA      sr_type_resolve_beg  * carry is set- rightwards
000019F4                           978  
000019F4                           979  *now determine if its a memory or register shift                  
000019F4  23F9 0000412C 00004168   980  sr_type_resolve      MOVE.L   L,INST_NAME_EXT   *we know its a leftwards operation
000019FE  1802                     981  sr_type_resolve_beg  MOVE.B   D2,D4          *D4 now holds the count/register bits
00001A00  4202                     982                       CLR.B    D2
00001A02  E59A                     983                       ROL.L    #2,D2          *get next 2 (size) bits
00001A04  1602                     984                       MOVE.B   D2,D3          *move size bits to D3 
00001A06  4202                     985                       CLR.B    D2             *clear size bits from D2
00001A08  B63C 0003                986                       CMP.B    #3,D3          *are size bits 11?
00001A0C  6700 0006                987                       BEQ      sr_mem         * yes-memory shift
00001A10  6000 005C                988                       BRA      sr_reg         * no-register shift
00001A14                           989                       
00001A14                           990  *its a memory shift/roll,so exact instruction lies in D4. First get type, then get direction later        
00001A14  B83C 0000                991  sr_mem               CMP.B   #0,D4          *D4 holds instruction type. which one is it?
00001A18  6700 0016                992                       BEQ     as_handler
00001A1C  B83C 0001                993                       CMP.B   #1,D4
00001A20  6700 001C                994                       BEQ     ls_handler
00001A24  B83C 0003                995                       CMP.B   #3,D4
00001A28  6700 0022                996                       BEQ     ro_handler
00001A2C  6000 F648                997                       BRA     inv_handler    *unsupported
00001A30                           998                       
00001A30  23F9 00004098 00004160   999  as_handler           MOVE.L  AS,INST_NAME   *its AS(R/L)
00001A3A  6000 001E               1000                       BRA     sr_mem_ret
00001A3E  23F9 00004094 00004160  1001  ls_handler           MOVE.L  LS,INST_NAME   *its LS(R/L)
00001A48  6000 0010               1002                       BRA     sr_mem_ret
00001A4C  23F9 0000409C 00004160  1003  ro_handler           MOVE.L  RO,INST_NAME   *its RO(R/L)
00001A56  6000 0002               1004                       BRA     sr_mem_ret
00001A5A                          1005  
00001A5A  4EB9 00001FE0           1006  sr_mem_ret           JSR     disp_instr     *display the instruction (eg 'ASR','ROL')  
00001A60  E79A                    1007                       ROL.L   #3,D2          *partition EA bits            
00001A62  1602                    1008                       MOVE.B  D2,D3          *and send them to D3 for next function call
00001A64  4EB9 00001CDA           1009                       JSR     EA_SRC_beg     *display EA info
00001A6A  6000 F5A8               1010                       BRA     prep
00001A6E                          1011  
00001A6E                          1012  *its a register shift/roll so D4 holds the register/immediate shift count
00001A6E  E38A                    1013  sr_reg               LSL.L   #1,D2          *send i/r bit to carry
00001A70  6500 000A               1014                       BCS     sr_reg_type
00001A74  1A3C 0000               1015                       MOVE.B  #0,D5              *flag operation as immediate shift on register
00001A78  6000 0006               1016                       BRA     sr_reg_type_beg
00001A7C                          1017                       
00001A7C  1A3C 0001               1018  sr_reg_type          MOVE.B  #1,D5              *flag operation as register shift on register
00001A80  4202                    1019  sr_reg_type_beg      CLR.B   D2 
00001A82  B63C 0000               1020                       CMP.B   #0,D3              *compare size bits to determine operation size
00001A86  6700 0012               1021                       BEQ     sr_byte    
00001A8A  B63C 0001               1022                       CMP.B   #1,D3
00001A8E  6700 0018               1023                       BEQ     sr_word    
00001A92  B63C 0002               1024                       CMP.B   #2,D3
00001A96  6700 001E               1025                       BEQ     sr_long
00001A9A                          1026  
00001A9A  23F9 0000413C 00004148  1027  sr_byte              MOVE.L  SIZEB,SIZECODE     *its a byte operation
00001AA4  6000 001E               1028                       BRA     sr_reg_ret
00001AA8  23F9 00004140 00004148  1029  sr_word              MOVE.L  SIZEW,SIZECODE     *itsva a word operation
00001AB2  6000 0010               1030                       BRA     sr_reg_ret
00001AB6  23F9 00004144 00004148  1031  sr_long              MOVE.L  SIZEL,SIZECODE     *its a long operation
00001AC0  6000 0002               1032                       BRA     sr_reg_ret  
00001AC4                          1033  
00001AC4  4202                    1034  sr_reg_ret           CLR.B   D2
00001AC6  E59A                    1035                       ROL.L   #2,D2              *get the 2 type identifying bits
00001AC8  B43C 0000               1036                       CMP.B   #0,D2
00001ACC  6700 0016               1037                       BEQ     as_reg
00001AD0  B43C 0001               1038                       CMP.B   #1,D2
00001AD4  6700 001C               1039                       BEQ     ls_reg
00001AD8  B43C 0003               1040                       CMP.B   #3,D2
00001ADC  6700 0022               1041                       BEQ     ro_reg
00001AE0  6000 F594               1042                       BRA     inv_handler        *its unsupported
00001AE4                          1043                       
00001AE4  23F9 00004098 00004160  1044  as_reg               MOVE.L  AS,INST_NAME       *its AS(L/R)
00001AEE  6000 0054               1045                       BRA     sr_reg_final
00001AF2                          1046  
00001AF2  23F9 00004094 00004160  1047  ls_reg               MOVE.L  LS,INST_NAME       *its LS(L/R)
00001AFC  6000 0046               1048                       BRA     sr_reg_final
00001B00                          1049                       
00001B00  23F9 0000409C 00004160  1050  ro_reg               MOVE.L  RO,INST_NAME       *its RO(L/R)
00001B0A  6000 0038               1051                       BRA     sr_reg_final
00001B0E                          1052  
00001B0E  1604                    1053  sr_reg_print_src     MOVE.B  D4,D3              *move source bits to D3
00001B10  2204                    1054                       MOVE.L  D4,D1              *and to D1
00001B12  BA3C 0001               1055                       CMP.B   #1,D5
00001B16  6700 001E               1056                       BEQ     sr_reg_print_Dn
00001B1A  B23C 0000               1057                       CMP.B   #0,D1              *we know source is immediate-- is it 000(= #8)?
00001B1E  6700 001E               1058                       BEQ     rs_0_shift_handler * yes-load D1 with appropriate dislay data 
00001B22                          1059  sr_reg_print_imm     *JSR     data_mode_print        *identify and print immediate data
00001B22  43F9 0000416E           1060                       LEA     imm_sign,A1        *load up the pound sign
00001B28  103C 000E               1061                       MOVE.B  #14,D0
00001B2C  4E4F                    1062                       TRAP    #15
00001B2E  103C 0003               1063                       MOVE.B  #3,D0              *prep the shift count for display
00001B32  4E4F                    1064                       TRAP    #15
00001B34  4E75                    1065                       RTS                      
00001B36  4EB9 00001D50           1066  sr_reg_print_Dn      JSR     DR_CMP                 *identify and print dest register
00001B3C  4E75                    1067                       RTS
00001B3E                          1068  
00001B3E  123C 0008               1069  rs_0_shift_handler   MOVE.B  #8,D1
00001B42  60DE                    1070                       BRA     sr_reg_print_imm
00001B44                          1071                
00001B44  4EB9 00001FE0           1072  sr_reg_final         JSR     disp_instr
00001B4A  4202                    1073                       CLR.B   D2
00001B4C  E79A                    1074                       ROL.L   #3,D2          *get dest Dn bits in D2
00001B4E  4EB8 1B0E               1075                       JSR     sr_reg_print_src   *determine if source is register/immediate based on D5 flag, print
00001B52  4EB9 0000209A           1076                       JSR     print_comma
00001B58  1602                    1077                       MOVE.B  D2,D3          *move dest bits to D3
00001B5A  4EB9 00001D50           1078                       JSR     DR_CMP         *print destination register
00001B60  DAFC 0002               1079                       ADDA    #word_len,A5   *reg shift/roll took up a word
00001B64  6000 F4AE               1080                       BRA     prep           
00001B68                          1081                                      
00001B68                          1082   * /_shift_roll_handler  
00001B68                          1083  *-----------------------------------------------------------------------------
00001B68                          1084  
00001B68                          1085                          
00001B68                          1086  *-----------------------------------------------------------------------------
00001B68                          1087  * lea_handler
00001B68                          1088  * handles lea
00001B68                          1089  
00001B68                          1090  *D1: holds opcode instruction
00001B68                          1091  *D2: holds register bits
00001B68                          1092  
00001B68  E209                    1093  lea_handler       LSR.B     #1,D1          *hardcoded bit
00001B6A  2401                    1094                    MOVE.L    D1,D2          *save dest An bits to D2
00001B6C  4201                    1095                    CLR.B     D1
00001B6E  E589                    1096                    LSL.L     #2,D1          *hardcoded bits
00001B70  E799                    1097                    ROL.L     #3,D1
00001B72  2601                    1098                    MOVE.L    D1,D3          *get EA bits into D3
00001B74  23F9 00004044 00004160  1099                    MOVE.L    LEA,INST_NAME
00001B7E  4EB9 00001FE0           1100                    JSR       disp_instr       
00001B84  4EB9 00001CDA           1101                    JSR       EA_SRC_beg
00001B8A  4EB9 0000209A           1102                    JSR       print_comma
00001B90  2602                    1103                    MOVE.L    D2,D3
00001B92  4EB9 00001DB4           1104                    JSR       PRINT_INNER_An     
00001B98  6000 F47A               1105                    BRA       prep
00001B9C                          1106                    
00001B9C                          1107                    
00001B9C                          1108  * /lea_handler
00001B9C                          1109  *-----------------------------------------------------------------------------
00001B9C                          1110  
00001B9C                          1111  
00001B9C                          1112  *-----------------------------------------------------------------------------
00001B9C                          1113  *jsr_handler
00001B9C                          1114  *handles 'JSR'
00001B9C                          1115  
00001B9C  23F9 00004054 00004160  1116  jsr_handler       MOVE.L  JSR,INST_NAME
00001BA6  4EB9 00001FE0           1117                    JSR     disp_instr
00001BAC  4202                    1118                    CLR.B   D2            *clear byte space for next few bits
00001BAE  E79A                    1119                    ROL.L   #3,D2         *save EA bits into D2
00001BB0  2602                    1120                    MOVE.L  D2,D3
00001BB2  4EB9 00001CDA           1121                    JSR     EA_SRC_beg
00001BB8  6000 F45A               1122                    BRA     prep
00001BBC                          1123  
00001BBC                          1124  * /jsr_handler
00001BBC                          1125  *-----------------------------------------------------------------------------
00001BBC                          1126  
00001BBC                          1127  
00001BBC                          1128  *-----------------------------------------------------------------------------
00001BBC                          1129  *movem_handler
00001BBC                          1130  *handles 'MOVEM'
00001BBC                          1131  
00001BBC                          1132  *An list corresponds to higher byte
00001BBC                          1133  *Dn list corresponds to lower byte
00001BBC                          1134  
00001BBC                          1135  *D2:holds first register in sublist
00001BBC                          1136  *D3:holds the number of successive 1's shifted out of a list (register train)
00001BBC                          1137  *D4:holds number of iterations for shifting out the bits in the list bytes. also the register number.
00001BBC                          1138  *D5:holds the An list byte
00001BBC                          1139  *D6:holds the Dn list byte
00001BBC                          1140  
00001BBC  23F9 0000403C 00004160  1141  movem_handler  MOVE.L  MOV,INST_NAME
00001BC6  23F9 00004134 00004168  1142                 MOVE.L  EM,INST_NAME_EXT
00001BD0  B23C 0008               1143                 CMP.B   #$8,D1
00001BD4  6700 0026               1144                 BEQ     movem_dn
00001BD8  4201                    1145  movem_an       CLR.B   D1
00001BDA  E589                    1146                 LSL.L   #2,D1
00001BDC  6500 0010               1147                 BCS     movem_long
00001BE0                          1148                 
00001BE0  23F9 00004140 00004148  1149  movem_word     MOVE.L  SIZEW,SIZECODE
00001BEA  6000 0018               1150                 BRA     movem_list
00001BEE  23F9 00004144 00004148  1151  movem_long     MOVE.L  SIZEL,SIZECODE
00001BF8  6000 000A               1152                 BRA     movem_list
00001BFC                          1153  
00001BFC  4201                    1154  movem_dn       CLR.B   D1
00001BFE  E589                    1155                 LSL.L   #2,D1
00001C00  65EC                    1156                 BCS     movem_long
00001C02  60DC                    1157                 BRA     movem_word
00001C04                          1158  
00001C04  4EB9 00001FE0           1159  movem_list     JSR     disp_instr
00001C0A  DAFC 0002               1160                 ADDA    #word_len,A5                 *get to register list word
00001C0E  3A15                    1161                 MOVE.W  (A5),D5                      *move entire list to D5
00001C10  1C05                    1162                 MOVE.B  D5,D6                        *move lower order byte (Dn list) to D6
00001C12  E04D                    1163                 LSR.W   #word_len*4,D5               *shift the An list to the lower order of D5                  
00001C14  7801                    1164                 MOVE.L  #1,D4                        *init loop counter/register number
00001C16  4282                    1165                 CLR.L   D2                           *clear D2, which is holding first register in train
00001C18  4283                    1166                 CLR.L   D3                           *set train counter to 1
00001C1A  6000 0002               1167                 BRA     movem_dn_list_loop           *first take care or the Dn list
00001C1E                          1168     
00001C1E  B83C 0008               1169  movem_dn_list_loop     CMP.B  #word_len*4,D4        *have we done the register list [d0,d6]?
00001C22  6700 0024               1170                         BEQ    movem_dn_last         * yes get the last register bit (d7)
00001C26  E20E                    1171                         LSR.B  #1,D6                 *shift out a (Dn) bit. 1 if its in the list, 0 if not
00001C28  6500 0006               1172                         BCS    movem_dn_list_status_1  *a register was identified--check status of register train
00001C2C  5244                    1173                         ADDI   #1,D4
00001C2E  60EE                    1174                         BRA    movem_dn_list_loop    *check status
00001C30                          1175                      
00001C30  C744                    1176  movem_dn_list_status_1 EXG    D3,D4                 *print appropriate data register corresponding to shifted out bit
00001C32  5343                    1177                         SUBI   #1,D3
00001C34  4EB9 00001D50           1178                         JSR    DR_CMP
00001C3A  4EB9 000020C6           1179                         JSR    print_slash
00001C40  5243                    1180                         ADDI   #1,D3
00001C42  C744                    1181                         EXG    D3,D4
00001C44  5244                    1182                         ADDI   #1,D4
00001C46  60D6                    1183                         BRA    movem_dn_list_loop   *return to the loop                                   
00001C48                          1184                          
00001C48  E20E                    1185  movem_dn_last          LSR.B  #1,D6
00001C4A  6500 0006               1186                         BCS    movem_d7_print
00001C4E  6000 0010               1187                         BRA    movem_an_list_prep
00001C52                          1188                          
00001C52  163C 0007               1189  movem_d7_print         MOVE.B #7,D3
00001C56  103C 0001               1190                         MOVE.B #1,D0                 *flag d7 as having been printed for next round of An's
00001C5A  4EB9 00001D50           1191                         JSR    DR_CMP
00001C60                          1192                         
00001C60  CB46                    1193  movem_an_list_prep     EXG    D5,D6                 *get higher order (an) byte
00001C62  7801                    1194                         MOVE.L #1,D4                 *init loop
00001C64  4203                    1195                         CLR.B  D3   
00001C66  B83C 0008               1196  movem_an_list_loop     CMP.B  #word_len*4,D4        *have we done the register list [d0,d6]?
00001C6A  6700 0024               1197                         BEQ    movem_an_last         * yes get the last register bit (d7)
00001C6E  E20E                    1198                         LSR.B  #1,D6                 *shift out a (Dn) bit. 1 if its in the list, 0 if not
00001C70  6500 0006               1199                         BCS    movem_an_list_status_1  *a register was identified--check status of register train
00001C74  5244                    1200                         ADDI   #1,D4
00001C76  60EE                    1201                         BRA    movem_an_list_loop    *check status
00001C78                          1202                      
00001C78  C744                    1203  movem_an_list_status_1 EXG    D3,D4                 *continue in same way as Dn loop
00001C7A  5343                    1204                         SUBI   #1,D3
00001C7C  4EB9 000020C6           1205                         JSR    print_slash
00001C82  4EB9 00001DB4           1206                         JSR    PRINT_INNER_AN
00001C88  5243                    1207                         ADDI   #1,D3
00001C8A  C744                    1208                         EXG    D3,D4
00001C8C  5244                    1209                         ADDI   #1,D4
00001C8E  60D6                    1210                         BRA    movem_an_list_loop                                      
00001C90                          1211                          
00001C90  E20E                    1212  movem_an_last          LSR.B  #1,D6
00001C92  6500 0006               1213                         BCS    movem_a7_print
00001C96  6000 0012               1214                         BRA    movem_ea
00001C9A                          1215                          
00001C9A  163C 0007               1216  movem_a7_print         MOVE.B #7,D3
00001C9E  4EB9 000020C6           1217                         JSR    print_slash
00001CA4  4EB9 00001DB4           1218                         JSR    PRINT_INNER_AN
00001CAA                          1219                
00001CAA                          1220               
00001CAA  4EB9 0000209A           1221  movem_ea       JSR     print_comma
00001CB0  4201                    1222                 CLR.B   D1
00001CB2  E799                    1223                 ROL.L   #3,D1            *get EA bits
00001CB4  2601                    1224                 MOVE.L  D1,D3            *and put them into D3
00001CB6  4EB9 00001CDA           1225                 JSR     EA_SRC_beg       *identify and print destination
00001CBC  6000 F356               1226                 BRA     prep
00001CC0                          1227  
00001CC0                          1228  * /movem_handler
00001CC0                          1229  *-----------------------------------------------------------------------------
00001CC0                          1230  
00001CC0                          1231  *-----------------------------------------------------------------------------
00001CC0                          1232  * rts_handler
00001CC0                          1233  * handles 'RTS'
00001CC0                          1234  
00001CC0  4281                    1235  rts_handler    CLR.L  D1                    *rts all hardcoded
00001CC2  23F9 0000405C 00004160  1236                 MOVE.L RTS,INST_NAME
00001CCC  4EB9 00001FE0           1237                 JSR    disp_instr
00001CD2  DAFC 0002               1238                 ADDA   #word_len,A5          *rts took up a word
00001CD6  6000 F33C               1239                 BRA    prep
00001CDA                          1240  
00001CDA                          1241  * /rts_handler
00001CDA                          1242  *-----------------------------------------------------------------------------
00001CDA                          1243  
00001CDA                          1244  
00001CDA                          1245  
00001CDA                          1246  *below functions also increment address pointer A5 depending on data fetch size for immediate,absolute addresses
00001CDA                          1247  
00001CDA  DAFC 0002               1248  EA_SRC_beg  ADDA   #word_len,A5             *increment pointer to next word in address range
00001CDE                          1249  
00001CDE                          1250              *(xxx).W, (xxx).L, #<data>        
00001CDE  0C03 0007               1251  EA_SRC      CMPI.B #$7, D3            *Compares if its 111
00001CE2  6700 002E               1252                 BEQ FILTER_EA_MODE
00001CE6                          1253  
00001CE6                          1254              *Dn
00001CE6  0C03 0000               1255              CMPI.B #$0, D3           *Compares if its 000
00001CEA                          1256                  
00001CEA  6700 0060               1257                  BEQ DATA_REGISTER
00001CEE                          1258                  
00001CEE  0C03 0001               1259              CMPI.B #1, D3               *001
00001CF2  6700 0050               1260                  BEQ ADDRESS_MODE
00001CF6                          1261                  
00001CF6                          1262              *(An)
00001CF6  0C03 0002               1263              CMPI.B #$2, D3            *Compares if its 010
00001CFA  6700 0094               1264                  BEQ CLOSED_PARAN
00001CFE                          1265                  
00001CFE                          1266              *(An)+
00001CFE  0C03 0003               1267              CMPI.B #$3, D3            *Compares if its 011
00001D02  6700 00F0               1268                  BEQ POSTFIX_PLUS
00001D06                          1269              
00001D06                          1270              *-(An)                  *Compares if its 100
00001D06  0C03 0004               1271              CMPI.B #$4, D3
00001D0A  6700 0116               1272                  BEQ PREFIX_MINUS
00001D0E                          1273                  
00001D0E  6600 0024               1274                  BNE INVALID_MODE      *e.g. ARI,PCI
00001D12                          1275  
00001D12                          1276  FILTER_EA_MODE
00001D12                          1277          *Rotate to get register as byte
00001D12  4203                    1278          CLR.B  D3
00001D14  E79B                    1279          ROL.L  #3,D3
00001D16                          1280           
00001D16                          1281          *(xxx).W
00001D16  0C03 0000               1282          CMPI.B #$0, D3
00001D1A  6700 0134               1283              BEQ WORD_MODE
00001D1E                          1284              
00001D1E                          1285          *(xxx).L
00001D1E  0C03 0001               1286          CMPI.B #$1, D3
00001D22  6700 0146               1287              BEQ LONG_MODE
00001D26                          1288              
00001D26                          1289          *# <data>
00001D26  0C03 0004               1290          CMPI.B #$4, D3
00001D2A  6700 0158               1291              BEQ DATA_MODE
00001D2E  6600 0004               1292              BNE INVALID_MODE
00001D32  4E75                    1293      RTS
00001D34                          1294  
00001D34                          1295  
00001D34                          1296  INVALID_MODE    *unsupported mode eg PCD,PCI
00001D34  227C 0000411C           1297      MOVE.L  #INV,A1
00001D3A  103C 000E               1298      MOVE.B  #14,D0
00001D3E  4E4F                    1299      TRAP    #15
00001D40                          1300      
00001D40  544D                    1301      ADDA    #2,A5   ******* inv opcodes take up a word
00001D42                          1302      
00001D42  4E75                    1303      RTS
00001D44                          1304      
00001D44                          1305  *An
00001D44                          1306  ADDRESS_MODE  *Get register to get what Dn to go to
00001D44  4203                    1307      CLR.B  D3
00001D46  E79B                    1308      ROL.L  #3,D3
00001D48  6000 006A               1309      BRA    PRINT_INNER_An
00001D4C                          1310  
00001D4C                          1311  * Dn
00001D4C                          1312  DATA_REGISTER    *Get register to get what Dn to go to
00001D4C  4203                    1313      CLR.B  D3
00001D4E  E79B                    1314      ROL.L  #3,D3
00001D50                          1315      
00001D50  0C03 0000               1316  DR_CMP  CMPI.B #0, D3
00001D54  6700 016A               1317          BEQ PRINT_D0
00001D58  0C03 0001               1318      CMPI.B #1, D3
00001D5C  6700 0174               1319          BEQ PRINT_D1
00001D60  0C03 0002               1320      CMPI.B #2, D3
00001D64  6700 017E               1321          BEQ PRINT_D2
00001D68  0C03 0003               1322      CMPI.B #3, D3
00001D6C  6700 0188               1323          BEQ PRINT_D3
00001D70  0C03 0004               1324      CMPI.B #4, D3
00001D74  6700 0192               1325          BEQ PRINT_D4
00001D78  0C03 0005               1326      CMPI.B #5, D3
00001D7C  6700 019C               1327          BEQ PRINT_D5
00001D80  0C03 0006               1328      CMPI.B #6, D3
00001D84  6700 01A6               1329          BEQ PRINT_D6
00001D88  0C03 0007               1330      CMPI.B #7, D3
00001D8C  6700 01B0               1331          BEQ PRINT_D7
00001D90                          1332      
00001D90                          1333  * (An)
00001D90                          1334  CLOSED_PARAN  *Get register to get what Dn to go to
00001D90  4203                    1335      CLR.B  D3
00001D92  E79B                    1336      ROL.L  #3,D3
00001D94                          1337      *Prints '('
00001D94  43F9 00004170           1338      LEA open_paren, A1
00001D9A  103C 000E               1339      MOVE.B #14, D0
00001D9E  4E4F                    1340      TRAP #15
00001DA0                          1341      
00001DA0                          1342      *Print The appropriate value of An *Needed to use JSR & RTS
00001DA0  4EB9 00001DB4           1343      JSR PRINT_INNER_An
00001DA6                          1344     
00001DA6                          1345      *Prints ')'
00001DA6  43F9 00004172           1346      LEA closed_paren, A1
00001DAC  103C 000E               1347      MOVE.B #14, D0
00001DB0  4E4F                    1348      TRAP #15
00001DB2  4E75                    1349      RTS
00001DB4                          1350      
00001DB4                          1351  *Prints the An in (An) and returns to the original method   
00001DB4                          1352  PRINT_INNER_An
00001DB4  0C43 0000               1353      CMPI  #0, D3
00001DB8  6700 0196               1354          BEQ    PRINT_A0
00001DBC  0C43 0001               1355      CMPI #1, D3
00001DC0  6700 01A0               1356          BEQ PRINT_A1
00001DC4  0C43 0002               1357      CMPI #2, D3
00001DC8  6700 01AA               1358          BEQ PRINT_A2
00001DCC  0C43 0003               1359      CMPI #3, D3
00001DD0  6700 01B4               1360          BEQ PRINT_A3
00001DD4  0C43 0004               1361      CMPI #4, D3
00001DD8  6700 01BE               1362          BEQ PRINT_A4
00001DDC  0C43 0005               1363      CMPI #5, D3
00001DE0  6700 01C8               1364          BEQ PRINT_A5
00001DE4  0C43 0006               1365      CMPI #6, D3
00001DE8  6700 01D2               1366          BEQ PRINT_A6
00001DEC  0C43 0007               1367      CMPI #7, D3
00001DF0  6700 01DC               1368          BEQ PRINT_A7
00001DF4                          1369  
00001DF4                          1370  * (An)+
00001DF4                          1371  POSTFIX_PLUS
00001DF4  4203                    1372      CLR.B  D3
00001DF6  E79B                    1373      ROL.L  #3,D3
00001DF8                          1374      
00001DF8                          1375      *Prints '('
00001DF8  43F9 00004170           1376      LEA open_paren, A1
00001DFE  103C 000E               1377      MOVE.B #14, D0
00001E02  4E4F                    1378      TRAP #15
00001E04                          1379  
00001E04                          1380      
00001E04                          1381      *Print The appropriate value of An
00001E04  4EB8 1DB4               1382      JSR PRINT_INNER_An
00001E08                          1383      
00001E08                          1384      *Prints ')'
00001E08  43F9 00004172           1385      LEA closed_paren, A1
00001E0E  103C 000E               1386      MOVE.B #14, D0
00001E12  4E4F                    1387      TRAP #15
00001E14                          1388      
00001E14                          1389       *Prints '+'
00001E14  43F9 00004174           1390      LEA plus_sign, A1
00001E1A  103C 000E               1391      MOVE.B #14, D0
00001E1E  4E4F                    1392      TRAP #15
00001E20  4E75                    1393      RTS
00001E22                          1394      
00001E22                          1395  *-(An)
00001E22  4203                    1396  PREFIX_MINUS   CLR.B  D3
00001E24  E79B                    1397      ROL.L  #3,D3
00001E26                          1398      
00001E26                          1399       *Prints '-'
00001E26  43F9 00004176           1400      LEA neg_sign, A1
00001E2C  103C 000E               1401      MOVE.B #14, D0
00001E30  4E4F                    1402      TRAP #15
00001E32                          1403      
00001E32                          1404      *Prints '('
00001E32  43F9 00004170           1405      LEA open_paren, A1
00001E38  103C 000E               1406      MOVE.B #14, D0
00001E3C  4E4F                    1407      TRAP #15
00001E3E                          1408      
00001E3E                          1409      *Print The appropriate value of An *Needed to use JSR & RTS
00001E3E  4EB8 1DB4               1410      JSR PRINT_INNER_An
00001E42                          1411      
00001E42                          1412      
00001E42                          1413      *Prints ')'
00001E42  43F9 00004172           1414      LEA closed_paren, A1
00001E48  103C 000E               1415      MOVE.B #14, D0
00001E4C  4E4F                    1416      TRAP #15
00001E4E                          1417   
00001E4E  4E75                    1418      RTS
00001E50                          1419      
00001E50                          1420  *(xxx).W 
00001E50  48E7 4000               1421  WORD_MODE  MOVEM.L  D1,-(SP)      *save calling state of D1
00001E54  4281                    1422             CLR.L    D1
00001E56                          1423             *ADDA     #word_len,A5  *increment the pointer to the next address by the length of the next WORD fetched from memory
00001E56  4EB9 000020B0           1424             JSR      print_addr_sgn
00001E5C  305D                    1425             MOVE.W   (A5)+,A0      *move that word value to A0 for display
00001E5E  4EB9 00002034           1426             JSR      hex_2_ascii   *convert/display the word
00001E64  4CDF 0002               1427             MOVEM.L  (SP)+,D1      *restore D1
00001E68  4E75                    1428             RTS
00001E6A                          1429      
00001E6A                          1430  *(xxx).L 
00001E6A  48E7 4000               1431  LONG_MODE  MOVEM.L  D1,-(SP)      *save calling state of D1
00001E6E  4281                    1432             CLR.L    D1
00001E70                          1433             *ADDA     #long_len,A5 *increment the pointer to the next address by the length of the next LONG fetched from memory
00001E70  4EB9 000020B0           1434             JSR      print_addr_sgn
00001E76  205D                    1435             MOVE.L   (A5)+,A0      *move that long value to A0 for display
00001E78  4EB9 00002034           1436             JSR      hex_2_ascii   *convert/display the long in A0
00001E7E  4CDF 0002               1437             MOVEM.L  (SP)+,D1      *restore D1
00001E82  4E75                    1438             RTS
00001E84                          1439             
00001E84                          1440  
00001E84                          1441  *#<data>
00001E84  48E7 4000               1442  DATA_MODE  MOVEM.L  D1,-(SP)        *save calling state of D1
00001E88  4281                    1443             CLR.L    D1 
00001E8A  0C12 0001               1444             CMP.B    #1,(A2)         *is immediate data flagged as a word?
00001E8E  6700 000A               1445             BEQ      word_data_handler
00001E92  0C12 0002               1446             CMP.B    #2,(A2)         *is immediate data flagged as a long?
00001E96  6700 0008               1447             BEQ      long_data_handler         
00001E9A                          1448  
00001E9A                          1449                                      *then its a byte held as a word 
00001E9A                          1450  
00001E9A                          1451  *byte_data_handler *ADDA     #byte_len,A5
00001E9A                          1452   *                 MOVE.B   (A5)+,D1     *get immediate byte data and increment address by a byte
00001E9A                          1453    *                BRA      data_mode_print
00001E9A                          1454                  
00001E9A                          1455  word_data_handler *ADDA     #word_len,A5
00001E9A  321D                    1456                    MOVE.W   (A5)+,D1     *get immediate word data and increment address by a word
00001E9C  6000 0008               1457                    BRA      data_mode_print
00001EA0                          1458  
00001EA0                          1459  long_data_handler *ADDA     #long_len,A5
00001EA0  221D                    1460                    MOVE.L   (A5)+,D1     *get immediate long data and increment address by a long
00001EA2  6000 0002               1461                    BRA      data_mode_print
00001EA6                          1462  
00001EA6  43F9 0000416E           1463  data_mode_print   LEA      imm_sign, A1    *load and print '#' character
00001EAC  103C 000E               1464                    MOVE.B   #14, D0
00001EB0  4E4F                    1465                    TRAP     #15  
00001EB2  2041                    1466                    MOVE.L   D1,A0
00001EB4  4EB9 00002034           1467                    JSR      hex_2_ascii  *print the hex data
00001EBA  4CDF 0002               1468                    MOVEM.L  (SP)+,D1     *restore D1
00001EBE  4E75                    1469                    RTS
00001EC0                          1470  
00001EC0  43F9 00001ECE           1471  PRINT_D0 LEA D0_MESS, A1
00001EC6  103C 000E               1472      MOVE.B #14, D0
00001ECA  4E4F                    1473      TRAP #15
00001ECC  4E75                    1474      RTS
00001ECE= 4430 0000               1475  D0_MESS  DC.W 'D0',0
00001ED2                          1476  
00001ED2                          1477  
00001ED2  43F9 00001EE0           1478  PRINT_D1 LEA D1_MESS, A1
00001ED8  103C 000E               1479      MOVE.B #14, D0
00001EDC  4E4F                    1480      TRAP #15
00001EDE  4E75                    1481      RTS
00001EE0= 4431 0000               1482  D1_MESS  DC.W 'D1',0
00001EE4                          1483  
00001EE4                          1484  
00001EE4  43F9 00001EF2           1485  PRINT_D2 LEA D2_MESS, A1
00001EEA  103C 000E               1486      MOVE.B #14, D0
00001EEE  4E4F                    1487      TRAP #15
00001EF0  4E75                    1488      RTS
00001EF2= 4432 0000               1489  D2_MESS  DC.W 'D2',0
00001EF6                          1490  
00001EF6                          1491  
00001EF6  43F9 00001F04           1492  PRINT_D3 LEA D3_MESS, A1
00001EFC  103C 000E               1493      MOVE.B #14, D0
00001F00  4E4F                    1494      TRAP #15
00001F02  4E75                    1495      RTS
00001F04= 4433 0000               1496  D3_MESS  DC.W 'D3',0
00001F08                          1497  
00001F08                          1498  
00001F08  43F9 00001F16           1499  PRINT_D4 LEA D4_MESS, A1
00001F0E  103C 000E               1500      MOVE.B #14, D0
00001F12  4E4F                    1501      TRAP #15
00001F14  4E75                    1502      RTS
00001F16= 4434 0000               1503  D4_MESS  DC.W 'D4',0
00001F1A                          1504  
00001F1A                          1505  
00001F1A  43F9 00001F28           1506  PRINT_D5 LEA D5_MESS, A1
00001F20  103C 000E               1507      MOVE.B #14, D0
00001F24  4E4F                    1508      TRAP #15
00001F26  4E75                    1509      RTS
00001F28= 4435 0000               1510  D5_MESS  DC.W 'D5',0
00001F2C                          1511  
00001F2C                          1512  
00001F2C  43F9 00001F3A           1513  PRINT_D6 LEA D6_MESS, A1
00001F32  103C 000E               1514      MOVE.B #14, D0
00001F36  4E4F                    1515      TRAP #15
00001F38  4E75                    1516      RTS
00001F3A= 4436 0000               1517  D6_MESS  DC.W 'D6',0
00001F3E                          1518  
00001F3E  43F9 00001F4C           1519  PRINT_D7 LEA D7_MESS, A1
00001F44  103C 000E               1520      MOVE.B #14, D0
00001F48  4E4F                    1521      TRAP #15
00001F4A  4E75                    1522      RTS
00001F4C= 4437 0000               1523  D7_MESS  DC.W 'D7',0
00001F50                          1524      
00001F50                          1525  
00001F50  43F9 00001F5E           1526  PRINT_A0 LEA A0_MESS, A1
00001F56  103C 000E               1527      MOVE.B #14, D0
00001F5A  4E4F                    1528      TRAP #15
00001F5C  4E75                    1529      RTS
00001F5E= 4130 0000               1530  A0_MESS DC.W 'A0',0
00001F62                          1531  
00001F62  43F9 00001F70           1532  PRINT_A1 LEA A1_MESS, A1
00001F68  103C 000E               1533      MOVE.B #14, D0
00001F6C  4E4F                    1534      TRAP #15
00001F6E  4E75                    1535      RTS
00001F70= 4131 0000               1536  A1_MESS DC.W 'A1',0
00001F74                          1537  
00001F74  43F9 00001F82           1538  PRINT_A2 LEA A2_MESS, A1
00001F7A  103C 000E               1539      MOVE.B #14, D0
00001F7E  4E4F                    1540      TRAP #15
00001F80  4E75                    1541      RTS
00001F82= 4132 0000               1542  A2_MESS DC.W 'A2',0
00001F86                          1543  
00001F86  43F9 00001F94           1544  PRINT_A3 LEA A3_MESS, A1
00001F8C  103C 000E               1545      MOVE.B #14, D0
00001F90  4E4F                    1546      TRAP #15
00001F92  4E75                    1547      RTS
00001F94= 4133 0000               1548  A3_MESS DC.W 'A3',0
00001F98                          1549  
00001F98  43F9 00001FA6           1550  PRINT_A4 LEA A4_MESS, A1
00001F9E  103C 000E               1551      MOVE.B #14, D0
00001FA2  4E4F                    1552      TRAP #15
00001FA4  4E75                    1553      RTS
00001FA6= 4134 0000               1554  A4_MESS DC.W 'A4',0
00001FAA                          1555  
00001FAA  43F9 00001FB8           1556  PRINT_A5 LEA A5_MESS, A1
00001FB0  103C 000E               1557      MOVE.B #14, D0
00001FB4  4E4F                    1558      TRAP #15
00001FB6  4E75                    1559      RTS
00001FB8= 4135 0000               1560  A5_MESS DC.W 'A5',0
00001FBC                          1561  
00001FBC  43F9 00001FCA           1562  PRINT_A6 LEA A6_MESS, A1
00001FC2  103C 000E               1563      MOVE.B #14, D0
00001FC6  4E4F                    1564      TRAP #15
00001FC8  4E75                    1565      RTS
00001FCA= 4136 0000               1566  A6_MESS DC.W 'A6',0
00001FCE                          1567  
00001FCE  43F9 00001FDC           1568  PRINT_A7 LEA A7_MESS, A1
00001FD4  103C 000E               1569      MOVE.B #14, D0
00001FD8  4E4F                    1570      TRAP #15
00001FDA  4E75                    1571      RTS
00001FDC= 4137 0000               1572  A7_MESS DC.W 'A7',0
00001FE0                          1573                
00001FE0                          1574  *-----------------------------------------------------------------------------------------
00001FE0                          1575  *disp_instr
00001FE0                          1576  * displays the instruction name in assembly and the address of the instruction
00001FE0                          1577  
00001FE0  48E7 4000               1578  disp_instr    MOVEM.L D1, -(SP)     *save state of D1 before using it below
00001FE4                          1579  
00001FE4  4EB9 000020B0           1580                JSR     print_addr_sgn *print '$'
00001FEA  204D                    1581                MOVEA.L A5,A0          *load A0 with the current address for the next function
00001FEC  4EB9 00002034           1582                JSR     hex_2_ascii    *convert the hex addr to ascii to print
00001FF2                          1583                
00001FF2  43F9 0000417F           1584                LEA     space,A1
00001FF8  103C 000E               1585                MOVE.B  #14,D0
00001FFC  4E4F                    1586                TRAP    #15
00001FFE                          1587                
00001FFE  43F9 00004160           1588                LEA.L   INST_NAME,A1  *move the (assembly) name of this instruction into A1
00002004  103C 000E               1589                MOVE.B  #14,D0
00002008  4E4F                    1590                TRAP    #15
0000200A                          1591                
0000200A  43F9 00004168           1592                LEA     INST_NAME_EXT,A1  *if the instruction name was longer than 32 bits
00002010  103C 000E               1593                MOVE.B  #14,D0
00002014  4E4F                    1594                TRAP    #15
00002016                          1595                
00002016  43F9 00004148           1596                LEA.L   SIZECODE,A1       *print size of operation
0000201C  103C 000E               1597                MOVE.B  #14,D0
00002020  4E4F                    1598                TRAP    #15
00002022                          1599                
00002022  43F9 0000417F           1600                LEA     space,A1
00002028  103C 000E               1601                MOVE.B  #14,D0
0000202C  4E4F                    1602                TRAP    #15
0000202E                          1603                
0000202E                          1604                
0000202E  4CDF 0002               1605                MOVEM.L  (SP)+,D1         *restore D1
00002032  4E75                    1606                RTS
00002034                          1607                
00002034                          1608  * /disp_instr
00002034                          1609  *-----------------------------------------------------------------------------------------  
00002034                          1610  
00002034                          1611  
00002034                          1612  *----------------------------------------------------------------------------------------- 
00002034                          1613  *hex_2_ascii
00002034                          1614  * converts a hex number to its ascii string equivalent (0s in MSB positions).
00002034                          1615  
00002034                          1616  * move A0 into D3 and split first part of address and second part of address 
00002034                          1617  *   to D3 and D4 respectively
00002034                          1618  
00002034                          1619  *D3:less significant word of address
00002034                          1620  *D4:more significant word of address 
00002034                          1621  *D5:holds iteration number
00002034                          1622  *D6:index into table
00002034                          1623  
00002034                          1624  h2a_regs        REG     D1/D3-D6/A0/A4
00002034                          1625  
00002034  48E7 5E88               1626  hex_2_ascii     MOVEM.L h2a_regs,-(SP)  *save state of registers before call                                
00002038  4285                    1627                  CLR.L   D5              *clear iteration counter
0000203A  4281                    1628                  CLR.L   D1
0000203C  4286                    1629                  CLR.L   D6
0000203E  2808                    1630                  MOVE.L  A0,D4           *save address in D4
00002040  2604                    1631                  MOVE.L  D4,D3           *and move it to D3
00002042  4244                    1632                  CLR.W   D4              
00002044  4843                    1633                  SWAP    D3              *partition the first and second long of the address
00002046  4243                    1634                  CLR.W   D3
00002048  49F9 00004000           1635  h2a_prep        LEA.L   string_tbl,A4
0000204E  E99C                    1636                  ROL.L   #4,D4           *roll first byte over for analysis
00002050  B834 6801               1637  h2a_loop        CMP.B   1(A4,D6.L),D4   *find hex/ascii match in table
00002054  6700 0016               1638                  BEQ     h2a_match
00002058  BC3C 0020               1639                  cmp.b   #32,d6
0000205C  6C00 0006               1640                  BGE     h2a_f 
00002060  5486                    1641                  ADDI.L  #2,D6
00002062  60EC                    1642                  BRA     h2a_loop
00002064  123C 000F               1643  h2a_f           MOVE.B  #$F,D1
00002068  6000 0006               1644                  BRA     h2a_match_cont        
0000206C  1234 6000               1645  h2a_match       MOVE.B  (A4,D6.W),D1    *move the match to D1
00002070  103C 0006               1646  h2a_match_cont  MOVE.B  #6,D0           *display the value in D1
00002074  4E4F                    1647                  TRAP    #15
00002076  4204                    1648                  CLR.B   D4
00002078  4206                    1649                  CLR.B   D6
0000207A  5245                    1650                  ADDI    #1,D5           *increment loop counter
0000207C  BA3C 0008               1651                  CMP.B   #h2a_its,D5     *have we done every nibble
00002080  6C00 0012               1652                  BGE     h2a_ret
00002084  BA3C 0004               1653                  CMP.B   #h2a_its-4,D5   *are we halfway done (time to get second part of addr?)
00002088  6700 0004               1654                  BEQ     h2a_swap
0000208C  60BA                    1655                  BRA     h2a_prep
0000208E  2803                    1656  h2a_swap        MOVE.L  D3,D4           *move second part of word to D4 
00002090  4286                    1657                  CLR.L   D6              *clear the index into the string table               
00002092  60B4                    1658                  BRA     h2a_prep
00002094                          1659  
00002094  4CDF 117A               1660  h2a_ret         MOVEM.L  (SP)+,h2a_regs   *restore state of registers 
00002098  4E75                    1661                  RTS
0000209A                          1662                  
0000209A  =00000008               1663  h2a_its         EQU     8
0000209A                          1664  
0000209A                          1665  * /hex_2_ascii
0000209A                          1666  *----------------------------------------------------------------------------------------- 
0000209A                          1667  * the following functions print characters commonly used by this program
0000209A                          1668  
0000209A  48E7 0040               1669  print_comma   MOVEM.L A1,-(SP)
0000209E  43F9 00004178           1670                LEA     comma,A1
000020A4  103C 000E               1671                MOVE.B  #14,D0
000020A8  4E4F                    1672                TRAP    #15    
000020AA  4CDF 0200               1673                MOVEM.L (SP)+,A1
000020AE  4E75                    1674                RTS    
000020B0                          1675                
000020B0  48E7 0040               1676  print_addr_sgn MOVEM.L A1,-(SP)
000020B4  43F9 0000416C           1677                 LEA     addr_sign,A1
000020BA  103C 000E               1678                 MOVE.B  #14,D0
000020BE  4E4F                    1679                 TRAP    #15    
000020C0  4CDF 0200               1680                 MOVEM.L (SP)+,A1
000020C4  4E75                    1681                 RTS    
000020C6                          1682                 
000020C6  48E7 0040               1683  print_slash    MOVEM.L A1,-(SP)
000020CA  43F9 0000417A           1684                 LEA     slash,A1
000020D0  103C 000E               1685                 MOVE.B  #14,D0
000020D4  4E4F                    1686                 TRAP    #15    
000020D6  4CDF 0200               1687                 MOVEM.L (SP)+,A1
000020DA  4E75                    1688                 RTS    
000020DC                          1689                 
000020DC  48E7 0040               1690  print_hyphen   MOVEM.L A1,-(SP)
000020E0  43F9 00004176           1691                 LEA     neg_sign,A1
000020E6  103C 000E               1692                 MOVE.B  #14,D0
000020EA  4E4F                    1693                 TRAP    #15    
000020EC  4CDF 0200               1694                 MOVEM.L (SP)+,A1
000020F0  4E75                    1695                 RTS                 
000020F2                          1696                 
000020F2  43F9 0000417C           1697  done          LEA     nl,A1
000020F8  103C 000E               1698                MOVE.B  #14,D0
000020FC  4E4F                    1699                TRAP    #15
000020FE  43F9 00004244           1700                LEA     done_msg,A1
00002104  103C 000E               1701                MOVE.B  #14,D0
00002108  4E4F                    1702                TRAP    #15
0000210A  103C 0009               1703                MOVE.B  #9,D0         *indicate end of simulation
0000210E  4E4F                    1704                TRAP    #15
00002110                          1705                
00002110  43F9 0000421A           1706  addr_err      LEA     bad_addr,A1   *load the error msg into A1
00002116  103C 000E               1707                MOVE.B  #14,D0       *indicate output
0000211A  4E4F                    1708                TRAP    #15
0000211C  43F9 0000417C           1709                LEA     nl,A1        *load new line into A1
00002122  103C 000E               1710                MOVE.B  #14,D0        *indicate output
00002126  4E4F                    1711                TRAP    #15
00002128  4282                    1712                CLR.L   D2            *reset msb index for further iterations
0000212A                          1713                *BRA     disp_msg      *go back to welcome msg
0000212A                          1714                           
0000212A  43F9 0000416E           1715  fatal_err     LEA     imm_sign,A1   *load the error msg into A1
00002130  103C 000E               1716                MOVE.B  #14,D0       *indicate output
00002134  4E4F                    1717                TRAP    #15
00002136  43F9 0000417C           1718                LEA     nl,A1        *load new line into A1
0000213C  103C 000E               1719                MOVE.B  #14,D0        *indicate output
00002140  4E4F                    1720                TRAP    #15
00002142  4282                    1721                CLR.L   D2            *reset msb index for further iterations
00002144  60AC                    1722                BRA     done         *go back to welcome msg
00002146                          1723                
00002146                          1724  *-------------------------------------------------------------------------------------------------------------------------------------------              
00004000                          1725  data          ORG     $4000
00004000                          1726                
00004000                          1727  *string table for converting user input addresses from ascii to hex      
00004000= 30 00                   1728  string_tbl    DC.B    $30,$0      *{ascii,hex}
00004002= 31 01                   1729                DC.B    $31,$1          
00004004= 32 02                   1730                DC.B    $32,$2 
00004006= 33 03                   1731                DC.B    $33,$3
00004008= 34 04                   1732                DC.B    $34,$4
0000400A= 35 05                   1733                DC.B    $35,$5
0000400C= 36 06                   1734                DC.B    $36,$6
0000400E= 37 07                   1735                DC.B    $37,$7
00004010= 38 08                   1736                DC.B    $38,$8
00004012= 39 09                   1737                DC.B    $39,$9            
00004014= 41 0A                   1738                DC.B    $41,$A
00004016= 42 0B                   1739                DC.B    $42,$B
00004018= 43 0C                   1740                DC.B    $43,$C
0000401A= 44 0D                   1741                DC.B    $44,$D
0000401C= 45 0E                   1742                DC.B    $45,$E
0000401E= 46 0F                   1743                DC.B    $46,$F
00004020                          1744                
00004020                          1745               *hex_1
00004020                          1746               *contains first hex digit of the instruction with corresponding mappings
00004020                          1747               *also contains all supported instructions in the comment field
00004020                          1748                * 1 means the mapping is ambiguous (and we have to read more bits in instruction) 0 means its not.
00004020                          1749                * -1 means the instruction isnt one that can be disassembled in this program             
00004020= 01 01                   1750  hex_1         DC.B    $01,$01  * 'MOVE.B','MOVEA.B'
00004022= 03 01                   1751                DC.B    $03,$01  * 'MOVE.W','MOVEA.W'
00004024= 02 01                   1752                DC.B    $02,$01  * 'MOVEA.L','MOVEA.L'
00004026= 04 01                   1753                DC.B    $04,$01  * 'MOVEM','LEA','NEG','JSR','RTS','NOP'
00004028= 0D 01                   1754                DC.B    $0D,$01  * 'ADD','ADDA'
0000402A= 00 01                   1755                DC.B    $00,$01  * 'ORI','BCLR','CMPI','ADDI','EORI','SUBI'
0000402C= 0B 01                   1756                DC.B    $0B,$01  * 'EOR','CMP'
0000402E= 0E 00                   1757                DC.B    $0E,$00  * 'LSR','LSL','ASR','ASL','ROL','ROR' (determined in shift_roll_handler)
00004030= 06 00                   1758                DC.B    $06,$00  * Bcc('BCS','BGE','BLT','BVC','BRA','BCC','BNE','BEQ','BVS','BGT','BLE')
00004032= 09 00                   1759                DC.B    $09,$00  * 'SUB','SUBA' (determined in sub_handler)
00004034= 05 01                   1760                DC.B    $05,$01  * 'SUBQ','ADDQ'
00004036= 0C 00                   1761                DC.B    $0C,$00  * 'MULS'
00004038= 08 01                   1762                DC.B    $08,$01  * 'OR','DIVS(word)'
0000403A= FF FF                   1763                DC.B    -1,-1    * unsupported instruction-first hex val is not one in the table above
0000403C                          1764  
0000403C                          1765  *below table holds ascii codes for instruction printing
0000403C                          1766  *MOVEA         DC.L    'MOVEA',0
0000403C                          1767  *MOVEM         DC.L    'MOVEM',0              
0000403C= 4D4F5600 00000000       1768  MOV           DC.L    'MOV',0
00004044= 4C454100 00000000       1769  LEA           DC.L    'LEA',0
0000404C= 4E454700 00000000       1770  NEG           DC.L    'NEG',0 
00004054= 4A535200 00000000       1771  JSR           DC.L    'JSR',0
0000405C= 52545300 00000000       1772  RTS           DC.L    'RTS',0
00004064= 4E4F5000 00000000       1773  NOP           DC.L    'NOP',0
0000406C= 41444400 00000000       1774  ADD           DC.L    'ADD',0
00004074= 42434C00 00000000       1775  BCL           DC.L    'BCL',0
0000407C                          1776  *ADDA          DC.L    'ADDA',0
0000407C= 4F524900 00000000       1777  ORI           DC.L    'ORI',0
00004084                          1778  *BCLR          DC.L    'BCLR',0
00004084                          1779  *CMPI          DC.L    'CMPI',0
00004084= 454F5200 00000000       1780  EOR           DC.L    'EOR',0
0000408C= 434D5000 00000000       1781  CMP           DC.L    'CMP',0
00004094= 4C53 0000               1782  LS            DC.W    'LS',0    *LSL,LSR
00004098= 4153 0000               1783  AS            DC.W    'AS',0    *ASL,ASR
0000409C= 524F 0000               1784  RO            DC.W    'RO',0    *ROL,ROR
000040A0= 42435300 00000000       1785  BCS           DC.L    'BCS',0
000040A8= 42474500 00000000       1786  BGE           DC.L    'BGE',0
000040B0= 424C5400 00000000       1787  BLT           DC.L    'BLT',0
000040B8= 42564300 00000000       1788  BVC           DC.L    'BVC',0
000040C0= 42524100 00000000       1789  BRA           DC.L    'BRA',0
000040C8= 42434300 00000000       1790  BCC           DC.L    'BCC',0
000040D0= 424E4500 00000000       1791  BNE           DC.L    'BNE',0
000040D8= 42455100 00000000       1792  BEQ           DC.L    'BEQ',0
000040E0= 42565300 00000000       1793  BVS           DC.L    'BVS',0
000040E8= 42475400 00000000       1794  BGT           DC.L    'BGT',0
000040F0= 424C4500 00000000       1795  BLE           DC.L    'BLE',0
000040F8= 53554200 00000000       1796  SUB           DC.L    'SUB',0
00004100= 4D554C00 00000000       1797  MUL           DC.L    'MUL',0
00004108= 44495600 00000000       1798  DIV           DC.L    'DIV',0
00004110= 4F52 0000               1799  OR            DC.W    'OR',0
00004114= 44415400 00000000       1800  DAT           DC.L    'DAT',0   *DATA
0000411C= 494E5600 00000000       1801  INV           DC.L    'INV',0   *used for displaying unsupported addressing modes e.g --  MOVE.L 8(A4,D0),5(A4)
00004124                          1802  
00004124                          1803  *below holds extended codes to append to the instruction
00004124= 41 00                   1804  A             DC.B    'A',0
00004126= 49 00                   1805  I             DC.B    'I',0
00004128= 52 00                   1806  R             DC.B    'R',0
0000412A= 4D 00                   1807  M             DC.B    'M',0
0000412C= 4C 00                   1808  L             DC.B    'L',0
0000412E= 51 00                   1809  Q             DC.B    'Q',0
00004130= 53 00                   1810  S             DC.B    'S',0
00004132= 45 00                   1811  E             DC.B    'E',0
00004134= 454D 0000               1812  EM            DC.W    'EM',0
00004138= 4541 0000               1813  EA            DC.W    'EA',0
0000413C                          1814  
0000413C                          1815  *below holds ascii size strings to load to variable SIZECODE            
0000413C= 2E42 0000               1816  SIZEB         DC.W    '.B',00
00004140= 2E57 0000               1817  SIZEW         DC.W    '.W',0
00004144= 2E4C 0000               1818  SIZEL         DC.W    '.L',00
00004148                          1819  SIZECODE      DS.L    1
0000414C                          1820  
0000414C                          1821  *below establishes lengths of data units
0000414C  =00000001               1822  byte_len      EQU     1
0000414C  =00000002               1823  word_len      EQU     2
0000414C  =00000004               1824  long_len      EQU     4            
0000414C                          1825                
0000414C                          1826  * holds the condition of each branch                
0000414C= 05                      1827  bcc_tbl       DC.B    %0101 *BCS
0000414D= 0C                      1828                DC.B    %1100 *BGE
0000414E= 0D                      1829                DC.B    %1101 *BLT
0000414F= 08                      1830                DC.B    %1000 *BVC
00004150= 00                      1831                DC.B    %0000 *BRA  
00004151= 04                      1832                DC.B    %0100 *BCC
00004152= 06                      1833                DC.B    %0110 *BNE
00004153= 07                      1834                DC.B    %0111 *BEQ
00004154= 09                      1835                DC.B    %1001 *BVS
00004155= 0E                      1836                DC.B    %1110 *BGT
00004156= 0F                      1837                DC.B    %1111 *BLE   
00004157= FF                      1838                DC.B    -1    *invalid branch type
00004158                          1839                
00004158                          1840  *below holds shift counts for arithmetic/logical shifts
00004158= 00                      1841  shift_tbl     DC.B    %000
00004159= 01                      1842                DC.B    %001
0000415A= 02                      1843                DC.B    %010
0000415B= 03                      1844                DC.B    %011
0000415C= 04                      1845                DC.B    %100
0000415D= 05                      1846                DC.B    %101
0000415E= 06                      1847                DC.B    %110
0000415F= 07                      1848                DC.B    %111                              
00004160                          1849  
00004160                          1850  *below variables hold the name of the instruction
00004160                          1851  INST_NAME     DS.L    2         *holds the instruction to be printed (e.g. ADD.L; MOVE.B)
00004168                          1852  INST_NAME_EXT DS.L    1         *holds any part of instruction over 32 bits (eg last M in MOVEM)
0000416C                          1853  
0000416C                          1854  *below characters are used for printing
0000416C= 24 00                   1855  addr_sign     DC.B    '$',0
0000416E= 23 00                   1856  imm_sign      DC.B    '#',0
00004170= 28 00                   1857  open_paren    DC.B    '(',0
00004172= 29 00                   1858  closed_paren  DC.B    ')',0
00004174= 2B 00                   1859  plus_sign     DC.B    '+',0
00004176= 2D 00                   1860  neg_sign      DC.B    '-',0
00004178= 2C 00                   1861  comma         DC.B    ',',0
0000417A= 2F 00                   1862  slash         DC.B    '/',0
0000417C= 0D 0A 00                1863  nl            DC.B    '',CR,LF,0
0000417F= 20 20 20 20 00          1864  space         DC.B    '    ',0
00004184                          1865  
00004184                          1866  *below holds intro messages to user                       
00004184= 50 6C 65 61 73 65 ...   1867  display_start DC.B    'Please enter a maximum 32-bit starting memory address in hex (-1 to quit): ',0
000041D0= 50 6C 65 61 73 65 ...   1868  display_end   DC.B    'Please enter a maximum 32-bit ending memory address in hex (-1 to quit): ',0
0000421A= 50 6C 65 61 73 65 ...   1869  bad_addr      DC.B    'Please enter a valid address',CR,LF,0
00004239                          1870  
00004239                          1871  
00004239                          1872  *below variables store the starting and ending addresses the user provides
0000423A                          1873  user_start    DS.L    1
0000423E                          1874  user_end      DS.L    1
00004242                          1875  
00004242= 2D31                    1876  exit_val      DC.W    $2D31  *sentinel exit value
00004244                          1877               
00004244= 64 6F 6E 65 00          1878  done_msg      DC.B    'done',0
00004249                          1879  
00004249                          1880  
00004249                          1881                END     start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A                   4124
A0_MESS             1F5E
A1_MESS             1F70
A2_MESS             1F82
A3_MESS             1F94
A4_MESS             1FA6
A5_MESS             1FB8
A6_MESS             1FCA
A7_MESS             1FDC
ADD                 406C
ADDA_BEG            135C
ADDA_HANDLER        1352
ADDA_LONG_HANDLER   1382
ADDA_SAVE_DATA      1390
ADDA_WORD_HANDLER   1370
ADDI_HANDLER        1766
ADDQ_HANDLER        1610
ADDRESS_MODE        1D44
ADDR_ERR            2110
ADDR_SIGN           416C
ADD_HANDLER         1496
AS                  4098
AS_HANDLER          1A30
AS_REG              1AE4
BAD_ADDR            421A
BCC                 40C8
BCCD_HANDLER        1918
BCC_CALC            1986
BCC_COMPLETE        199A
BCC_COND            1866
BCC_DETERMINER      1876
BCC_DISPM           196C
BCC_HANDLER         185A
BCC_LONG_HANDLER    1996
BCC_TBL             414C
BCC_WORD_HANDLER    1992
BCL                 4074
BCLR_DYNAMIC        16F6
BCLR_STATIC         16AC
BCS                 40A0
BCS_HANDLER         18D2
BEQ                 40D8
BEQ_HANDLER         1934
BGE                 40A8
BGE_HANDLER         18E0
BGT                 40E8
BGT_HANDLER         1950
BLE                 40F0
BLE_HANDLER         195E
BLT                 40B0
BLT_HANDLER         18EE
BNE                 40D0
BNE_HANDLER         1926
BRA                 40C0
BRA_HANDLER         190A
BVC                 40B8
BVC_HANDLER         18FC
BVS                 40E0
BVS_HANDLER         1942
BYTE_LEN            1
CASE_QUICK8         160A
CHECK_FIRST         1064
CLOSED_PARAN        1D90
CLOSED_PAREN        4172
CMP                 408C
CMPA_HANDLER        13C4
CMPA_OR_CMP         12C4
CMPI_BYTE           1650
CMPI_HANDLER        161E
CMPI_LONG           1674
CMPI_RET            1682
CMPI_WORD           1662
CMP_HANDLER         14E2
COMMA               4178
CR                  D
D0_MESS             1ECE
D1_MESS             1EE0
D2_MESS             1EF2
D3_MESS             1F04
D4_MESS             1F16
D5_MESS             1F28
D6_MESS             1F3A
D7_MESS             1F4C
DAT                 4114
DATA                4000
DATA_MODE           1E84
DATA_MODE_PRINT     1EA6
DATA_REGISTER       1D4C
DISPLAY_END         41D0
DISPLAY_START       4184
DISP_INSTR          1FE0
DIV                 4108
DIVSW_BEG           1508
DIVSW_HANDLER       14F4
DONE                20F2
DONE_MSG            4244
DR_CMP              1D50
E                   4132
EA                  4138
EA_SRC              1CDE
EA_SRC_BEG          1CDA
EM                  4134
EOR                 4084
EORI_HANDLER        1798
EOR_HANDLER         14D0
EXIT_VAL            4242
FATAL_ERR           212A
FILTER_EA_MODE      1D12
GET_DATA            1312
H2A_F               2064
H2A_ITS             8
H2A_LOOP            2050
H2A_MATCH           206C
H2A_MATCH_CONT      2070
H2A_PREP            2048
H2A_REGS            117A
H2A_RET             2094
H2A_SWAP            208E
HEX_1               4020
HEX_2_ASCII         2034
I                   4126
IMM_SIGN            416E
INST_NAME           4160
INST_NAME_EXT       4168
INST_PARSE          10AC
INV                 411C
INVALID_MODE        1D34
INV_BCC_HANDLER     19B2
INV_BCC_LONG        19D2
INV_BCC_WORD        19CA
INV_HANDLER         1076
IS_IT_MOVEM         1220
JSR                 4054
JSR_HANDLER         1B9C
L                   412C
LEA                 4044
LEA_HANDLER         1B68
LEA_RESOLVE         1204
LF                  A
LONG_DATA_HANDLER   1EA0
LONG_LEN            4
LONG_MODE           1E6A
LS                  4094
LS_HANDLER          1A3E
LS_REG              1AF2
M                   412A
MATCH_FOUND         10A0
MOV                 403C
MOVEA_HANDLER       112E
MOVEM_A7_PRINT      1C9A
MOVEM_AN            1BD8
MOVEM_AN_LAST       1C90
MOVEM_AN_LIST_LOOP  1C66
MOVEM_AN_LIST_PREP  1C60
MOVEM_AN_LIST_STATUS_1  1C78
MOVEM_CHECK         1230
MOVEM_D7_PRINT      1C52
MOVEM_DN            1BFC
MOVEM_DN_LAST       1C48
MOVEM_DN_LIST_LOOP  1C1E
MOVEM_DN_LIST_STATUS_1  1C30
MOVEM_EA            1CAA
MOVEM_HANDLER       1BBC
MOVEM_LIST          1C04
MOVEM_LONG          1BEE
MOVEM_RESOLVE       1216
MOVEM_WORD          1BE0
MOVE_EA             1138
MOVE_HANDLER        1120
MUL                 4100
MULS_HANDLER        1536
NEG                 404C
NEG_BYTE            1824
NEG_HANDLER         17FC
NEG_LONG            1840
NEG_RESOLVE         11E6
NEG_RET             184A
NEG_SIGN            4176
NEG_WORD            1832
NL                  417C
NOP                 4064
NOP_HANDLER         133A
OPEN_PAREN          4170
OR                  4110
ORI                 407C
ORI_HANDLER         1732
OR_BYTE             141C
OR_DN_LEFT          13FA
OR_DN_RIGHT         13F0
OR_EA               144E
OR_HANDLER          13D0
OR_LEFT_PRINT       147E
OR_LONG             1440
OR_SIZE             1404
OR_WORD             142E
PLUS_SIGN           4174
POSTFIX_PLUS        1DF4
PREFIX_MINUS        1E22
PREP                1014
PRINT_A0            1F50
PRINT_A1            1F62
PRINT_A2            1F74
PRINT_A3            1F86
PRINT_A4            1F98
PRINT_A5            1FAA
PRINT_A6            1FBC
PRINT_A7            1FCE
PRINT_ADDR_SGN      20B0
PRINT_COMMA         209A
PRINT_D0            1EC0
PRINT_D1            1ED2
PRINT_D2            1EE4
PRINT_D3            1EF6
PRINT_D4            1F08
PRINT_D5            1F1A
PRINT_D6            1F2C
PRINT_D7            1F3E
PRINT_HYPHEN        20DC
PRINT_INNER_AN      1DB4
PRINT_SLASH         20C6
Q                   412E
Q_PRINTS            15E8
R                   4128
RO                  409C
RO_HANDLER          1A4C
RO_REG              1B00
RS_0_SHIFT_HANDLER  1B3E
RTS                 405C
RTS_HANDLER         1CC0
S                   4130
SHIFT_TBL           4158
SIZEB               413C
SIZECODE            4148
SIZEL               4144
SIZEW               4140
SLASH               417A
SPACE               417F
SR_BYTE             1A9A
SR_LONG             1AB6
SR_MEM              1A14
SR_MEM_RET          1A5A
SR_REG              1A6E
SR_REG_FINAL        1B44
SR_REG_PRINT_DN     1B36
SR_REG_PRINT_IMM    1B22
SR_REG_PRINT_SRC    1B0E
SR_REG_RET          1AC4
SR_REG_TYPE         1A7C
SR_REG_TYPE_BEG     1A80
SR_TYPE_RESOLVE     19F4
SR_TYPE_RESOLVE_BEG  19FE
SR_WORD             1AA8
STACK               7000
START               1000
START_ADDR          1000
STRING_TBL          4000
SUB                 40F8
SUBA_HANDLER        13B8
SUBI_HANDLER        17CA
SUBQ_BYTE           159A
SUBQ_DET            1570
SUBQ_EA             15D2
SUBQ_HANDLER        1566
SUBQ_LONG           15BE
SUBQ_WORD           15AC
SUB_HANDLER         14AC
USER_END            423E
USER_START          423A
WORD_DATA_HANDLER   1E9A
WORD_LEN            2
WORD_MODE           1E50
_0_HANDLER          1250
_11_HANDLER         1296
_11_RESOLVE         12A6
_13_HANDLER         123A
_1_HANDLER          10F6
_2_HANDLER          118C
_3_HANDLER          1162
_4_HANDLER          11BA
_4_RESOLVE          11F6
_5_HANDLER          1302
_8_CHECK            12F0
_8_HANDLER          12D4
_SHIFT_ROLL_HANDLER  19DA
